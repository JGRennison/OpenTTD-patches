Index: src/table/settings.ini
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>; This file is part of OpenTTD.\n; OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.\n; OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n; See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.\n;\n\n[pre-amble]\n/* Begin - Callback Functions for the various settings */\nstatic bool v_PositionMainToolbar(int32 p1);\nstatic bool v_PositionStatusbar(int32 p1);\nstatic bool PopulationInLabelActive(int32 p1);\nstatic bool RedrawScreen(int32 p1);\nstatic bool RedrawSmallmap(int32 p1);\nstatic bool StationSpreadChanged(int32 p1);\nstatic bool InvalidateBuildIndustryWindow(int32 p1);\nstatic bool CloseSignalGUI(int32 p1);\nstatic bool InvalidateTownViewWindow(int32 p1);\nstatic bool DeleteSelectStationWindow(int32 p1);\nstatic bool UpdateConsists(int32 p1);\nstatic bool TrainAccelerationModelChanged(int32 p1);\nstatic bool RoadVehAccelerationModelChanged(int32 p1);\nstatic bool TrainSlopeSteepnessChanged(int32 p1);\nstatic bool RoadVehSlopeSteepnessChanged(int32 p1);\nstatic bool DragSignalsDensityChanged(int32);\nstatic bool ProgrammableSignalsShownChanged(int32);\nstatic bool VehListCargoFilterShownChanged(int32);\nstatic bool TownFoundingChanged(int32 p1);\nstatic bool DifficultyNoiseChange(int32 i);\nstatic bool DifficultyMoneyCheatMultiplayerChange(int32 i);\nstatic bool MaxNoAIsChange(int32 i);\nstatic bool CheckRoadSide(int p1);\nstatic bool ChangeMaxHeightLevel(int32 p1);\nstatic bool CheckFreeformEdges(int32 p1);\nstatic bool ChangeDynamicEngines(int32 p1);\nstatic bool StationCatchmentChanged(int32 p1);\nstatic bool InvalidateVehTimetableWindow(int32 p1);\nstatic bool UpdateTimeSettings(int32 p1);\nstatic bool ChangeTimeOverrideMode(int32 p1);\nstatic bool InvalidateCompanyLiveryWindow(int32 p1);\nstatic bool InvalidateNewGRFChangeWindows(int32 p1);\nstatic bool InvalidateIndustryViewWindow(int32 p1);\nstatic bool InvalidateAISettingsWindow(int32 p1);\nstatic bool RedrawTownAuthority(int32 p1);\nstatic bool InvalidateCompanyInfrastructureWindow(int32 p1);\nstatic bool InvalidateCompanyWindow(int32 p1);\nstatic bool ZoomMinMaxChanged(int32 p1);\nstatic bool MaxVehiclesChanged(int32 p1);\nstatic bool InvalidateShipPathCache(int32 p1);\nstatic bool ImprovedBreakdownsSettingChanged(int32 p1);\nstatic bool DayLengthChanged(int32 p1);\nstatic bool SimulatedWormholeSignalsChanged(int32 p1);\nstatic bool EnableSingleVehSharedOrderGuiChanged(int32 p1);\nstatic bool CheckYapfRailSignalPenalties(int32 p1);\nstatic bool ViewportMapShowTunnelModeChanged(int32 p1);\nstatic bool UpdateLinkgraphColours(int32 p1);\nstatic bool TLSettingChanged(int32 p1);\nstatic bool RSSettingChanged(int32 p1);\nstatic bool UpdateClientName(int32 p1);\nstatic bool UpdateServerPassword(int32 p1);\nstatic bool UpdateRconPassword(int32 p1);\nstatic bool UpdateSettingsPassword(int32 p1);\nstatic bool UpdateClientConfigValues(int32 p1);\nstatic bool CheckSharingRail(int32 p1);\nstatic bool CheckSharingRoad(int32 p1);\nstatic bool CheckSharingWater(int32 p1);\nstatic bool CheckSharingAir(int32 p1);\n\nextern int32 _old_ending_year_slv_105;\n\n/* End - Callback Functions for the various settings */\n\n/* Begin - GUI order callbacks */\n\nstatic int OrderTownGrowthRate(uint nth);\n\n/* End - GUI order callbacks */\n\n/* Begin - xref conversion callbacks */\n\nstatic int64 LinkGraphDistModeXrefChillPP(int64 val);\n\n/* End - xref conversion callbacks */\n\nstatic const SettingDescEnumEntry _linkgraph_mode_symmetric[] = {\n{ DT_MANUAL, STR_CONFIG_SETTING_DISTRIBUTION_MANUAL },\n{ DT_SYMMETRIC, STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC },\n{ DT_ASYMMETRIC, STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC },\n{ DT_ASYMMETRIC_EQ, STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC_EQ },\n{ DT_ASYMMETRIC_NEAR, STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC_NEAREST },\n{ 0, STR_NULL }\n};\nstatic const SettingDescEnumEntry _linkgraph_mode_asymmetric[] = {\n{ DT_MANUAL, STR_CONFIG_SETTING_DISTRIBUTION_MANUAL },\n{ DT_ASYMMETRIC, STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC },\n{ DT_ASYMMETRIC_EQ, STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC_EQ },\n{ DT_ASYMMETRIC_NEAR, STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC_NEAREST },\n{ 0, STR_NULL }\n};\nstatic const SettingDescEnumEntry _linkgraph_mode_per_cargo[] = {\n{ DT_PER_CARGO_DEFAULT, STR_CONFIG_SETTING_DISTRIBUTION_PER_CARGO_DEFAULT },\n{ DT_MANUAL, STR_CONFIG_SETTING_DISTRIBUTION_MANUAL },\n{ DT_SYMMETRIC, STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC },\n{ DT_ASYMMETRIC, STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC },\n{ DT_ASYMMETRIC_EQ, STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC_EQ },\n{ DT_ASYMMETRIC_NEAR, STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC_NEAREST },\n{ 0, STR_NULL }\n};\n\n/* Some settings do not need to be synchronised when playing in multiplayer.\n * These include for example the GUI settings and will not be saved with the\n * savegame.\n * It is also a bit tricky since you would think that service_interval\n * for example doesn't need to be synched. Every client assigns the\n * service_interval value to the v->service_interval, meaning that every client\n * assigns his value. If the setting was company-based, that would mean that\n * vehicles could decide on different moments that they are heading back to a\n * service depot, causing desyncs on a massive scale. */\nconst SettingDesc _settings[] = {\n[post-amble]\n};\n[templates]\nSDTG_BOOL  =  SDTG_BOOL($name,              $flags, $guiflags, $var, $def,                        $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname),\nSDTG_VAR   =   SDTG_VAR($name,       $type, $flags, $guiflags, $var, $def, $min, $max, $interval, $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname, $orderproc),\nSDTG_ENUM   = SDTG_ENUM($name,       $type, $flags, $guiflags, $var, $def,                        $str, $strhelp,          $proc, $from, $to,        $cat, $extver, $patxname,             $enumlist),\nSDTG_OMANY = SDTG_OMANY($name,       $type, $flags, $guiflags, $var, $def,       $max, $full,     $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname),\nSDTC_BOOL  =  SDTC_BOOL(       $var,        $flags, $guiflags, $def,                              $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname),\nSDTC_LIST  =  SDTC_LIST(       $var, $type, $flags, $guiflags, $def,                              $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname),\nSDTC_OMANY = SDTC_OMANY(       $var, $type, $flags, $guiflags, $def,             $max, $full,     $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname),\nSDTC_STR   =   SDTC_STR(       $var, $type, $flags, $guiflags, $def,                              $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname),\nSDTC_VAR   =   SDTC_VAR(       $var, $type, $flags, $guiflags, $def,       $min, $max, $interval, $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname, $orderproc),\nSDT_BOOL   =   SDT_BOOL($base, $var,        $flags, $guiflags, $def,                              $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname),\nSDT_OMANY  =  SDT_OMANY($base, $var, $type, $flags, $guiflags, $def,             $max, $full,     $str, $strhelp, $strval, $proc, $from, $to, $load, $cat, $extver, $patxname),\nSDT_STR    =    SDT_STR($base, $var, $type, $flags, $guiflags, $def,                              $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname),\nSDT_VAR    =    SDT_VAR($base, $var, $type, $flags, $guiflags, $def,       $min, $max, $interval, $str, $strhelp, $strval, $proc, $from, $to,        $cat, $extver, $patxname, $orderproc),\nSDT_ENUM   =   SDT_ENUM($base, $var, $type, $flags, $guiflags, $def,                              $str, $strhelp,          $proc, $from, $to,        $cat, $extver, $patxname,             $enumlist),\nSDT_NULL   =   SDT_NULL($length, $from, $to, $extver),\nSDT_XREF     = SDT_XREF(         $from, $to, $extver, $xref, $xrefcvt),\nSDT_END    = SDT_END()\n\nSDT_LINKGRAPH_PER_CARGO = SDT_ENUM(GameSettings, linkgraph.distribution_per_cargo[$linkgraph_cargo], SLE_UINT8, $flags | SLF_NOT_IN_CONFIG, $guiflags | SGF_NO_NEWGAME, DT_PER_CARGO_DEFAULT, STR_CONFIG_SETTING_DISTRIBUTION_PER_CARGO, STR_CONFIG_SETTING_DISTRIBUTION_PER_CARGO_HELPTEXT, $proc, $from, $to, SC_EXPERT, SlXvFeatureTest(XSLFTO_AND, XSLFI_LINKGRAPH_MODES), nullptr, _linkgraph_mode_per_cargo),\n\n[defaults]\nflags    = 0\nguiflags = SGF_NONE\ninterval = 0\nstr      = STR_NULL\nstrhelp  = STR_CONFIG_SETTING_NO_EXPLANATION_AVAILABLE_HELPTEXT\nstrval   = STR_NULL\nproc     = nullptr\nload     = nullptr\nfrom     = SL_MIN_VERSION\nto       = SL_MAX_VERSION\ncat      = SC_ADVANCED\nextver   = SlXvFeatureTest()\npatxname = nullptr\nxref     = <this parameter must be set>\nxrefcvt  = nullptr\norderproc = nullptr\nenumlist = <this parameter must be set>\n\n\n\n; Saved settings variables.\n; Do not ADD or REMOVE something in this \"difficulty.XXX\" table or before it. It breaks savegame compatibility.\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.max_no_competitors\ntype     = SLE_UINT8\nfrom     = SLV_97\ndef      = 0\nmin      = 0\nmax      = MAX_COMPANIES - 1\ninterval = 1\nproc     = MaxNoAIsChange\ncat      = SC_BASIC\n\n[SDT_NULL]\nlength   = 1\nfrom     = SLV_97\nto       = SLV_110\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.number_towns\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_NEWGAME_ONLY\ndef      = 2\nmin      = 0\nmax      = 4\ninterval = 1\nstrval   = STR_NUM_VERY_LOW\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.industry_density\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_MULTISTRING\ndef      = ID_END - 1\nmin      = 0\nmax      = ID_END - 1\ninterval = 1\nstr      = STR_CONFIG_SETTING_INDUSTRY_DENSITY\nstrhelp  = STR_CONFIG_SETTING_INDUSTRY_DENSITY_HELPTEXT\nstrval   = STR_FUNDING_ONLY\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.max_loan\ntype     = SLE_UINT32\nfrom     = SLV_97\nguiflags = SGF_NEWGAME_ONLY | SGF_SCENEDIT_TOO | SGF_CURRENCY\ndef      = 300000\nmin      = 100000\nmax      = 5000000\ninterval = 50000\nstr      = STR_CONFIG_SETTING_MAXIMUM_INITIAL_LOAN\nstrhelp  = STR_CONFIG_SETTING_MAXIMUM_INITIAL_LOAN_HELPTEXT\nstrval   = STR_JUST_CURRENCY_LONG\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.initial_interest\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_NEWGAME_ONLY | SGF_SCENEDIT_TOO\ndef      = 2\nmin      = 2\nmax      = 4\ninterval = 1\nstr      = STR_CONFIG_SETTING_INTEREST_RATE\nstrhelp  = STR_CONFIG_SETTING_INTEREST_RATE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.vehicle_costs\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_NEWGAME_ONLY | SGF_SCENEDIT_TOO | SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_RUNNING_COSTS\nstrhelp  = STR_CONFIG_SETTING_RUNNING_COSTS_HELPTEXT\nstrval   = STR_SEA_LEVEL_LOW\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.competitor_speed\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 0\nmax      = 4\ninterval = 1\nstr      = STR_CONFIG_SETTING_CONSTRUCTION_SPEED\nstrhelp  = STR_CONFIG_SETTING_CONSTRUCTION_SPEED_HELPTEXT\nstrval   = STR_AI_SPEED_VERY_SLOW\ncat      = SC_BASIC\n\n[SDT_NULL]\nlength   = 1\nfrom     = SLV_97\nto       = SLV_110\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.vehicle_breakdowns\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_VEHICLE_BREAKDOWNS\nstrhelp  = STR_CONFIG_SETTING_VEHICLE_BREAKDOWNS_HELPTEXT\nstrval   = STR_DISASTER_NONE\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.subsidy_multiplier\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 0\nmax      = 3\ninterval = 1\nstr      = STR_CONFIG_SETTING_SUBSIDY_MULTIPLIER\nstrhelp  = STR_CONFIG_SETTING_SUBSIDY_MULTIPLIER_HELPTEXT\nstrval   = STR_SUBSIDY_X1_5\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.construction_cost\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_NEWGAME_ONLY | SGF_SCENEDIT_TOO | SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_CONSTRUCTION_COSTS\nstrhelp  = STR_CONFIG_SETTING_CONSTRUCTION_COSTS_HELPTEXT\nstrval   = STR_SEA_LEVEL_LOW\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.terrain_type\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_MULTISTRING | SGF_NEWGAME_ONLY\ndef      = 1\nmin      = 0\nmax      = 4\ninterval = 1\nstr      = STR_CONFIG_SETTING_TERRAIN_TYPE\nstrhelp  = STR_CONFIG_SETTING_TERRAIN_TYPE_HELPTEXT\nstrval   = STR_TERRAIN_TYPE_VERY_FLAT\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.quantity_sea_lakes\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_NEWGAME_ONLY\ndef      = 0\nmin      = 0\nmax      = 4\ninterval = 1\nstrval   = STR_SEA_LEVEL_VERY_LOW\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = difficulty.economy\nfrom     = SLV_97\ndef      = false\nstr      = STR_CONFIG_SETTING_RECESSIONS\nstrhelp  = STR_CONFIG_SETTING_RECESSIONS_HELPTEXT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = difficulty.line_reverse_mode\nfrom     = SLV_97\ndef      = false\nstr      = STR_CONFIG_SETTING_TRAIN_REVERSING\nstrhelp  = STR_CONFIG_SETTING_TRAIN_REVERSING_HELPTEXT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = difficulty.disasters\nfrom     = SLV_97\ndef      = false\nstr      = STR_CONFIG_SETTING_DISASTERS\nstrhelp  = STR_CONFIG_SETTING_DISASTERS_HELPTEXT\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = difficulty.town_council_tolerance\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_CITY_APPROVAL\nstrhelp  = STR_CONFIG_SETTING_CITY_APPROVAL_HELPTEXT\nstrval   = STR_CITY_APPROVAL_PERMISSIVE\nproc     = DifficultyNoiseChange\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = difficulty.money_cheat_in_multiplayer\ndef      = false\nstr      = STR_CONFIG_SETTING_MONEY_CHEAT_MULTIPLAYER\nstrhelp  = STR_CONFIG_SETTING_MONEY_CHEAT_MULTIPLAYER_HELPTEXT\nproc     = DifficultyMoneyCheatMultiplayerChange\ncat      = SC_EXPERT\npatxname = \"\"cheat.difficulty.money_cheat_in_multiplayer\"\"\n\n[SDTG_VAR]\nname     = \"\"diff_level\"\"\nvar      = _old_diff_level\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_CONFIG\nfrom     = SLV_97\nto       = SLV_178\ndef      = 3\nmin      = 0\nmax      = 3\ncat      = SC_BASIC\n\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"order.old_timetable_separation\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = order.old_timetable_separation\ndef      = true\ncat      = SC_EXPERT\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_AUTO_TIMETABLE, 1, 3)\npatxname = \"\"auto_timetables.order.timetable_separation\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = order.old_timetable_separation_rate\ntype     = SLE_UINT8\ndef      = 100\nmin      = 0\nmax      = 100\ninterval = 10\nstr      = STR_CONFIG_SETTING_TIMETABLE_SEPARATION_RATE\nstrhelp  = STR_CONFIG_SETTING_TIMETABLE_SEPARATION_RATE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\ncat      = SC_EXPERT\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_AUTO_TIMETABLE, 1, 2)\npatxname = \"\"auto_timetables.order.timetable_separation_rate\"\"\n\n; There are only 21 predefined town_name values (0-20), but you can have more with newgrf action F so allow\n; these bigger values (21-255). Invalid values will fallback to english on use and (undefined string) in GUI.\n[SDT_OMANY]\nbase     = GameSettings\nvar      = game_creation.town_name\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_NO_NETWORK\ndef      = 0\nmax      = 255\nfull     = _town_names\ncat      = SC_BASIC\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = game_creation.landscape\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_MULTISTRING | SGF_NEWGAME_ONLY\ndef      = 0\nmax      = 3\nfull     = _climates\nload     = ConvertLandscape\nstr      = STR_CONFIG_SETTING_LANDSCAPE\nstrhelp  = STR_CONFIG_SETTING_LANDSCAPE_HELPTEXT\nstrval   = STR_CHEAT_SWITCH_CLIMATE_TEMPERATE_LANDSCAPE\ncat      = SC_BASIC\n\n; Snow line upper byte\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n; Snow line (or snow_line_height * TILE_HEIGHT)\n[SDT_NULL]\nlength   = 1\nfrom     = SLV_97\nto       = SLV_164\n\n;;game_creation.desert_amount\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n;;game_creation.tree_line\n[SDT_NULL]\nlength   = 2\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = vehicle.road_side\ntype     = SLE_UINT8\nfrom     = SLV_97\nguiflags = SGF_MULTISTRING | SGF_NO_NETWORK\ndef      = 1\nmax      = 1\nfull     = _roadsides\nstr      = STR_CONFIG_SETTING_ROAD_SIDE\nstrhelp  = STR_CONFIG_SETTING_ROAD_SIDE_HELPTEXT\nstrval   = STR_GAME_OPTIONS_ROAD_VEHICLES_DROPDOWN_LEFT\nproc     = CheckRoadSide\n\n; Construction\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.max_heightlevel\ntype     = SLE_UINT8\nfrom     = SLV_194\nguiflags = SGF_NEWGAME_ONLY | SGF_SCENEDIT_TOO\ndef      = DEF_MAX_HEIGHTLEVEL\nmin      = MIN_MAX_HEIGHTLEVEL\nmax      = MAX_MAX_HEIGHTLEVEL\ninterval = 1\nstr      = STR_CONFIG_SETTING_MAX_HEIGHTLEVEL\nstrhelp  = STR_CONFIG_SETTING_MAX_HEIGHTLEVEL_HELPTEXT\nstrval   = STR_JUST_INT\nproc     = ChangeMaxHeightLevel\ncat      = SC_BASIC\nextver   = SlXvFeatureTest(XSLFTO_OR, XSLFI_HEIGHT_8_BIT, 1, 1)\n\n;; construction.allow_more_heightlevels\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.build_on_slopes\nguiflags = SGF_NO_NETWORK\ndef      = true\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.command_pause_level\ntype     = SLE_UINT8\nfrom     = SLV_154\nguiflags = SGF_MULTISTRING | SGF_NO_NETWORK\ndef      = 1\nmin      = 0\nmax      = 3\ninterval = 1\nstr      = STR_CONFIG_SETTING_COMMAND_PAUSE_LEVEL\nstrhelp  = STR_CONFIG_SETTING_COMMAND_PAUSE_LEVEL_HELPTEXT\nstrval   = STR_CONFIG_SETTING_COMMAND_PAUSE_LEVEL_NO_ACTIONS\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.enable_build_river\ndef      = false\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_ENABLE_BUILD_RIVER\nstrhelp  = STR_CONFIG_SETTING_ENABLE_BUILD_RIVER_HELPTEXT\npatxname = \"\"enable_build_river.construction.enable_build_river\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.enable_remove_water\ndef      = true\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_ENABLE_REMOVE_WATER\nstrhelp  = STR_CONFIG_SETTING_ENABLE_REMOVE_WATER_HELPTEXT\npatxname = \"\"enable_build_river.construction.enable_remove_water\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.terraform_per_64k_frames\ntype     = SLE_UINT32\nfrom     = SLV_156\ndef      = 64 << 16\nmin      = 0\nmax      = 1 << 30\ninterval = 1\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.terraform_frame_burst\ntype     = SLE_UINT16\nfrom     = SLV_156\ndef      = 4096\nmin      = 0\nmax      = 1 << 30\ninterval = 1\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.clear_per_64k_frames\ntype     = SLE_UINT32\nfrom     = SLV_156\ndef      = 64 << 16\nmin      = 0\nmax      = 1 << 30\ninterval = 1\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.clear_frame_burst\ntype     = SLE_UINT16\nfrom     = SLV_156\ndef      = 4096\nmin      = 0\nmax      = 1 << 30\ninterval = 1\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.tree_per_64k_frames\ntype     = SLE_UINT32\nfrom     = SLV_175\ndef      = 64 << 16\nmin      = 0\nmax      = 1 << 30\ninterval = 1\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.tree_frame_burst\ntype     = SLE_UINT16\nfrom     = SLV_175\ndef      = 4096\nmin      = 0\nmax      = 1 << 30\ninterval = 1\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.purchase_land_per_64k_frames\ntype     = SLE_UINT32\ndef      = 16 << 16\nmin      = 0\nmax      = 1 << 30\ninterval = 1\ncat      = SC_EXPERT\npatxname = \"\"buy_land_rate_limit.construction.purchase_land_per_64k_frames\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.purchase_land_frame_burst\ntype     = SLE_UINT16\ndef      = 1024\nmin      = 0\nmax      = 1 << 30\ninterval = 1\ncat      = SC_EXPERT\npatxname = \"\"buy_land_rate_limit.construction.purchase_land_frame_burst\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.autoslope\nfrom     = SLV_75\ndef      = true\nstr      = STR_CONFIG_SETTING_AUTOSLOPE\nstrhelp  = STR_CONFIG_SETTING_AUTOSLOPE_HELPTEXT\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.extra_dynamite\ndef      = true\nstr      = STR_CONFIG_SETTING_EXTRADYNAMITE\nstrhelp  = STR_CONFIG_SETTING_EXTRADYNAMITE_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.max_bridge_length\ntype     = SLE_UINT16\nfrom     = SLV_159\nguiflags = SGF_NO_NETWORK\ndef      = 64\nmin      = 1\nmax      = 4096\ninterval = 1\nstr      = STR_CONFIG_SETTING_MAX_BRIDGE_LENGTH\nstrhelp  = STR_CONFIG_SETTING_MAX_BRIDGE_LENGTH_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TILE_LENGTH\n\n[SDT_XREF]\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP, 2)\nxref     = \"\"construction.simulated_wormhole_signals\"\"\n\n[SDT_XREF]\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\nxref     = \"\"construction.simulated_wormhole_signals\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.max_bridge_height\ntype     = SLE_UINT8\nfrom     = SLV_194\nguiflags = SGF_NO_NETWORK\ndef      = 12\nmin      = 1\nmax      = MAX_TILE_HEIGHT\ninterval = 1\nstr      = STR_CONFIG_SETTING_MAX_BRIDGE_HEIGHT\nstrhelp  = STR_CONFIG_SETTING_MAX_BRIDGE_HEIGHT_HELPTEXT\nstrval   = STR_JUST_COMMA\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.max_tunnel_length\ntype     = SLE_UINT16\nfrom     = SLV_159\nguiflags = SGF_NO_NETWORK\ndef      = 64\nmin      = 1\nmax      = 4096\ninterval = 1\nstr      = STR_CONFIG_SETTING_MAX_TUNNEL_LENGTH\nstrhelp  = STR_CONFIG_SETTING_MAX_TUNNEL_LENGTH_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TILE_LENGTH\n\n;; construction.max_chunnel_exit_length\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_233)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.chunnel\ndef      = false\nstr      = STR_CONFIG_SETTING_CHUNNEL\nstrhelp  = STR_CONFIG_SETTING_CHUNNEL_HELPTEXT\ncat      = SC_BASIC\npatxname = \"\"chunnel.construction.chunnel\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.simulated_wormhole_signals\ntype     = SLE_UINT8\nflags    = 0\ndef      = 2\nmin      = 1\nmax      = 16\nstr      = STR_CONFIG_SETTING_SIMULATE_SIGNALS\nstrval   = STR_CONFIG_SETTING_SIMULATE_SIGNALS_VALUE\nproc     = SimulatedWormholeSignalsChanged\ncat      = SC_BASIC\npatxname = \"\"signal_tunnel_bridge.construction.simulated_wormhole_signals\"\"\n\n[SDT_XREF]\nxref     = \"\"construction.maximum_signal_evaluations\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"construction.chunnel\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n;; construction.longbridges\n[SDT_NULL]\nlength   = 1\nto       = SLV_159\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.train_signal_side\ntype     = SLE_UINT8\nguiflags = SGF_MULTISTRING | SGF_NO_NETWORK\ndef      = 1\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_SIGNALSIDE\nstrhelp  = STR_CONFIG_SETTING_SIGNALSIDE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_SIGNALSIDE_LEFT\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = station.never_expire_airports\nguiflags = SGF_NO_NETWORK\ndef      = false\nstr      = STR_CONFIG_SETTING_NEVER_EXPIRE_AIRPORTS\nstrhelp  = STR_CONFIG_SETTING_NEVER_EXPIRE_AIRPORTS_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.town_layout\ntype     = SLE_UINT8\nfrom     = SLV_59\nguiflags = SGF_MULTISTRING\ndef      = TL_ORIGINAL\nmin      = TL_BEGIN\nmax      = NUM_TLS - 1\ninterval = 1\nstr      = STR_CONFIG_SETTING_TOWN_LAYOUT\nstrhelp  = STR_CONFIG_SETTING_TOWN_LAYOUT_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TOWN_LAYOUT_DEFAULT\nproc     = TownFoundingChanged\n\n;; economy.town_construction_cost\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.station_rating_type\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.scale_industry_production\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP, 7)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.allow_town_roads\nfrom     = SLV_113\nguiflags = SGF_NO_NETWORK\ndef      = true\nstr      = STR_CONFIG_SETTING_ALLOW_TOWN_ROADS\nstrhelp  = STR_CONFIG_SETTING_ALLOW_TOWN_ROADS_HELPTEXT\n\n[SDT_XREF]\nxref     = \"\"economy.old_town_cargo_factor\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.day_length_factor\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.found_town\ntype     = SLE_UINT8\nfrom     = SLV_128\nguiflags = SGF_MULTISTRING\ndef      = TF_FORBIDDEN\nmin      = TF_BEGIN\nmax      = TF_END - 1\ninterval = 1\nstr      = STR_CONFIG_SETTING_TOWN_FOUNDING\nstrhelp  = STR_CONFIG_SETTING_TOWN_FOUNDING_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TOWN_FOUNDING_FORBIDDEN\nproc     = TownFoundingChanged\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.allow_town_level_crossings\nfrom     = SLV_143\nguiflags = SGF_NO_NETWORK\ndef      = true\nstr      = STR_CONFIG_SETTING_ALLOW_TOWN_LEVEL_CROSSINGS\nstrhelp  = STR_CONFIG_SETTING_ALLOW_TOWN_LEVEL_CROSSINGS_HELPTEXT\n\n[SDT_XREF]\nxref     = \"\"economy.old_town_cargo_factor\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.town_cargogen_mode\ntype     = SLE_UINT8\nfrom     = SLV_TOWN_CARGOGEN\nguiflags = SGF_MULTISTRING\ndef      = TCGM_BITCOUNT\nmin      = TCGM_BEGIN\nmax      = TCGM_END - 1\ninterval = 1\nstr      = STR_CONFIG_SETTING_TOWN_CARGOGENMODE\nstrhelp  = STR_CONFIG_SETTING_TOWN_CARGOGENMODE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TOWN_CARGOGENMODE_ORIGINAL\ncat      = SC_ADVANCED\n\n;; economy.max_town_heightlevel\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n; link graph\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = linkgraph.recalc_interval\ntype     = SLE_UINT16\nfrom     = SLV_183\ndef      = 4\nmin      = 2\nmax      = 32\ninterval = 2\nstr      = STR_CONFIG_SETTING_LINKGRAPH_INTERVAL\nstrval   = STR_JUST_COMMA\nstrhelp  = STR_CONFIG_SETTING_LINKGRAPH_INTERVAL_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = linkgraph.recalc_time\ntype     = SLE_UINT16\nfrom     = SLV_183\ndef      = 16\nmin      = 1\nmax      = 4096\ninterval = 1\nstr      = STR_CONFIG_SETTING_LINKGRAPH_TIME\nstrval   = STR_JUST_COMMA\nstrhelp  = STR_CONFIG_SETTING_LINKGRAPH_TIME_HELPTEXT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = linkgraph.recalc_not_scaled_by_daylength\ndef      = true\nstr      = STR_CONFIG_SETTING_LINKGRAPH_NOT_DAYLENGTH_SCALED\nstrhelp  = STR_CONFIG_SETTING_LINKGRAPH_NOT_DAYLENGTH_SCALED_HELPTEXT\nextver   = SlXvFeatureTest([](uint16 version, bool version_in_range) -> bool { return version_in_range && SlXvIsFeaturePresent(XSLFI_LINKGRAPH_DAY_SCALE) && !SlXvIsFeaturePresent(XSLFI_JOKERPP); })\npatxname = \"\"linkgraph_day_scale.linkgraph.recalc_not_scaled_by_daylength\"\"\n\n[SDT_ENUM]\nbase     = GameSettings\nvar      = linkgraph.distribution_pax\ntype     = SLE_UINT8\nfrom     = SLV_183\ndef      = DT_MANUAL\nenumlist = _linkgraph_mode_symmetric\nstr      = STR_CONFIG_SETTING_DISTRIBUTION_PAX\nstrhelp  = STR_CONFIG_SETTING_DISTRIBUTION_PAX_HELPTEXT\n\n[SDT_ENUM]\nbase     = GameSettings\nvar      = linkgraph.distribution_mail\ntype     = SLE_UINT8\nfrom     = SLV_183\ndef      = DT_MANUAL\nenumlist = _linkgraph_mode_symmetric\nstr      = STR_CONFIG_SETTING_DISTRIBUTION_MAIL\nstrhelp  = STR_CONFIG_SETTING_DISTRIBUTION_MAIL_HELPTEXT\n\n[SDT_ENUM]\nbase     = GameSettings\nvar      = linkgraph.distribution_armoured\ntype     = SLE_UINT8\nfrom     = SLV_183\ndef      = DT_MANUAL\nenumlist = _linkgraph_mode_symmetric\nstr      = STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED\nstrhelp  = STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED_HELPTEXT\n\n[SDT_ENUM]\nbase     = GameSettings\nvar      = linkgraph.distribution_default\ntype     = SLE_UINT8\nfrom     = SLV_183\ndef      = DT_MANUAL\nenumlist = _linkgraph_mode_asymmetric\nstr      = STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT\nstrhelp  = STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT_HELPTEXT\n\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 0\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 1\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 2\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 3\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 4\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 5\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 6\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 7\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 8\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 9\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 10\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 11\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 12\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 13\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 14\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 15\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 16\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 17\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 18\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 19\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 20\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 21\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 22\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 23\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 24\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 25\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 26\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 27\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 28\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 29\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 30\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 31\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 32\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 33\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 34\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 35\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 36\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 37\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 38\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 39\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 40\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 41\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 42\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 43\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 44\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 45\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 46\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 47\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 48\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 49\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 50\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 51\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 52\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 53\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 54\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 55\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 56\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 57\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 58\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 59\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 60\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 61\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 62\n[SDT_LINKGRAPH_PER_CARGO]\nlinkgraph_cargo = 63\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = linkgraph.accuracy\ntype     = SLE_UINT8\nfrom     = SLV_183\ndef      = 16\nmin      = 2\nmax      = 64\ninterval = 1\nstr      = STR_CONFIG_SETTING_LINKGRAPH_ACCURACY\nstrval   = STR_JUST_COMMA\nstrhelp  = STR_CONFIG_SETTING_LINKGRAPH_ACCURACY_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = linkgraph.demand_distance\ntype     = SLE_UINT8\nfrom     = SLV_183\ndef      = 100\nmin      = 0\nmax      = 255\ninterval = 5\nstr      = STR_CONFIG_SETTING_DEMAND_DISTANCE\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\nstrhelp  = STR_CONFIG_SETTING_DEMAND_DISTANCE_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = linkgraph.demand_size\ntype     = SLE_UINT8\nfrom     = SLV_183\ndef      = 100\nmin      = 0\nmax      = 100\ninterval = 5\nstr      = STR_CONFIG_SETTING_DEMAND_SIZE\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\nstrhelp  = STR_CONFIG_SETTING_DEMAND_SIZE_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = linkgraph.short_path_saturation\ntype     = SLE_UINT8\nfrom     = SLV_183\ndef      = 80\nmin      = 0\nmax      = 250\ninterval = 5\nstr      = STR_CONFIG_SETTING_SHORT_PATH_SATURATION\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\nstrhelp  = STR_CONFIG_SETTING_SHORT_PATH_SATURATION_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.old_town_cargo_factor\ntype     = SLE_INT8\ndef      = 0\nmin      = -16\nmax      = +8\ninterval = 1\nstr      = STR_CONFIG_SETTING_TOWN_CARGO_FACTOR\nstrval   = STR_JUST_INT\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_TOWN_CARGO_ADJ, 1, 1)\npatxname = \"\"town_cargo_adj.economy.town_cargo_factor\"\"\n\n[SDT_XREF]\nxref     = \"\"economy.old_town_cargo_factor\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.town_cargo_scale_factor\ntype     = SLE_INT16\nguiflags = SGF_DECIMAL1\ndef      = 0\nmin      = -160\nmax      = +80\ninterval = 1\nstr      = STR_CONFIG_SETTING_TOWN_CARGO_FACTOR\nstrval   = STR_JUST_DECIMAL1\nstrhelp  = STR_CONFIG_SETTING_TOWN_CARGO_FACTOR_HELPTEXT\npatxname = \"\"town_cargo_adj.economy.town_cargo_scale_factor\"\"\n\n; Vehicles\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.train_acceleration_model\ntype     = SLE_UINT8\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 1\ninterval = 1\nstr      = STR_CONFIG_SETTING_TRAIN_ACCELERATION_MODEL\nstrhelp  = STR_CONFIG_SETTING_TRAIN_ACCELERATION_MODEL_HELPTEXT\nstrval   = STR_CONFIG_SETTING_ORIGINAL\nproc     = TrainAccelerationModelChanged\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.roadveh_acceleration_model\ntype     = SLE_UINT8\nfrom     = SLV_139\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 1\ninterval = 1\nstr      = STR_CONFIG_SETTING_ROAD_VEHICLE_ACCELERATION_MODEL\nstrhelp  = STR_CONFIG_SETTING_ROAD_VEHICLE_ACCELERATION_MODEL_HELPTEXT\nstrval   = STR_CONFIG_SETTING_ORIGINAL\nproc     = RoadVehAccelerationModelChanged\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.train_slope_steepness\ntype     = SLE_UINT8\nfrom     = SLV_133\ndef      = 3\nmin      = 0\nmax      = 10\ninterval = 1\nstr      = STR_CONFIG_SETTING_TRAIN_SLOPE_STEEPNESS\nstrhelp  = STR_CONFIG_SETTING_TRAIN_SLOPE_STEEPNESS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\nproc     = TrainSlopeSteepnessChanged\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.roadveh_slope_steepness\ntype     = SLE_UINT8\nfrom     = SLV_139\ndef      = 7\nmin      = 0\nmax      = 10\ninterval = 1\nstr      = STR_CONFIG_SETTING_ROAD_VEHICLE_SLOPE_STEEPNESS\nstrhelp  = STR_CONFIG_SETTING_ROAD_VEHICLE_SLOPE_STEEPNESS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\nproc     = RoadVehSlopeSteepnessChanged\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.forbid_90_deg\ndef      = false\nstr      = STR_CONFIG_SETTING_FORBID_90_DEG\nstrhelp  = STR_CONFIG_SETTING_FORBID_90_DEG_HELPTEXT\nproc     = InvalidateShipPathCache\ncat      = SC_EXPERT\n\n;; pf.back_of_one_way_pbs_waiting_point\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n;; pf.back_of_one_way_pbs_waiting_point\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_train_length\ntype     = SLE_UINT8\nfrom     = SLV_159\ndef      = 7\nmin      = 1\nmax      = 64\ninterval = 1\nstr      = STR_CONFIG_SETTING_TRAIN_LENGTH\nstrhelp  = STR_CONFIG_SETTING_TRAIN_LENGTH_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TILE_LENGTH\ncat      = SC_BASIC\n\n; vehicle.mammoth_trains\n[SDT_NULL]\nlength   = 1\nto       = SLV_159\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.smoke_amount\ntype     = SLE_UINT8\nfrom     = SLV_145\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_SMOKE_AMOUNT\nstrhelp  = STR_CONFIG_SETTING_SMOKE_AMOUNT_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NONE\n\n; order.gotodepot\n[SDT_NULL]\nlength   = 1\nto       = SLV_159\n\n;; order.gotodepot\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n; path finder\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.roadveh_queue\ndef      = true\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.reroute_rv_on_layout_change\ntype     = SLE_UINT8\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_REROUTE_RV_ON_LAYOUT_CHANGE\nstrhelp  = STR_CONFIG_SETTING_REROUTE_RV_ON_LAYOUT_CHANGE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_REROUTE_RV_ON_LAYOUT_CHANGE_NO\ncat      = SC_ADVANCED\npatxname = \"\"pf.reroute_rv_on_layout_change\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.new_pathfinding_all\nto       = SLV_87\ndef      = false\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.yapf.ship_use_yapf\nfrom     = SLV_28\nto       = SLV_87\ndef      = false\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.yapf.road_use_yapf\nfrom     = SLV_28\nto       = SLV_87\ndef      = true\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.yapf.rail_use_yapf\nfrom     = SLV_28\nto       = SLV_87\ndef      = true\ncat      = SC_EXPERT\n\n##\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.pathfinder_for_trains\ntype     = SLE_UINT8\nfrom     = SLV_87\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 1\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_PATHFINDER_FOR_TRAINS\nstrhelp  = STR_CONFIG_SETTING_PATHFINDER_FOR_TRAINS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PATHFINDER_NPF\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.pathfinder_for_roadvehs\ntype     = SLE_UINT8\nfrom     = SLV_87\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 1\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_PATHFINDER_FOR_ROAD_VEHICLES\nstrhelp  = STR_CONFIG_SETTING_PATHFINDER_FOR_ROAD_VEHICLES_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PATHFINDER_NPF\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.pathfinder_for_ships\ntype     = SLE_UINT8\nfrom     = SLV_87\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 1\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_PATHFINDER_FOR_SHIPS\nstrhelp  = STR_CONFIG_SETTING_PATHFINDER_FOR_SHIPS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PATHFINDER_NPF\nproc     = InvalidateShipPathCache\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.never_expire_vehicles\nguiflags = SGF_NO_NETWORK\ndef      = false\nstr      = STR_CONFIG_SETTING_NEVER_EXPIRE_VEHICLES\nstrhelp  = STR_CONFIG_SETTING_NEVER_EXPIRE_VEHICLES_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.no_expire_vehicles_after\ntype     = SLE_INT32\nguiflags = SGF_NO_NETWORK | SGF_0ISDISABLED\ndef      = 0\nmin      = MIN_YEAR\nmax      = MAX_YEAR\ninterval = 1\nstr      = STR_CONFIG_SETTING_NO_EXPIRE_VEHICLES_AFTER\nstrhelp  = STR_CONFIG_SETTING_NO_EXPIRE_VEHICLES_AFTER_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NO_EXPIRE_VEHICLES_AFTER_VALUE\ncat      = SC_EXPERT\npatxname = \"\"vehicle.no_expire_vehicles_after\"\"\n\n;; vehicle.exact_intro_date\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_trains\ntype     = SLE_UINT16\ndef      = 500\nmin      = 0\nmax      = 10000\nstr      = STR_CONFIG_SETTING_MAX_TRAINS\nstrhelp  = STR_CONFIG_SETTING_MAX_TRAINS_HELPTEXT\nstrval   = STR_JUST_COMMA\nproc     = MaxVehiclesChanged\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_roadveh\ntype     = SLE_UINT16\ndef      = 500\nmin      = 0\nmax      = 10000\nstr      = STR_CONFIG_SETTING_MAX_ROAD_VEHICLES\nstrhelp  = STR_CONFIG_SETTING_MAX_ROAD_VEHICLES_HELPTEXT\nstrval   = STR_JUST_COMMA\nproc     = MaxVehiclesChanged\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_aircraft\ntype     = SLE_UINT16\ndef      = 200\nmin      = 0\nmax      = 10000\nstr      = STR_CONFIG_SETTING_MAX_AIRCRAFT\nstrhelp  = STR_CONFIG_SETTING_MAX_AIRCRAFT_HELPTEXT\nstrval   = STR_JUST_COMMA\nproc     = MaxVehiclesChanged\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_ships\ntype     = SLE_UINT16\ndef      = 300\nmin      = 0\nmax      = 10000\nstr      = STR_CONFIG_SETTING_MAX_SHIPS\nstrhelp  = STR_CONFIG_SETTING_MAX_SHIPS_HELPTEXT\nstrval   = STR_JUST_COMMA\nproc     = MaxVehiclesChanged\ncat      = SC_BASIC\n\n[SDTG_BOOL]\nname     = nullptr\nguiflags = SGF_NO_NETWORK\nvar      = _old_vds.servint_ispercent\ndef      = false\nto       = SLV_120\n\n[SDTG_VAR]\nname     = nullptr\ntype     = SLE_UINT16\nguiflags = SGF_0ISDISABLED\nvar      = _old_vds.servint_trains\ndef      = 150\nmin      = 5\nmax      = 800\nto       = SLV_120\n\n[SDTG_VAR]\nname     = nullptr\ntype     = SLE_UINT16\nguiflags = SGF_0ISDISABLED\nvar      = _old_vds.servint_roadveh\ndef      = 150\nmin      = 5\nmax      = 800\nto       = SLV_120\n\n[SDTG_VAR]\nname     = nullptr\ntype     = SLE_UINT16\nguiflags = SGF_0ISDISABLED\nvar      = _old_vds.servint_ships\ndef      = 360\nmin      = 5\nmax      = 800\nto       = SLV_120\n\n[SDTG_VAR]\nname     = nullptr\ntype     = SLE_UINT16\nguiflags = SGF_0ISDISABLED\nvar      = _old_vds.servint_aircraft\ndef      = 150\nmin      = 5\nmax      = 800\nto       = SLV_120\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = order.no_servicing_if_no_breakdowns\ndef      = true\nstr      = STR_CONFIG_SETTING_NOSERVICE\nstrhelp  = STR_CONFIG_SETTING_NOSERVICE_HELPTEXT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.wagon_speed_limits\nguiflags = SGF_NO_NETWORK\ndef      = true\nstr      = STR_CONFIG_SETTING_WAGONSPEEDLIMITS\nstrhelp  = STR_CONFIG_SETTING_WAGONSPEEDLIMITS_HELPTEXT\nproc     = UpdateConsists\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.max_locomotive_speed_limits\ndef      = true\nstr      = STR_CONFIG_SETTING_MAXLOCOMOTIVESPEEDS\nstrhelp  = STR_CONFIG_SETTING_MAXLOCOMOTIVESPEEDS_HELPTEXT\nproc     = UpdateConsists\npatxname = \"\"vehicle.max_locomotive_speed_limits\"\"\n\n;; vehicle.slow_road_vehicles_in_curves\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP, SL_JOKER_1_25)\n\n;; vehicle.train_speed_adaption\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.disable_elrails\nfrom     = SLV_38\nguiflags = SGF_NO_NETWORK\ndef      = false\nstr      = STR_CONFIG_SETTING_DISABLE_ELRAILS\nstrhelp  = STR_CONFIG_SETTING_DISABLE_ELRAILS_HELPTEXT\nproc     = SettingsDisableElrail\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.freight_trains\ntype     = SLE_UINT8\nfrom     = SLV_39\nguiflags = SGF_NO_NETWORK\ndef      = 1\nmin      = 1\nmax      = 255\ninterval = 1\nstr      = STR_CONFIG_SETTING_FREIGHT_TRAINS\nstrhelp  = STR_CONFIG_SETTING_FREIGHT_TRAINS_HELPTEXT\nstrval   = STR_JUST_COMMA\nproc     = UpdateConsists\n\n;; vehicle.freight_mult_to_passengers\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; ticks_per_minute\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n; order.timetabling\n[SDT_NULL]\nlength   = 1\nfrom     = SLV_67\nto       = SLV_159\nextver   = SlXvFeatureTest(XSLFTO_OR, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n;;  order.timetable_automated\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_XREF]\nxref     = \"\"order.old_timetable_separation\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.plane_speed\ntype     = SLE_UINT8\nfrom     = SLV_90\nguiflags = SGF_NO_NETWORK\ndef      = 4\nmin      = 1\nmax      = 4\nstr      = STR_CONFIG_SETTING_PLANE_SPEED\nstrhelp  = STR_CONFIG_SETTING_PLANE_SPEED_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PLANE_SPEED_VALUE\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.dynamic_engines\nfrom     = SLV_95\nguiflags = SGF_NO_NETWORK\ndef      = true\nproc     = ChangeDynamicEngines\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.plane_crashes\ntype     = SLE_UINT8\nfrom     = SLV_138\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_PLANE_CRASHES\nstrhelp  = STR_CONFIG_SETTING_PLANE_CRASHES_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PLANE_CRASHES_NONE\ncat      = SC_BASIC\n\n[SDT_XREF]\nxref     = \"\"vehicle.improved_breakdowns\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"vehicle.improved_breakdowns\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.improved_breakdowns\nguiflags = SGF_NO_NETWORK\ndef      = false\nstr      = STR_CONFIG_SETTING_IMPROVED_BREAKDOWNS\nproc     = ImprovedBreakdownsSettingChanged\npatxname = \"\"improved_breakdowns.vehicle.improved_breakdowns\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.ship_collision_avoidance\ndef      = true\nstr      = STR_CONFIG_SETTING_SHIP_COLLISION_AVOIDANCE\nstrhelp  = STR_CONFIG_SETTING_SHIP_COLLISION_AVOIDANCE_HELPTEXT\npatxname = \"\"ship_collision_avoidance.vehicle.ship_collision_avoidance\"\"\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.no_train_crash_other_company\ndef      = false\nstr      = STR_CONFIG_SETTING_NO_TRAIN_CRASH_OTHER_COMPANY\nstrhelp  = STR_CONFIG_SETTING_NO_TRAIN_CRASH_OTHER_COMPANY_HELPTEXT\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.vehicle.no_train_crash_other_company\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.flip_direction_all_trains\ndef      = false\nstr      = STR_CONFIG_SETTING_FLIP_DIRECTION_ALL_TRAINS\nstrhelp  = STR_CONFIG_SETTING_FLIP_DIRECTION_ALL_TRAINS_HELPTEXT\npatxname = \"\"flip_direction_all_trains.vehicle.flip_direction_all_trains\"\"\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.roadveh_articulated_overtaking\ndef      = true\nstr      = STR_CONFIG_SETTING_ROADVEH_ARTICULATED_OVERTAKING\nstrhelp  = STR_CONFIG_SETTING_ROADVEH_ARTICULATED_OVERTAKING_HELPTEXT\npatxname = \"\"roadveh_articulated_overtaking.vehicle.roadveh_articulated_overtaking\"\"\ncat      = SC_BASIC\n\n; station.join_stations\n[SDT_NULL]\nlength   = 1\nto       = SLV_159\n\n[SDTC_BOOL]\nvar      = gui.sg_full_load_any\nfrom     = SLV_22\nto       = SLV_93\ndef      = true\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = order.improved_load\nguiflags = SGF_NO_NETWORK\ndef      = true\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = order.selectgoods\ndef      = true\ncat      = SC_EXPERT\n\n;; economy.deliver_goods\n;; vehicle.cargo_wait_time\n[SDT_NULL]\nlength   = 2\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; order.automatic_timetable_separation\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n;; order.timetable_auto_travel_buffer\n;; order.timetable_auto_load_buffer\n;; order.timetable_auto_travel_rounding\n;; order.timetable_auto_load_rounding\n[SDT_NULL]\nlength   = 4\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP, SL_JOKER_1_24)\n\n[SDTC_BOOL]\nvar      = gui.sg_new_nonstop\nfrom     = SLV_22\nto       = SLV_93\ndef      = false\n\n; station.nonuniform_stations\n[SDT_NULL]\nlength   = 1\nto       = SLV_159\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = station.station_spread\ntype     = SLE_UINT8\ndef      = 12\nmin      = 4\nmax      = 128\nstr      = STR_CONFIG_SETTING_STATION_SPREAD\nstrhelp  = STR_CONFIG_SETTING_STATION_SPREAD_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TILE_LENGTH\nproc     = StationSpreadChanged\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = order.serviceathelipad\ndef      = true\nstr      = STR_CONFIG_SETTING_SERVICEATHELIPAD\nstrhelp  = STR_CONFIG_SETTING_SERVICEATHELIPAD_HELPTEXT\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = order.nonstop_only\ndef      = false\nstr      = STR_CONFIG_SETTING_NONSTOP_ORDER_ONLY\nstrhelp  = STR_CONFIG_SETTING_NONSTOP_ORDER_ONLY_HELPTEXT\ncat      = SC_EXPERT\npatxname = \"\"nonstop_only.order.nonstop_only\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = station.modified_catchment\ndef      = true\nstr      = STR_CONFIG_SETTING_CATCHMENT\nstrhelp  = STR_CONFIG_SETTING_CATCHMENT_HELPTEXT\nproc     = StationCatchmentChanged\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = station.catchment_increase\ntype     = SLE_UINT8\ndef      = 0\nmin      = 0\nmax      = 5\nstr      = STR_CONFIG_SETTING_CATCHMENT_INCREASE\nstrhelp  = STR_CONFIG_SETTING_CATCHMENT_INCREASE_HELPTEXT\nstrval   = STR_JUST_COMMA\nproc     = StationCatchmentChanged\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_STATION_CATCHMENT_INC)\npatxname = \"\"station_catchment_inc.station.catchment_increase\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = station.cargo_class_rating_wait_time\ndef      = false\nstr      = STR_CONFIG_SETTING_STATION_RATING_CARGO_CLASS_WAIT_TIME\nstrhelp  = STR_CONFIG_SETTING_STATION_RATING_CARGO_CLASS_WAIT_TIME_HELPTEXT\npatxname = \"\"station_rating.station.cargo_class_rating_wait_time\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = station.station_size_rating_cargo_amount\ndef      = false\nstr      = STR_CONFIG_SETTING_STATION_RATING_SIZE_CARGO_AMOUNT\nstrhelp  = STR_CONFIG_SETTING_STATION_RATING_SIZE_CARGO_AMOUNT_HELPTEXT\npatxname = \"\"station_rating.station.station_size_rating_cargo_amount\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = station.serve_neutral_industries\ndef      = true\nfrom     = SLV_SERVE_NEUTRAL_INDUSTRIES\nstr      = STR_CONFIG_SETTING_SERVE_NEUTRAL_INDUSTRIES\nstrhelp  = STR_CONFIG_SETTING_SERVE_NEUTRAL_INDUSTRIES_HELPTEXT\nproc     = StationCatchmentChanged\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = order.gradual_loading\nfrom     = SLV_40\nguiflags = SGF_NO_NETWORK\ndef      = true\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.road_stop_on_town_road\nfrom     = SLV_47\ndef      = true\nstr      = STR_CONFIG_SETTING_STOP_ON_TOWN_ROAD\nstrhelp  = STR_CONFIG_SETTING_STOP_ON_TOWN_ROAD_HELPTEXT\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.road_stop_on_competitor_road\nfrom     = SLV_114\ndef      = true\nstr      = STR_CONFIG_SETTING_STOP_ON_COMPETITOR_ROAD\nstrhelp  = STR_CONFIG_SETTING_STOP_ON_COMPETITOR_ROAD_HELPTEXT\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.road_custom_bridge_heads\ndef      = true\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_ENABLE_ROAD_CUSTOM_BRIDGE_HEADS\nstrhelp  = STR_CONFIG_SETTING_ENABLE_ROAD_CUSTOM_BRIDGE_HEADS_HELPTEXT\npatxname = \"\"custom_bridge_heads.construction.road_custom_bridge_heads\"\"\n\n[SDT_XREF]\nxref     = \"\"construction.road_custom_bridge_heads\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.rail_custom_bridge_heads\ndef      = true\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_ENABLE_RAIL_CUSTOM_BRIDGE_HEADS\nstrhelp  = STR_CONFIG_SETTING_ENABLE_RAIL_CUSTOM_BRIDGE_HEADS_HELPTEXT\npatxname = \"\"custom_bridge_heads.construction.rail_custom_bridge_heads\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.allow_grf_objects_under_bridges\ndef      = false\ncat      = SC_ADVANCED\nstr      = STR_CONFIG_SETTING_ALLOW_GRF_OBJECTS_UNDER_BRIDGES\nstrhelp  = STR_CONFIG_SETTING_ALLOW_GRF_OBJECTS_UNDER_BRIDGES_HELPTEXT\npatxname = \"\"allow_grf_objects_under_bridges.construction.allow_grf_objects_under_bridges\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.allow_stations_under_bridges\ndef      = false\ncat      = SC_ADVANCED\nstr      = STR_CONFIG_SETTING_ALLOW_GRF_STATIONS_UNDER_BRIDGES\nstrhelp  = STR_CONFIG_SETTING_ALLOW_GRF_STATIONS_UNDER_BRIDGES_HELPTEXT\npatxname = \"\"allow_stations_under_bridges.construction.allow_stations_under_bridges\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.allow_road_stops_under_bridges\ndef      = true\ncat      = SC_ADVANCED\nstr      = STR_CONFIG_SETTING_ALLOW_ROAD_STATIONS_UNDER_BRIDGES\nstrhelp  = STR_CONFIG_SETTING_ALLOW_ROAD_STATIONS_UNDER_BRIDGES_HELPTEXT\npatxname = \"\"allow_stations_under_bridges.construction.allow_road_stops_under_bridges\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.allow_docks_under_bridges\ndef      = false\ncat      = SC_ADVANCED\nstr      = STR_CONFIG_SETTING_ALLOW_DOCKS_UNDER_BRIDGES\nstrhelp  = STR_CONFIG_SETTING_ALLOW_DOCKS_UNDER_BRIDGES_HELPTEXT\npatxname = \"\"allow_stations_under_bridges.construction.allow_docks_under_bridges\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.purchase_land_permitted\ntype     = SLE_UINT8\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_PURCHASE_LAND_PERMITTED\nstrhelp  = STR_CONFIG_SETTING_PURCHASE_LAND_PERMITTED_HELPTEXT\nstrval   = STR_PURCHASE_LAND_PERMITTED_NO\npatxname = \"\"purchase_land_permitted.construction.purchase_land_permitted\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = station.adjacent_stations\nfrom     = SLV_62\ndef      = true\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.station_noise_level\nfrom     = SLV_96\nguiflags = SGF_NO_NETWORK\ndef      = false\nstr      = STR_CONFIG_SETTING_NOISE_LEVEL\nstrhelp  = STR_CONFIG_SETTING_NOISE_LEVEL_HELPTEXT\nproc     = InvalidateTownViewWindow\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = station.distant_join_stations\nfrom     = SLV_106\ndef      = true\nstr      = STR_CONFIG_SETTING_DISTANT_JOIN_STATIONS\nstrhelp  = STR_CONFIG_SETTING_DISTANT_JOIN_STATIONS_HELPTEXT\nproc     = DeleteSelectStationWindow\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.traffic_lights\nfrom     = SL_MIN_VERSION\ndef      = true\nstr      = STR_CONFIG_SETTING_TRAFFIC_LIGHTS\nstrhelp  = STR_CONFIG_SETTING_TRAFFIC_LIGHTS_HELPTEXT\nproc     = TLSettingChanged\ncat      = SC_EXPERT\npatxname = \"\"construction.traffic_lights\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.towns_build_traffic_lights\nfrom     = SL_MIN_VERSION\ndef      = true\nstr      = STR_CONFIG_SETTING_TOWNS_BUILD_TRAFFIC_LIGHTS\nstrhelp  = STR_CONFIG_SETTING_TOWNS_BUILD_TRAFFIC_LIGHTS_HELPTEXT\ncat      = SC_EXPERT\npatxname = \"\"construction.towns_build_traffic_lights\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.allow_building_tls_in_towns\nfrom     = SL_MIN_VERSION\ndef      = false\nstr      = STR_CONFIG_SETTING_ALLOW_BUILDING_TLS_ON_TOWN_ROADS\nstrhelp  = STR_CONFIG_SETTING_ALLOW_BUILDING_TLS_ON_TOWN_ROADS_HELPTEXT\ncat      = SC_EXPERT\npatxname = \"\"construction.allow_building_tls_in_towns\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.traffic_lights_green_phase\ntype     = SLE_UINT8\nfrom     = SL_MIN_VERSION\ndef      = 2\nmin      = 1\nmax      = 16\nstr      = STR_CONFIG_SETTING_TRAFFIC_LIGHTS_GREEN_PHASE\nstrhelp  = STR_CONFIG_SETTING_TRAFFIC_LIGHTS_GREEN_PHASE_HELPTEXT\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\npatxname = \"\"construction.traffic_lights_green_phase\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.max_tlc_size\ntype     = SLE_UINT8\nfrom     = SL_MIN_VERSION\nguiflags = SGF_0ISDISABLED\ndef      = 4\nmin      = 1\nmax      = 32\nstr      = STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_SIZE\nstrhelp  = STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_SIZE_HELPTEXT\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\npatxname = \"\"construction.max_tlc_size\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.max_tlc_distance\ntype     = SLE_UINT8\nfrom     = SL_MIN_VERSION\ndef      = 1\nmin      = 0\nmax      = 4\nstr      = STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_DISTANCE\nstrhelp  = STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_DISTANCE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TILE_LENGTH\ncat      = SC_EXPERT\npatxname = \"\"construction.max_tlc_distance\"\"\n\n## Road signs\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.road_signs\nfrom     = SL_MIN_VERSION\ndef      = true\nstr      = STR_CONFIG_SETTING_ROAD_SIGNS\nstrhelp  = STR_CONFIG_SETTING_ROAD_SIGNS_HELPTEXT\nproc     = RSSettingChanged\ncat      = SC_EXPERT\npatxname = \"\"construction.road_signs\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.towns_build_road_signs\nfrom     = SL_MIN_VERSION\ndef      = true\nstr      = STR_CONFIG_SETTING_TOWNS_BUILD_ROAD_SIGNS\nstrhelp  = STR_CONFIG_SETTING_TOWNS_BUILD_ROAD_SIGNS_HELPTEXT\ncat      = SC_EXPERT\npatxname = \"\"construction.towns_build_road_signs\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.allow_building_rs_in_towns\nfrom     = SL_MIN_VERSION\ndef      = true\nstr      = STR_CONFIG_SETTING_ALLOW_BUILDING_RS_ON_TOWN_ROADS\nstrhelp  = STR_CONFIG_SETTING_ALLOW_BUILDING_RS_ON_TOWN_ROADS_HELPTEXT\ncat      = SC_EXPERT\npatxname = \"\"construction.allow_building_rs_in_towns\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.allow_eye_candy_road_signs\nfrom     = SL_MIN_VERSION\ndef      = true\nstr      = STR_CONFIG_SETTING_AUTO_BUILD_EYE_CANDY_ROAD_SIGNS\nstrhelp  = STR_CONFIG_SETTING_AUTO_BUILD_EYE_CANDY_ROAD_SIGNS_HELPTEXT\ncat      = SC_EXPERT\npatxname = \"\"construction.allow_eye_candy_road_signs\"\"\n\n## Speed limits\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.limit_vehicle_speed_in_towns\nfrom     = SL_MIN_VERSION\ndef      = false\nstr      = STR_CONFIG_SETTING_LIMITVEHSPEED_IN\ncat      = SC_EXPERT\npatxname = \"\"vehicle.limit_vehicle_speed_in_towns\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_veh_speed_in_towns_two_way\ntype     = SLE_UINT16\nfrom     = SL_MIN_VERSION\ndef      = 50\nmin      = 0\nmax      = 250\nstr      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_IN_TNEW\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\npatxname = \"\"vehicle.max_veh_speed_in_towns_two_way\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_veh_speed_in_towns_one_way\ntype     = SLE_UINT16\nfrom     = SL_MIN_VERSION\ndef      = 70\nmin      = 0\nmax      = 250\nstr      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_IN_OWOW\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\npatxname = \"\"vehicle.max_veh_speed_in_towns_one_way\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.limit_vehicle_speed_outside_towns\nfrom     = SL_MIN_VERSION\ndef      = false\nstr      = STR_CONFIG_SETTING_LIMITVEHSPEED_OUT\ncat      = SC_EXPERT\npatxname = \"\"vehicle.limit_vehicle_speed_outside_towns\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_veh_speed_out_towns_two_way\ntype     = SLE_UINT16\nfrom     = SL_MIN_VERSION\ndef      = 90\nmin      = 0\nmax      = 250\nstr      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_OUT_TNEW\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\npatxname = \"\"vehicle.max_veh_speed_out_towns_two_way\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_veh_speed_out_towns_one_way\ntype     = SLE_UINT16\nfrom     = SL_MIN_VERSION\ndef      = 130\nmin      = 0\nmax      = 250\nstr      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_OUT_OWOW\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\npatxname = \"\"vehicle.max_veh_speed_out_towns_one_way\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.limit_vehicle_speed_tunnel_bridge\nfrom     = SL_MIN_VERSION\ndef      = false\nstr      = STR_CONFIG_SETTING_LIMITVEHSPEED_WORMHOLE\ncat      = SC_EXPERT\npatxname = \"\"vehicle.limit_vehicle_speed_tunnel_bridge\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.limit_vehicle_speed_tunnel_bridge_enhanced\nfrom     = SL_MIN_VERSION\ndef      = false\nstr      = STR_CONFIG_SETTING_LIMITVEHSPEED_WORMHOLE_ENHANCED\ncat      = SC_EXPERT\npatxname = \"\"vehicle.limit_vehicle_speed_tunnel_bridge_enhanced\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_veh_speed_tunnel_bridge\ntype     = SLE_UINT16\nfrom     = SL_MIN_VERSION\ndef      = 90\nmin      = 0\nmax      = 250\nstr      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_WORMHOLE\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\npatxname = \"\"vehicle.max_veh_speed_tunnel_bridge\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.limit_vehicle_speed_highway\nfrom     = SL_MIN_VERSION\ndef      = false\nstr      = STR_CONFIG_SETTING_LIMITVEHSPEED_HIGHWAY\ncat      = SC_EXPERT\npatxname = \"\"vehicle.limit_vehicle_speed_highway\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.max_veh_speed_highway\ntype     = SLE_UINT16\nfrom     = SL_MIN_VERSION\ndef      = 150\nmin      = 0\nmax      = 1000\nstr      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_HIGHWAY\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\npatxname = \"\"vehicle.max_veh_speed_highway\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.one_way_roads_out_town_as_highway\nfrom     = SL_MIN_VERSION\ndef      = false\nstr      = STR_CONFIG_SETTING_ONE_WAY_ROADS_OUT_OF_TOWN_AS_HIGHWAY\ncat      = SC_EXPERT\npatxname = \"\"vehicle.one_way_roads_out_town_as_highway\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.try_to_use_two_lanes_on_highway\nfrom     = SL_MIN_VERSION\ndef      = false\nstr      = STR_CONFIG_SETTING_BOTH_LANES_ON_HIGHWAY\ncat      = SC_EXPERT\npatxname = \"\"vehicle.try_to_use_two_lanes_on_highway\"\"\n\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.chance_of_going_to_second_lane\ntype     = SLE_UINT8\ndef      = 2\nmin      = 1\nmax      = 4\nstr      = STR_CONFIG_SETTING_CHANCE_OF_GOING_TO_SECOND_LANE\nstrval   = STR_CONFIG_SETTING_CHANCE_OF_GOING_TO_SECOND_LANE_VALUE\npatxname = \"\"vehicle.chance_of_going_to_second_lane\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.min_speed_for_second_lane\ntype     = SLE_UINT16\nfrom     = SL_MIN_VERSION\ndef      = 120\nmin      = 0\nmax      = 500\nstr      = STR_CONFIG_SETTING_MIN_SPEED_FOR_SECOND_LANE\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\npatxname = \"\"vehicle.min_speed_for_second_lane\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.only_buses_on_second_lane_on_highway\nfrom     = SL_MIN_VERSION\ndef      = false\nstr      = STR_CONFIG_SETTING_ONLY_BUSES_ON_SECOND_LANE\ncat      = SC_EXPERT\npatxname = \"\"vehicle.only_buses_on_second_lane_on_highway\"\"\n\n##\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.inflation\ndef      = true\nstr      = STR_CONFIG_SETTING_INFLATION\nstrhelp  = STR_CONFIG_SETTING_INFLATION_HELPTEXT\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.day_length_factor\ntype     = SLE_UINT8\ndef      = 1\nmin      = 1\nmax      = 125\nstr      = STR_CONFIG_SETTING_DAY_LENGTH_FACTOR\nstrhelp  = STR_CONFIG_SETTING_DAY_LENGTH_FACTOR_HELPTEXT\nstrval   = STR_JUST_COMMA\nproc     = DayLengthChanged\ncat      = SC_BASIC\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_VARIABLE_DAY_LENGTH)\npatxname = \"\"variable_day_length.economy.day_length_factor\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.raw_industry_construction\ntype     = SLE_UINT8\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_RAW_INDUSTRY_CONSTRUCTION_METHOD\nstrhelp  = STR_CONFIG_SETTING_RAW_INDUSTRY_CONSTRUCTION_METHOD_HELPTEXT\nstrval   = STR_CONFIG_SETTING_RAW_INDUSTRY_CONSTRUCTION_METHOD_NONE\nproc     = InvalidateBuildIndustryWindow\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.industry_platform\ntype     = SLE_UINT8\nfrom     = SLV_148\ndef      = 1\nmin      = 0\nmax      = 4\nstr      = STR_CONFIG_SETTING_INDUSTRY_PLATFORM\nstrhelp  = STR_CONFIG_SETTING_INDUSTRY_PLATFORM_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TILE_LENGTH\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.multiple_industry_per_town\ndef      = false\nstr      = STR_CONFIG_SETTING_MULTIPINDTOWN\nstrhelp  = STR_CONFIG_SETTING_MULTIPINDTOWN_HELPTEXT\n\n;; economy.allow_automatic_industries\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP, 4)\n\n;; construction.extra_industry_placement_logic\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_NULL]\nlength   = 1\nto       = SLV_141\n\n;; economy.minimum_distance_town\n;; economy.minimum_distance_industry\n;; economy.minimum_distance_ind_town\n[SDT_NULL]\nlength   = 6\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.bribe\ndef      = true\nstr      = STR_CONFIG_SETTING_BRIBE\nstrhelp  = STR_CONFIG_SETTING_BRIBE_HELPTEXT\nproc     = RedrawTownAuthority\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.exclusive_rights\nfrom     = SLV_79\ndef      = true\nstr      = STR_CONFIG_SETTING_ALLOW_EXCLUSIVE\nstrhelp  = STR_CONFIG_SETTING_ALLOW_EXCLUSIVE_HELPTEXT\nproc     = RedrawTownAuthority\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.fund_buildings\nfrom     = SLV_165\ndef      = true\nstr      = STR_CONFIG_SETTING_ALLOW_FUND_BUILDINGS\nstrhelp  = STR_CONFIG_SETTING_ALLOW_FUND_BUILDINGS_HELPTEXT\nproc     = RedrawTownAuthority\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.fund_roads\nfrom     = SLV_160\ndef      = true\nstr      = STR_CONFIG_SETTING_ALLOW_FUND_ROAD\nstrhelp  = STR_CONFIG_SETTING_ALLOW_FUND_ROAD_HELPTEXT\nproc     = RedrawTownAuthority\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.give_money\nfrom     = SLV_79\ndef      = true\nstr      = STR_CONFIG_SETTING_ALLOW_GIVE_MONEY\nstrhelp  = STR_CONFIG_SETTING_ALLOW_GIVE_MONEY_HELPTEXT\ncat      = SC_BASIC\n\n;; game_creation.tree_line_height\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n; Snow line upper byte\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.snow_line_height\ntype     = SLE_UINT8\nguiflags = SGF_NO_NETWORK\ndef      = DEF_SNOWLINE_HEIGHT\nmin      = MIN_SNOWLINE_HEIGHT\nmax      = MAX_SNOWLINE_HEIGHT\ninterval = 1\nstr      = STR_CONFIG_SETTING_SNOWLINE_HEIGHT\nstrhelp  = STR_CONFIG_SETTING_SNOWLINE_HEIGHT_HELPTEXT\nstrval   = STR_JUST_COMMA\ncat      = SC_BASIC\n\n;;game_creation.desert_amount\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n;;game_creation.tree_line\n[SDT_NULL]\nlength   = 2\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n;;game_creation.desert_amount\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n[SDT_NULL]\nlength   = 4\nto       = SLV_144\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, 0, 0)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.starting_year\ntype     = SLE_INT32\ndef      = DEF_START_YEAR\nmin      = MIN_YEAR\nmax      = MAX_YEAR\ninterval = 1\nstr      = STR_CONFIG_SETTING_STARTING_YEAR\nstrval   = STR_JUST_INT\ncat      = SC_BASIC\n\n[SDTG_VAR]\nname     = \"\"old_ending_year_slv_105\"\"\nvar      = _old_ending_year_slv_105\nflags    = SLF_NOT_IN_CONFIG\ntype     = SLE_INT32\nto       = SLV_105\ndef      = DEF_END_YEAR\nmin      = MIN_YEAR\nmax      = MAX_YEAR\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.ending_year\ntype     = SLE_INT32\nfrom     = SLV_ENDING_YEAR\nguiflags = SGF_0ISDISABLED\ndef      = DEF_END_YEAR\nmin      = MIN_YEAR\nmax      = MAX_YEAR\ninterval = 1\nstr      = STR_CONFIG_SETTING_ENDING_YEAR\nstrhelp  = STR_CONFIG_SETTING_ENDING_YEAR_HELPTEXT\nstrval   = STR_CONFIG_SETTING_ENDING_YEAR_VALUE\ncat      = SC_ADVANCED\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.smooth_economy\ndef      = true\nstr      = STR_CONFIG_SETTING_SMOOTH_ECONOMY\nstrhelp  = STR_CONFIG_SETTING_SMOOTH_ECONOMY_HELPTEXT\nproc     = InvalidateIndustryViewWindow\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.allow_shares\ndef      = false\nstr      = STR_CONFIG_SETTING_ALLOW_SHARES\nstrhelp  = STR_CONFIG_SETTING_ALLOW_SHARES_HELPTEXT\nproc     = InvalidateCompanyWindow\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.min_years_for_shares\ntype     = SLE_UINT8\nfrom     = SLV_TRADING_AGE\ndef      = 6\nmin      = 0\nmax      = 255\ninterval = 1\nstr      = STR_CONFIG_SETTING_MIN_YEARS_FOR_SHARES\nstrhelp  = STR_CONFIG_SETTING_MIN_YEARS_FOR_SHARES_HELPTEXT\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.feeder_payment_share\ntype     = SLE_UINT8\nfrom     = SLV_134\ndef      = 75\nmin      = 0\nmax      = 100\nstr      = STR_CONFIG_SETTING_FEEDER_PAYMENT_SHARE\nstrhelp  = STR_CONFIG_SETTING_FEEDER_PAYMENT_SHARE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\ncat      = SC_EXPERT\n\n[SDT_XREF]\nxref     = \"\"economy.day_length_factor\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.price_mult[0-70]\n[SDT_NULL]\nlength   = 71\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.price_rails[0-15]\n[SDT_NULL]\nlength   = 16\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.rail_maintenance[0-15]\n[SDT_NULL]\nlength   = 16\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n; note that this has changed format in SpringPP 2.1.147\n[SDT_XREF]\nxref     = \"\"vehicle.pay_for_repair\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"vehicle.repair_cost\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.town_consumption_rate\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.town_pop_*\n[SDT_NULL]\nlength   = 6\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.town_consumption_rates[0-2][0-2]\n[SDT_NULL]\nlength   = 18\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.town_effects[0-2]\n[SDT_NULL]\nlength   = 3\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n;; economy.grow_if_one_delivered\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.town_growth_rate\ntype     = SLE_INT8\nfrom     = SLV_54\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = -2\nmax      = 4\nstr      = STR_CONFIG_SETTING_TOWN_GROWTH\nstrhelp  = STR_CONFIG_SETTING_TOWN_GROWTH_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TOWN_GROWTH_EXTREME_SLOW\norderproc = OrderTownGrowthRate\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.town_growth_cargo_transported\ntype     = SLE_UINT8\ndef      = 0\nmin      = 0\nmax      = 100\ninterval = 10\nstr      = STR_CONFIG_SETTING_TOWN_GROWTH_CARGO_TRANSPORTED\nstrhelp  = STR_CONFIG_SETTING_TOWN_GROWTH_CARGO_TRANSPORTED_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\ncat      = SC_EXPERT\npatxname = \"\"town_growth.economy.town_growth_cargo_transported\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.larger_towns\ntype     = SLE_UINT8\nfrom     = SLV_54\nguiflags = SGF_0ISDISABLED\ndef      = 4\nmin      = 0\nmax      = 255\ninterval = 1\nstr      = STR_CONFIG_SETTING_LARGER_TOWNS\nstrhelp  = STR_CONFIG_SETTING_LARGER_TOWNS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LARGER_TOWNS_VALUE\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.initial_city_size\ntype     = SLE_UINT8\nfrom     = SLV_56\ndef      = 2\nmin      = 1\nmax      = 10\ninterval = 1\nstr      = STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER\nstrhelp  = STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER_HELPTEXT\nstrval   = STR_JUST_COMMA\n\n;; economy.town_growth_cargo, economy.town_pop_need_goods, economy.larger_town_growth_cargo, economy.larger_town_pop_need_goods\n[SDT_NULL]\nlength   = 10\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.mod_road_rebuild\nfrom     = SLV_77\ndef      = true\ncat      = SC_EXPERT\n\n[SDT_XREF]\nxref     = \"\"construction.maximum_signal_evaluations\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.town_min_distance\ntype     = SLE_UINT16\ndef      = 20\nmin      = 15\nmax      = 500\ninterval = 5\nstr      = STR_CONFIG_SETTING_TOWN_MIN_DISTANCE\nstrhelp  = STR_CONFIG_SETTING_TOWN_MIN_DISTANCE_HELPTEXT\nstrval   = STR_JUST_INT\npatxname = \"\"town_min_distance.economy.town_min_distance\"\"\n\n[SDT_XREF]\nxref     = \"\"economy.town_min_distance\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n[SDT_XREF]\nxref     = \"\"economy.infrastructure_sharing[0]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.infrastructure_sharing[1]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.infrastructure_sharing[2]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.infrastructure_sharing[3]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_fee[0]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_fee[1]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_fee[2]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_fee[3]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_payment_in_debt\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP)\n\n[SDT_XREF]\nxref     = \"\"economy.infrastructure_sharing[0]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_XREF]\nxref     = \"\"economy.infrastructure_sharing[1]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_XREF]\nxref     = \"\"economy.infrastructure_sharing[2]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_XREF]\nxref     = \"\"economy.infrastructure_sharing[3]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_fee[0]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_fee[1]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_fee[2]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_fee[3]\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_XREF]\nxref     = \"\"economy.sharing_payment_in_debt\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.maximum_signal_evaluations\ntype     = SLE_UINT16\ndef      = 256\nmin      = 64\nmax      = 4096\ninterval = 1\nstr      = STR_CONFIG_SETTING_MAX_SIGNAL_EVALUATIONS\nstrhelp  = STR_CONFIG_SETTING_MAX_SIGNAL_EVALUATIONS_HELPTEXT\nstrval   = STR_JUST_COMMA\ncat      = SC_EXPERT\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_PROG_SIGS)\npatxname = \"\"programmable_signals.construction.maximum_signal_evaluations\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.infrastructure_sharing[0]\ndef      = false\nstr      = STR_CONFIG_SETTING_SHARING_RAIL\nproc     = CheckSharingRail\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.economy.infrastructure_sharing.rail\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.infrastructure_sharing[1]\ndef      = false\nstr      = STR_CONFIG_SETTING_SHARING_ROAD\nproc     = CheckSharingRoad\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.economy.infrastructure_sharing.road\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.infrastructure_sharing[2]\ndef      = false\nstr      = STR_CONFIG_SETTING_SHARING_WATER\nproc     = CheckSharingWater\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.economy.infrastructure_sharing.water\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.infrastructure_sharing[3]\ndef      = false\nstr      = STR_CONFIG_SETTING_SHARING_AIR\nproc     = CheckSharingAir\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.economy.infrastructure_sharing.air\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.sharing_fee[0]\ntype     = SLE_UINT\nguiflags = SGF_CURRENCY\ndef      = 100\nmin      = 0\nmax      = 1000000\ninterval = 10\nstr      = STR_CONFIG_SETTING_SHARING_FEE_RAIL\nstrval   = STR_JUST_CURRENCY_LONG\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.economy.sharing_fee.rail\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.sharing_fee[1]\ntype     = SLE_UINT\nguiflags = SGF_CURRENCY\ndef      = 100\nmin      = 0\nmax      = 1000000\ninterval = 10\nstr      = STR_CONFIG_SETTING_SHARING_FEE_ROAD\nstrval   = STR_JUST_CURRENCY_LONG\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.economy.sharing_fee.road\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.sharing_fee[2]\ntype     = SLE_UINT\nguiflags = SGF_CURRENCY\ndef      = 100\nmin      = 0\nmax      = 1000000\ninterval = 10\nstr      = STR_CONFIG_SETTING_SHARING_FEE_WATER\nstrval   = STR_JUST_CURRENCY_LONG\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.economy.sharing_fee.water\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.sharing_fee[3]\ntype     = SLE_UINT\nguiflags = SGF_CURRENCY\ndef      = 100\nmin      = 0\nmax      = 1000000\ninterval = 10\nstr      = STR_CONFIG_SETTING_SHARING_FEE_AIR\nstrval   = STR_JUST_CURRENCY_LONG\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.economy.sharing_fee.air\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.sharing_payment_in_debt\ndef      = false\nstr      = STR_CONFIG_SETTING_SHARING_PAYMENT_IN_DEBT\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_INFRA_SHARING)\npatxname = \"\"infra_sharing.economy.sharing_payment_in_debt\"\"\n\n[SDT_XREF]\nxref     = \"\"economy.day_length_factor\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n; previously ai-new setting.\n[SDT_NULL]\nlength   = 1\nto       = SLV_106\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = script.settings_profile\ntype     = SLE_UINT8\nfrom     = SLV_178\nguiflags = SGF_MULTISTRING\ndef      = SP_EASY\nmin      = SP_EASY\nmax      = SP_HARD\nfull     = _settings_profiles\nstr      = STR_CONFIG_SETTING_AI_PROFILE\nstrhelp  = STR_CONFIG_SETTING_AI_PROFILE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_AI_PROFILE_EASY\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = ai.ai_in_multiplayer\ndef      = true\nstr      = STR_CONFIG_SETTING_AI_IN_MULTIPLAYER\nstrhelp  = STR_CONFIG_SETTING_AI_IN_MULTIPLAYER_HELPTEXT\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = ai.ai_disable_veh_train\ndef      = false\nstr      = STR_CONFIG_SETTING_AI_BUILDS_TRAINS\nstrhelp  = STR_CONFIG_SETTING_AI_BUILDS_TRAINS_HELPTEXT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = ai.ai_disable_veh_roadveh\ndef      = false\nstr      = STR_CONFIG_SETTING_AI_BUILDS_ROAD_VEHICLES\nstrhelp  = STR_CONFIG_SETTING_AI_BUILDS_ROAD_VEHICLES_HELPTEXT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = ai.ai_disable_veh_aircraft\ndef      = false\nstr      = STR_CONFIG_SETTING_AI_BUILDS_AIRCRAFT\nstrhelp  = STR_CONFIG_SETTING_AI_BUILDS_AIRCRAFT_HELPTEXT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = ai.ai_disable_veh_ship\ndef      = false\nstr      = STR_CONFIG_SETTING_AI_BUILDS_SHIPS\nstrhelp  = STR_CONFIG_SETTING_AI_BUILDS_SHIPS_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = script.script_max_opcode_till_suspend\ntype     = SLE_UINT32\nfrom     = SLV_107\nguiflags = SGF_NEWGAME_ONLY\ndef      = 10000\nmin      = 500\nmax      = 250000\ninterval = 2500\nstr      = STR_CONFIG_SETTING_SCRIPT_MAX_OPCODES\nstrhelp  = STR_CONFIG_SETTING_SCRIPT_MAX_OPCODES_HELPTEXT\nstrval   = STR_JUST_COMMA\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = script.script_max_memory_megabytes\ntype     = SLE_UINT32\nfrom     = SLV_SCRIPT_MEMLIMIT\nguiflags = SGF_NEWGAME_ONLY\ndef      = 1024\nmin      = 8\nmax      = 8192\ninterval = 8\nstr      = STR_CONFIG_SETTING_SCRIPT_MAX_MEMORY\nstrhelp  = STR_CONFIG_SETTING_SCRIPT_MAX_MEMORY_HELPTEXT\nstrval   = STR_CONFIG_SETTING_SCRIPT_MAX_MEMORY_VALUE\ncat      = SC_EXPERT\n\n##\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.extend_vehicle_life\ntype     = SLE_UINT8\ndef      = 0\nmin      = 0\nmax      = 100\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.dist_local_authority\ntype     = SLE_UINT8\ndef      = 20\nmin      = 5\nmax      = 60\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.reverse_at_signals\nfrom     = SLV_159\ndef      = false\nstr      = STR_CONFIG_SETTING_REVERSE_AT_SIGNALS\nstrhelp  = STR_CONFIG_SETTING_REVERSE_AT_SIGNALS_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.wait_oneway_signal\ntype     = SLE_UINT8\ndef      = 15\nmin      = 2\nmax      = 255\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.wait_twoway_signal\ntype     = SLE_UINT8\ndef      = 41\nmin      = 2\nmax      = 255\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.town_noise_population[0]\ntype     = SLE_UINT16\nfrom     = SLV_96\ndef      = 800\nmin      = 200\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.town_noise_population[1]\ntype     = SLE_UINT16\nfrom     = SLV_96\ndef      = 2000\nmin      = 400\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.town_noise_population[2]\ntype     = SLE_UINT16\nfrom     = SLV_96\ndef      = 4000\nmin      = 800\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = economy.infrastructure_maintenance\nfrom     = SLV_166\ndef      = false\nstr      = STR_CONFIG_SETTING_INFRASTRUCTURE_MAINTENANCE\nstrhelp  = STR_CONFIG_SETTING_INFRASTRUCTURE_MAINTENANCE_HELPTEXT\nproc     = InvalidateCompanyInfrastructureWindow\ncat      = SC_BASIC\n\n[SDT_XREF]\nxref     = \"\"economy.infrastructure_maintenance\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n;; construction.traffic_lights...\n[SDT_NULL]\nlength   = 6\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_XREF]\nxref     = \"\"linkgraph.recalc_interval\"\"\nxrefcvt  = LinkGraphDistModeXrefChillPP\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_XREF]\nxref     = \"\"linkgraph.distribution_pax\"\"\nxrefcvt  = LinkGraphDistModeXrefChillPP\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_XREF]\nxref     = \"\"linkgraph.distribution_mail\"\"\nxrefcvt  = LinkGraphDistModeXrefChillPP\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n;; linkgraph.distribution_express\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_XREF]\nxref     = \"\"linkgraph.distribution_armoured\"\"\nxrefcvt  = LinkGraphDistModeXrefChillPP\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_XREF]\nxref     = \"\"linkgraph.distribution_default\"\"\nxrefcvt  = LinkGraphDistModeXrefChillPP\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_XREF]\nxref     = \"\"linkgraph.accuracy\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_XREF]\nxref     = \"\"linkgraph.demand_size\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_XREF]\nxref     = \"\"linkgraph.demand_distance\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n[SDT_XREF]\nxref     = \"\"linkgraph.short_path_saturation\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP)\n\n;; linkgraph.no_overload_links\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = economy.random_road_reconstruction\ntype     = SLE_UINT16\ndef      = 0\nmin      = 0\nmax      = 1000\nstr      = STR_CONFIG_SETTING_RANDOM_ROAD_RECONSTRUCTION\nstrhelp  = STR_CONFIG_SETTING_RANDOM_ROAD_RECONSTRUCTION_HELPTEXT\nstrval   = STR_JUST_COMMA\ncat      = SC_BASIC\npatxname = \"\"economy.random_road_reconstruction\"\"\n\n##\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.wait_for_pbs_path\ntype     = SLE_UINT8\nfrom     = SLV_100\ndef      = 30\nmin      = 2\nmax      = 255\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.reserve_paths\nfrom     = SLV_100\ndef      = false\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.path_backoff_interval\ntype     = SLE_UINT8\nfrom     = SLV_100\ndef      = 20\nmin      = 1\nmax      = 255\ncat      = SC_EXPERT\n\n##\n; Used to be pf.opf.pf_maxlength & pf.opf.pf_maxdepth\n[SDT_NULL]\nlength   = 3\nto       = SLV_REMOVE_OPF\n\n##\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_max_search_nodes\ntype     = SLE_UINT\ndef      = 10000\nmin      = 500\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_rail_firstred_penalty\ntype     = SLE_UINT\ndef      = 10 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_rail_firstred_exit_penalty\ntype     = SLE_UINT\ndef      = 100 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_rail_lastred_penalty\ntype     = SLE_UINT\ndef      = 10 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_rail_station_penalty\ntype     = SLE_UINT\ndef      = 1 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_rail_slope_penalty\ntype     = SLE_UINT\ndef      = 1 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_rail_curve_penalty\ntype     = SLE_UINT\ndef      = 1 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_rail_depot_reverse_penalty\ntype     = SLE_UINT\ndef      = 50 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_rail_pbs_cross_penalty\ntype     = SLE_UINT\nfrom     = SLV_100\ndef      = 3 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_rail_pbs_signal_back_penalty\ntype     = SLE_UINT\nfrom     = SLV_100\ndef      = 15 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_buoy_penalty\ntype     = SLE_UINT\ndef      = 2 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_water_curve_penalty\ntype     = SLE_UINT\ndef      = 1 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_road_curve_penalty\ntype     = SLE_UINT\ndef      = 1 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_crossing_penalty\ntype     = SLE_UINT\ndef      = 3 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_road_drive_through_penalty\ntype     = SLE_UINT\nfrom     = SLV_47\ndef      = 8 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_road_trafficlight_penalty\ntype     = SLE_UINT\nfrom     = SL_MIN_VERSION\ndef      = 2 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\nstr      = STR_NULL\npatxname = \"\"pf.npf.npf_road_trafficlight_penalty\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_road_two_way_penalty\ntype     = SLE_UINT\nfrom     = SL_MIN_VERSION\ndef      = 2 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\nstr      = STR_NULL\npatxname = \"\"pf.npf.npf_road_two_way_penalty\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_road_one_way_penalty\ntype     = SLE_UINT\nfrom     = SL_MIN_VERSION\ndef      = (NPF_TILE_LENGTH / 2)\nmin      = 0\nmax      = 100000\nstr      = STR_NULL\npatxname = \"\"pf.npf.npf_road_one_way_penalty\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_road_town_penalty\ntype     = SLE_UINT\nfrom     = SL_MIN_VERSION\ndef      = 2* NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\nstr      = STR_NULL\npatxname = \"\"pf.npf.npf_road_town_penalty\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_road_dt_occupied_penalty\ntype     = SLE_UINT\nfrom     = SLV_130\ndef      = 8 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.npf_road_bay_occupied_penalty\ntype     = SLE_UINT\nfrom     = SLV_130\ndef      = 15 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 100000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.npf.maximum_go_to_depot_penalty\ntype     = SLE_UINT\nfrom     = SLV_131\ndef      = 20 * NPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n##\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.yapf.disable_node_optimization\nfrom     = SLV_28\ndef      = false\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.max_search_nodes\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 10000\nmin      = 500\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = pf.yapf.rail_firstred_twoway_eol\nfrom     = SLV_28\ndef      = false\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_firstred_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 10 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_firstred_exit_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 100 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_lastred_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 10 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_lastred_exit_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 100 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_station_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 10 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_slope_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 2 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_curve45_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 1 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_curve90_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 6 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_depot_reverse_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 50 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_crossing_penalty\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 3 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_look_ahead_max_signals\ntype     = SLE_UINT\nfrom     = SLV_28\ndef      = 10\nmin      = 1\nmax      = 100\ncat      = SC_EXPERT\nproc     = CheckYapfRailSignalPenalties\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_look_ahead_signal_p0\ntype     = SLE_INT\nfrom     = SLV_28\ndef      = 500\nmin      = -1000000\nmax      = 1000000\ncat      = SC_EXPERT\nproc     = CheckYapfRailSignalPenalties\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_look_ahead_signal_p1\ntype     = SLE_INT\nfrom     = SLV_28\ndef      = -100\nmin      = -1000000\nmax      = 1000000\ncat      = SC_EXPERT\nproc     = CheckYapfRailSignalPenalties\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_look_ahead_signal_p2\ntype     = SLE_INT\nfrom     = SLV_28\ndef      = 5\nmin      = -1000000\nmax      = 1000000\ncat      = SC_EXPERT\nproc     = CheckYapfRailSignalPenalties\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_pbs_cross_penalty\ntype     = SLE_UINT\nfrom     = SLV_100\ndef      = 3 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_pbs_station_penalty\ntype     = SLE_UINT\nfrom     = SLV_100\ndef      = 8 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_pbs_signal_back_penalty\ntype     = SLE_UINT\nfrom     = SLV_100\ndef      = 15 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_doubleslip_penalty\ntype     = SLE_UINT\nfrom     = SLV_100\ndef      = 1 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_longer_platform_penalty\ntype     = SLE_UINT\nfrom     = SLV_33\ndef      = 8 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 20000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_longer_platform_per_tile_penalty\ntype     = SLE_UINT\nfrom     = SLV_33\ndef      = 0 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 20000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_shorter_platform_penalty\ntype     = SLE_UINT\nfrom     = SLV_33\ndef      = 40 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 20000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.rail_shorter_platform_per_tile_penalty\ntype     = SLE_UINT\nfrom     = SLV_33\ndef      = 0 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 20000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_slope_penalty\ntype     = SLE_UINT\nfrom     = SLV_33\ndef      = 2 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_curve_penalty\ntype     = SLE_UINT\nfrom     = SLV_33\ndef      = 1 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_crossing_penalty\ntype     = SLE_UINT\nfrom     = SLV_33\ndef      = 3 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_trafficlight_penalty\ntype     = SLE_UINT\nfrom     = SL_MIN_VERSION\ndef      = 2 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\npatxname = \"\"pf.yapf.road_trafficlight_penalty\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_two_way_penalty\ntype     = SLE_UINT\nfrom     = SL_MIN_VERSION\ndef      = 2 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\npatxname = \"\"pf.yapf.road_two_way_penalty\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_one_way_penalty\ntype     = SLE_UINT\nfrom     = SL_MIN_VERSION\ndef      = 1 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\npatxname = \"\"pf.yapf.road_one_way_penalty\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_town_penalty\ntype     = SLE_UINT\nfrom     = SL_MIN_VERSION\ndef      = 2 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\npatxname = \"\"pf.yapf.road_town_penalty\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_stop_penalty\ntype     = SLE_UINT\nfrom     = SLV_47\ndef      = 8 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_stop_occupied_penalty\ntype     = SLE_UINT\nfrom     = SLV_130\ndef      = 8 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.road_stop_bay_occupied_penalty\ntype     = SLE_UINT\nfrom     = SLV_130\ndef      = 15 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.maximum_go_to_depot_penalty\ntype     = SLE_UINT\nfrom     = SLV_131\ndef      = 20 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.ship_curve45_penalty\ntype     = SLE_UINT\nfrom     = SLV_SHIP_CURVE_PENALTY\ndef      = 1 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = pf.yapf.ship_curve90_penalty\ntype     = SLE_UINT\nfrom     = SLV_SHIP_CURVE_PENALTY\ndef      = 6 * YAPF_TILE_LENGTH\nmin      = 0\nmax      = 1000000\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = order.old_occupancy_smoothness\ntype     = SLE_UINT8\ndef      = 75\nmin      = 0\nmax      = 100\ninterval = 10\nstr      = STR_CONFIG_OCCUPANCY_SMOOTHNESS\nstrhelp  = STR_CONFIG_OCCUPANCY_SMOOTHNESS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_PERCENTAGE\ncat      = SC_EXPERT\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_ORDER_OCCUPANCY, 1, 1)\npatxname = \"\"order_occupancy.order.occupancy_smoothness\"\"\n\n##\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.land_generator\ntype     = SLE_UINT8\nfrom     = SLV_30\nguiflags = SGF_MULTISTRING | SGF_NEWGAME_ONLY\ndef      = 1\nmin      = 0\nmax      = 1\nstr      = STR_CONFIG_SETTING_LAND_GENERATOR\nstrhelp  = STR_CONFIG_SETTING_LAND_GENERATOR_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LAND_GENERATOR_ORIGINAL\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.oil_refinery_limit\ntype     = SLE_UINT8\nfrom     = SLV_30\ndef      = 32\nmin      = 12\nmax      = 128\nstr      = STR_CONFIG_SETTING_OIL_REF_EDGE_DISTANCE\nstrval   = STR_CONFIG_SETTING_TILE_LENGTH\nstrhelp  = STR_CONFIG_SETTING_OIL_REF_EDGE_DISTANCE_HELPTEXT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.tgen_smoothness\ntype     = SLE_UINT8\nfrom     = SLV_30\nguiflags = SGF_MULTISTRING | SGF_NEWGAME_ONLY\ndef      = 1\nmin      = TGEN_SMOOTHNESS_BEGIN\nmax      = TGEN_SMOOTHNESS_END - 1\nstr      = STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN\nstrhelp  = STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_HELPTEXT\nstrval   = STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_VERY_SMOOTH\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.variety\ntype     = SLE_UINT8\nfrom     = SLV_197\nguiflags = SGF_MULTISTRING | SGF_NEWGAME_ONLY\ndef      = 0\nmin      = 0\nmax      = 5\nstr      = STR_CONFIG_SETTING_VARIETY\nstrhelp  = STR_CONFIG_SETTING_VARIETY_HELPTEXT\nstrval   = STR_VARIETY_NONE\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.generation_seed\ntype     = SLE_UINT32\nfrom     = SLV_30\ndef      = GENERATE_NEW_SEED\nmin      = 0\nmax      = UINT32_MAX\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.generation_unique_id\ntype     = SLE_UINT32\ndef      = 0\nmin      = 0\nmax      = UINT32_MAX\npatxname = \"\"savegame_unique_id.game_creation.generation_unique_id\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.tree_placer\ntype     = SLE_UINT8\nfrom     = SLV_30\nguiflags = SGF_MULTISTRING | SGF_NEWGAME_ONLY | SGF_SCENEDIT_TOO\ndef      = 2\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_TREE_PLACER\nstrhelp  = STR_CONFIG_SETTING_TREE_PLACER_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TREE_PLACER_NONE\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.heightmap_rotation\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 1\nstr      = STR_CONFIG_SETTING_HEIGHTMAP_ROTATION\nstrval   = STR_CONFIG_SETTING_HEIGHTMAP_ROTATION_COUNTER_CLOCKWISE\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.se_flat_world_height\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 1\nmin      = 0\nmax      = 15\nstr      = STR_CONFIG_SETTING_SE_FLAT_WORLD_HEIGHT\nstrval   = STR_JUST_COMMA\ncat      = SC_BASIC\n\n##\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.map_x\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 8\nmin      = MIN_MAP_SIZE_BITS\nmax      = MAX_MAP_SIZE_BITS\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.map_y\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 8\nmin      = MIN_MAP_SIZE_BITS\nmax      = MAX_MAP_SIZE_BITS\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.freeform_edges\nfrom     = SLV_111\ndef      = true\nproc     = CheckFreeformEdges\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.water_borders\ntype     = SLE_UINT8\nfrom     = SLV_111\ndef      = 15\nmin      = 0\nmax      = 16\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.custom_town_number\ntype     = SLE_UINT16\nfrom     = SLV_115\ndef      = 1\nmin      = 1\nmax      = 5000\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.extra_tree_placement\ntype     = SLE_UINT8\nfrom     = SLV_132\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT\nstrhelp  = STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT_HELPTEXT\nstrval   = STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT_NONE\ncat      = SC_BASIC\n\n;; construction.tree_placement_drag_limit, construction.ingame_tree_line_height, construction.tree_growth_rate\n[SDT_NULL]\nlength   = 3\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_CHILLPP, SL_CHILLPP_232)\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = construction.trees_around_snow_line_enabled\ndef      = true\nstr      = STR_CONFIG_SETTING_TREES_AROUND_SNOWLINE\nstrhelp  = STR_CONFIG_SETTING_TREES_AROUND_SNOWLINE_HELPTEXT\ncat      = SC_BASIC\npatxname = \"\"everest_treeline.construction.trees_around_snow_line_enabled\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.trees_around_snow_line_range\ntype     = SLE_UINT8\ndef      = 8\nmin      = 1\nmax      = 20\nstr      = STR_CONFIG_SETTING_TREES_AROUND_SNOWLINE_RANGE\nstrhelp  = STR_CONFIG_SETTING_TREES_AROUND_SNOWLINE_RANGE_HELPTEXT\nstrval   = STR_JUST_COMMA\ncat      = SC_BASIC\npatxname = \"\"everest_treeline.construction.trees_around_snow_line_range\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = construction.tree_growth_rate\ntype     = SLE_UINT8\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 4\nstr      = STR_CONFIG_SETTING_TREE_GROWTH\nstrhelp  = STR_CONFIG_SETTING_TREE_GROWTH_HELPTEXT\nstrval   = STR_CONFIG_SETTING_TREE_GROWTH_NORMAL\ncat      = SC_BASIC\npatxname = \"\"reduced_tree_growth.construction.tree_growth_rate\"\"\n\n[SDT_XREF]\nxref     = \"\"construction.tree_growth_rate\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n[SDT_XREF]\nxref     = \"\"construction.trees_around_snow_line_range\"\"\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.custom_sea_level\ntype     = SLE_UINT8\nfrom     = SLV_149\ndef      = CUSTOM_SEA_LEVEL_MIN_PERCENTAGE\nmin      = CUSTOM_SEA_LEVEL_MIN_PERCENTAGE\nmax      = CUSTOM_SEA_LEVEL_MAX_PERCENTAGE\ncat      = SC_BASIC\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.min_river_length\ntype     = SLE_UINT8\nfrom     = SLV_163\ndef      = 16\nmin      = 2\nmax      = 255\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.river_route_random\ntype     = SLE_UINT8\nfrom     = SLV_163\ndef      = 5\nmin      = 1\nmax      = 255\ncat      = SC_EXPERT\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_creation.amount_of_rivers\ntype     = SLE_UINT8\nfrom     = SLV_163\nguiflags = SGF_MULTISTRING | SGF_NEWGAME_ONLY\ndef      = 2\nmin      = 0\nmax      = 3\nstr      = STR_CONFIG_SETTING_RIVER_AMOUNT\nstrhelp  = STR_CONFIG_SETTING_RIVER_AMOUNT_HELPTEXT\nstrval   = STR_RIVERS_NONE\n\n;;game_creation.build_public_roads\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_JOKERPP)\n\n; locale\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = locale.currency\ntype     = SLE_UINT8\nfrom     = SLV_97\nflags    = SLF_NO_NETWORK_SYNC\ndef      = 0\nmax      = CURRENCY_END - 1\nfull     = _locale_currencies\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDTG_OMANY]\nname     = \"\"units\"\"\nvar      = _old_units\ntype     = SLE_UINT8\nfrom     = SLV_97\nto       = SLV_184\nflags    = SLF_NOT_IN_CONFIG\ndef      = 1\nmax      = 2\nfull     = _locale_units\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = locale.units_velocity\ntype     = SLE_UINT8\nfrom     = SLV_184\nflags    = SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _locale_units\nproc     = RedrawScreen\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_LOCALISATION_UNITS_VELOCITY\nstrhelp  = STR_CONFIG_SETTING_LOCALISATION_UNITS_VELOCITY_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LOCALISATION_UNITS_VELOCITY_IMPERIAL\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = locale.units_power\ntype     = SLE_UINT8\nfrom     = SLV_184\nflags    = SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _locale_units\nproc     = RedrawScreen\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_LOCALISATION_UNITS_POWER\nstrhelp  = STR_CONFIG_SETTING_LOCALISATION_UNITS_POWER_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LOCALISATION_UNITS_POWER_IMPERIAL\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = locale.units_weight\ntype     = SLE_UINT8\nfrom     = SLV_184\nflags    = SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _locale_units\nproc     = RedrawScreen\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_LOCALISATION_UNITS_WEIGHT\nstrhelp  = STR_CONFIG_SETTING_LOCALISATION_UNITS_WEIGHT_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LOCALISATION_UNITS_WEIGHT_IMPERIAL\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = locale.units_volume\ntype     = SLE_UINT8\nfrom     = SLV_184\nflags    = SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _locale_units\nproc     = RedrawScreen\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_LOCALISATION_UNITS_VOLUME\nstrhelp  = STR_CONFIG_SETTING_LOCALISATION_UNITS_VOLUME_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LOCALISATION_UNITS_VOLUME_IMPERIAL\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = locale.units_force\ntype     = SLE_UINT8\nfrom     = SLV_184\nflags    = SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmax      = 2\nfull     = _locale_units\nproc     = RedrawScreen\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_LOCALISATION_UNITS_FORCE\nstrhelp  = STR_CONFIG_SETTING_LOCALISATION_UNITS_FORCE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LOCALISATION_UNITS_FORCE_IMPERIAL\n\n[SDT_OMANY]\nbase     = GameSettings\nvar      = locale.units_height\ntype     = SLE_UINT8\nfrom     = SLV_184\nflags    = SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _locale_units\nproc     = RedrawScreen\ncat      = SC_BASIC\nstr      = STR_CONFIG_SETTING_LOCALISATION_UNITS_HEIGHT\nstrhelp  = STR_CONFIG_SETTING_LOCALISATION_UNITS_HEIGHT_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LOCALISATION_UNITS_HEIGHT_IMPERIAL\n\n[SDT_STR]\nbase     = GameSettings\nvar      = locale.digit_group_separator\ntype     = SLE_STRQ\nfrom     = SLV_118\nflags    = SLF_NO_NETWORK_SYNC\ndef      = nullptr\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDT_STR]\nbase     = GameSettings\nvar      = locale.digit_group_separator_currency\ntype     = SLE_STRQ\nfrom     = SLV_118\nflags    = SLF_NO_NETWORK_SYNC\ndef      = nullptr\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDT_STR]\nbase     = GameSettings\nvar      = locale.digit_decimal_separator\ntype     = SLE_STRQ\nfrom     = SLV_126\nflags    = SLF_NO_NETWORK_SYNC\ndef      = nullptr\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.adjacent_crossings\nguiflags = SGF_NO_NETWORK\ndef      = true\nstr      = STR_CONFIG_SETTING_ADJACENT_CROSSINGS\nstrhelp  = STR_CONFIG_SETTING_ADJACENT_CROSSINGS_HELPTEXT\ncat      = SC_BASIC\npatxname = \"\"adjacent_crossings.vehicle.adjacent_crossings\"\"\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.safer_crossings\ndef      = false\nstr      = STR_CONFIG_SETTING_SAFER_CROSSINGS\nstrhelp  = STR_CONFIG_SETTING_SAFER_CROSSINGS_HELPTEXT\ncat      = SC_BASIC\npatxname = \"\"safer_crossings.vehicle.safer_crossings\"\"\n\n\n;***************************************************************************\n; Unsaved setting variables.\n\n[SDTC_OMANY]\nvar      = gui.autosave\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 4\nfull     = _autosave_interval\nstr      = STR_CONFIG_SETTING_AUTOSAVE\nstrhelp  = STR_CONFIG_SETTING_AUTOSAVE_HELPTEXT\nstrval   = STR_GAME_OPTIONS_AUTOSAVE_DROPDOWN_OFF\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.threaded_saves\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\ncat      = SC_EXPERT\n\n[SDTC_OMANY]\nvar      = gui.date_format_in_default_names\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmax      = 2\nfull     = _savegame_date\nstr      = STR_CONFIG_SETTING_DATE_FORMAT_IN_SAVE_NAMES\nstrhelp  = STR_CONFIG_SETTING_DATE_FORMAT_IN_SAVE_NAMES_HELPTEXT\nstrval   = STR_CONFIG_SETTING_DATE_FORMAT_IN_SAVE_NAMES_LONG\n\n[SDTC_BOOL]\nvar      = gui.show_finances\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SHOWFINANCES\nstrhelp  = STR_CONFIG_SETTING_SHOWFINANCES_HELPTEXT\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.auto_scrolling\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 3\nstr      = STR_CONFIG_SETTING_AUTOSCROLL\nstrhelp  = STR_CONFIG_SETTING_AUTOSCROLL_HELPTEXT\nstrval   = STR_CONFIG_SETTING_AUTOSCROLL_DISABLED\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.scroll_mode\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 3\nstr      = STR_CONFIG_SETTING_SCROLLMODE\nstrhelp  = STR_CONFIG_SETTING_SCROLLMODE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_SCROLLMODE_DEFAULT\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.smooth_scroll\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SMOOTH_SCROLLING\nstrhelp  = STR_CONFIG_SETTING_SMOOTH_SCROLLING_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.right_mouse_wnd_close\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_RIGHT_MOUSE_WND_CLOSE\nstrhelp  = STR_CONFIG_SETTING_RIGHT_MOUSE_WND_CLOSE_HELPTEXT\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.measure_tooltip\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_MEASURE_TOOLTIP\nstrhelp  = STR_CONFIG_SETTING_MEASURE_TOOLTIP_HELPTEXT\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.errmsg_duration\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 5\nmin      = 0\nmax      = 20\nstr      = STR_CONFIG_SETTING_ERRMSG_DURATION\nstrhelp  = STR_CONFIG_SETTING_ERRMSG_DURATION_HELPTEXT\nstrval   = STR_CONFIG_SETTING_ERRMSG_DURATION_VALUE\n\n[SDTC_VAR]\nvar      = gui.hover_delay_ms\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_0ISDISABLED\ndef      = 250\nmin      = 50\nmax      = 6000\ninterval = 50\nstr      = STR_CONFIG_SETTING_HOVER_DELAY\nstrhelp  = STR_CONFIG_SETTING_HOVER_DELAY_HELPTEXT\nstrval   = STR_CONFIG_SETTING_HOVER_DELAY_VALUE\n\n[SDTC_OMANY]\nvar      = gui.osk_activation\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nstr      = STR_CONFIG_SETTING_OSK_ACTIVATION\nstrhelp  = STR_CONFIG_SETTING_OSK_ACTIVATION_HELPTEXT\nstrval   = STR_CONFIG_SETTING_OSK_ACTIVATION_DISABLED\nguiflags = SGF_MULTISTRING\nfull     = _osk_activation\ndef      = 1\nmin      = 0\nmax      = 3\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.toolbar_pos\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_TOOLBAR_POS\nstrhelp  = STR_CONFIG_SETTING_TOOLBAR_POS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_HORIZONTAL_POS_LEFT\nproc     = v_PositionMainToolbar\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.statusbar_pos\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_STATUSBAR_POS\nstrhelp  = STR_CONFIG_SETTING_STATUSBAR_POS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_HORIZONTAL_POS_LEFT\nproc     = v_PositionStatusbar\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.window_snap_radius\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_0ISDISABLED\ndef      = 10\nmin      = 1\nmax      = 32\nstr      = STR_CONFIG_SETTING_SNAP_RADIUS\nstrhelp  = STR_CONFIG_SETTING_SNAP_RADIUS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_SNAP_RADIUS_VALUE\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.window_soft_limit\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_0ISDISABLED\ndef      = 20\nmin      = 5\nmax      = 255\ninterval = 1\nstr      = STR_CONFIG_SETTING_SOFT_LIMIT\nstrhelp  = STR_CONFIG_SETTING_SOFT_LIMIT_HELPTEXT\nstrval   = STR_CONFIG_SETTING_SOFT_LIMIT_VALUE\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.zoom_min\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = ZOOM_LVL_MIN\nmin      = ZOOM_LVL_MIN\nmax      = ZOOM_LVL_OUT_4X\nstr      = STR_CONFIG_SETTING_ZOOM_MIN\nstrhelp  = STR_CONFIG_SETTING_ZOOM_MIN_HELPTEXT\nstrval   = STR_CONFIG_SETTING_ZOOM_LVL_MIN\nproc     = ZoomMinMaxChanged\n\n[SDTC_VAR]\nvar      = gui.zoom_max\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = ZOOM_LVL_MAX\nmin      = ZOOM_LVL_OUT_8X\nmax      = ZOOM_LVL_MAX\nstr      = STR_CONFIG_SETTING_ZOOM_MAX\nstrhelp  = STR_CONFIG_SETTING_ZOOM_MAX_HELPTEXT\nstrval   = STR_CONFIG_SETTING_ZOOM_LVL_OUT_2X\nproc     = ZoomMinMaxChanged\n\n[SDTC_BOOL]\nvar      = gui.population_in_label\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_POPULATION_IN_LABEL\nstrhelp  = STR_CONFIG_SETTING_POPULATION_IN_LABEL_HELPTEXT\nproc     = PopulationInLabelActive\n\n[SDTC_BOOL]\nvar      = gui.link_terraform_toolbar\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_LINK_TERRAFORM_TOOLBAR\nstrhelp  = STR_CONFIG_SETTING_LINK_TERRAFORM_TOOLBAR_HELPTEXT\n\n[SDTC_VAR]\nvar      = gui.smallmap_land_colour\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_SMALLMAP_LAND_COLOUR\nstrhelp  = STR_CONFIG_SETTING_SMALLMAP_LAND_COLOUR_HELPTEXT\nstrval   = STR_CONFIG_SETTING_SMALLMAP_LAND_COLOUR_GREEN\nproc     = RedrawSmallmap\n\n[SDTC_VAR]\nvar      = gui.liveries\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_LIVERIES\nstrhelp  = STR_CONFIG_SETTING_LIVERIES_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LIVERIES_NONE\nproc     = InvalidateCompanyLiveryWindow\n\n[SDTC_VAR]\nvar      = gui.starting_colour\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = COLOUR_END\nmin      = 0\nmax      = COLOUR_END\nstr      = STR_CONFIG_SETTING_COMPANY_STARTING_COLOUR\nstrhelp  = STR_CONFIG_SETTING_COMPANY_STARTING_COLOUR_HELPTEXT\nstrval   = STR_COLOUR_DARK_BLUE\n\n[SDTC_BOOL]\nvar      = gui.prefer_teamchat\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_PREFER_TEAMCHAT\nstrhelp  = STR_CONFIG_SETTING_PREFER_TEAMCHAT_HELPTEXT\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.scrollwheel_scrolling\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_SCROLLWHEEL_SCROLLING\nstrhelp  = STR_CONFIG_SETTING_SCROLLWHEEL_SCROLLING_HELPTEXT\nstrval   = STR_CONFIG_SETTING_SCROLLWHEEL_ZOOM\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.scrollwheel_multiplier\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 5\nmin      = 1\nmax      = 15\ninterval = 1\nstr      = STR_CONFIG_SETTING_SCROLLWHEEL_MULTIPLIER\nstrhelp  = STR_CONFIG_SETTING_SCROLLWHEEL_MULTIPLIER_HELPTEXT\nstrval   = STR_JUST_COMMA\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.viewport_map_scan_surroundings\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_SCAN_SURROUNDINGS\nproc     = RedrawScreen\n\n[SDTC_BOOL]\nvar      = gui.show_slopes_on_viewport_map\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_SLOPES\nproc     = RedrawScreen\n\n[SDTC_BOOL]\nvar      = gui.show_bridges_on_map\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_BRIDGES\nproc     = RedrawScreen\n\n[SDTC_BOOL]\nvar      = gui.show_tunnels_on_map\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_TUNNELS\nproc     = ViewportMapShowTunnelModeChanged\n\n[SDTC_VAR]\nvar      = gui.show_vehicle_route\ntype     = SLE_UINT32\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 1\ninterval = 1\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE\nstrval   = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_NO\nproc     = RedrawScreen\n\n[SDTC_VAR]\nvar      = gui.dash_level_of_route_lines\ntype     = SLE_UINT32\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_0ISDISABLED\ndef      = 0\nmin      = 0\nmax      = 10\ninterval = 1\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_DRAW_ROUTE_DASH\nstrval   = STR_CONFIG_SETTING_VIEWPORT_MAP_DRAW_ROUTE_DASH_VALUE\nproc     = RedrawScreen\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.use_owner_colour_for_tunnelbridge\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_USE_OWNER_COLOUR_BRIDGE_TUNNEL\nproc     = RedrawScreen\n\n[SDTC_VAR]\nvar      = gui.show_scrolling_viewport_on_map\ntype     = SLE_UINT32\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 3\nmin      = 0\nmax      = 3\ninterval = 1\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_SCROLLING_VP\nstrval   = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_SCROLLING_VP_NOTHING\n\n[SDTC_VAR]\nvar      = gui.default_viewport_map_mode\ntype     = SLE_UINT32\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_DEFAULT_MODE\nstrval   = STR_CONFIG_SETTING_VIEWPORT_MAP_DEFAULT_MODE_VEGETATION\n\n[SDTC_VAR]\nvar      = gui.action_when_viewport_map_is_dblclicked\ntype     = SLE_UINT32\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_VIEWPORT_MAP_ACTION_DBLCLICK\nstrval   = STR_CONFIG_SETTING_VIEWPORT_MAP_ACTION_DBLCLICK_DO_NOTHING\n\n[SDTC_BOOL]\nvar      = gui.pause_on_newgame\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_PAUSE_ON_NEW_GAME\nstrhelp  = STR_CONFIG_SETTING_PAUSE_ON_NEW_GAME_HELPTEXT\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.advanced_vehicle_list\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_ADVANCED_VEHICLE_LISTS\nstrhelp  = STR_CONFIG_SETTING_ADVANCED_VEHICLE_LISTS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_COMPANIES_OFF\n\n[SDTC_BOOL]\nvar      = gui.timetable_in_ticks\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_TIMETABLE_IN_TICKS\nstrhelp  = STR_CONFIG_SETTING_TIMETABLE_IN_TICKS_HELPTEXT\nproc     = InvalidateVehTimetableWindow\ncat      = SC_EXPERT\n\n;; gui.time_in_minutes\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP, 7)\n\n[SDTC_BOOL]\nvar      = gui.timetable_leftover_ticks\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_TIMETABLE_LEFTOVER_TICKS\nstrhelp  = STR_CONFIG_SETTING_TIMETABLE_LEFTOVER_TICKS_HELPTEXT\nproc     = InvalidateVehTimetableWindow\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.override_time_settings\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_OVERRIDE_TIME_SETTINGS\nstrhelp  = STR_CONFIG_SETTING_OVERRIDE_TIME_SETTINGS_HELPTEXT\nproc     = ChangeTimeOverrideMode\n\n[SDTC_BOOL]\nvar      = gui.time_in_minutes\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_TIME_IN_MINUTES\nstrhelp  = STR_CONFIG_SETTING_TIME_IN_MINUTES_HELPTEXT\nproc     = UpdateTimeSettings\n\n[SDTC_VAR]\nvar      = gui.ticks_per_minute\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nstrval   = STR_JUST_INT\ndef      = 74\nmin      = 1\nmax      = 8192\ninterval = 10\nstr      = STR_CONFIG_SETTING_TICKS_PER_MINUTE\nstrhelp  = STR_CONFIG_SETTING_TICKS_PER_MINUTE_HELPTEXT\nproc     = UpdateTimeSettings\n\n[SDTC_VAR]\nvar      = gui.clock_offset\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nstrval   = STR_JUST_INT\ndef      = 0\nmin      = 0\nmax      = 1439\ninterval = 60\nstr      = STR_CONFIG_SETTING_CLOCK_OFFSET\nstrhelp  = STR_CONFIG_SETTING_CLOCK_OFFSET_HELPTEXT\nproc     = UpdateTimeSettings\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = game_time.time_in_minutes\ndef      = false\nstr      = STR_CONFIG_SETTING_TIME_IN_MINUTES\nstrhelp  = STR_CONFIG_SETTING_TIME_IN_MINUTES_HELPTEXT\nproc     = UpdateTimeSettings\npatxname = \"\"game_time.time_in_minutes\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_time.ticks_per_minute\ntype     = SLE_UINT16\nstrval   = STR_JUST_INT\ndef      = 74\nmin      = 1\nmax      = 8192\ninterval = 10\nstr      = STR_CONFIG_SETTING_TICKS_PER_MINUTE\nstrhelp  = STR_CONFIG_SETTING_TICKS_PER_MINUTE_HELPTEXT\nproc     = UpdateTimeSettings\npatxname = \"\"game_time.ticks_per_minute\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = game_time.clock_offset\ntype     = SLE_UINT16\nstrval   = STR_JUST_INT\ndef      = 0\nmin      = 0\nmax      = 1439\ninterval = 60\nstr      = STR_CONFIG_SETTING_CLOCK_OFFSET\nstrhelp  = STR_CONFIG_SETTING_CLOCK_OFFSET_HELPTEXT\nproc     = UpdateTimeSettings\npatxname = \"\"game_time.clock_offset\"\"\n\n;; gui.ticks_per_minute\n[SDT_NULL]\nlength   = 1\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_SPRINGPP, 7)\n\n[SDTC_VAR]\nvar      = gui.date_with_time\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 3\nstr      = STR_CONFIG_SETTING_DATE_WITH_TIME\nstrval   = STR_CONFIG_SETTING_DATE_WITH_TIME_NONE\nstrhelp  = STR_CONFIG_SETTING_DATE_WITH_TIME_HELPTEXT\nproc     = RedrawScreen\n\n[SDTC_BOOL]\nvar      = gui.timetable_start_text_entry\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_TIMETABLE_START_TEXT_ENTRY\nstrhelp  = STR_CONFIG_SETTING_TIMETABLE_START_TEXT_ENTRY_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.timetable_arrival_departure\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_TIMETABLE_SHOW_ARRIVAL_DEPARTURE\nstrhelp  = STR_CONFIG_SETTING_TIMETABLE_SHOW_ARRIVAL_DEPARTURE_HELPTEXT\nproc     = InvalidateVehTimetableWindow\n\n[SDTC_VAR]\nvar      = gui.max_departures\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nstrval   = STR_JUST_INT\ndef      = 10\nmin      = 1\nmax      = 30\ninterval = 1\nstr      = STR_CONFIG_MAX_DEPARTURES\nstrhelp  = STR_CONFIG_MAX_DEPARTURES_HELPTEXT\n\n[SDTC_VAR]\nvar      = gui.max_departure_time\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nstrval   = STR_JUST_INT\ndef      = 120\nmin      = 30\nmax      = 240\ninterval = 1\nstr      = STR_CONFIG_MAX_DEPARTURE_TIME\nstrhelp  = STR_CONFIG_MAX_DEPARTURE_TIME_HELPTEXT\n\n[SDTC_VAR]\nvar      = gui.departure_calc_frequency\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nstrval   = STR_JUST_INT\ndef      = 10\nmin      = 1\nmax      = 120\ninterval = 1\nstr      = STR_CONFIG_DEPARTURE_CALC_FREQUENCY\nstrhelp  = STR_CONFIG_DEPARTURE_CALC_FREQUENCY_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_show_vehicle\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_VEHICLE_NAME\nstrhelp  = STR_CONFIG_DEPARTURE_VEHICLE_NAME_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_show_group\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_GROUP_NAME\nstrhelp  = STR_CONFIG_DEPARTURE_GROUP_NAME_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_show_company\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_COMPANY_NAME\nstrhelp  = STR_CONFIG_DEPARTURE_COMPANY_NAME_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_show_vehicle_type\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_VEHICLE_TYPE\nstrhelp  = STR_CONFIG_DEPARTURE_VEHICLE_TYPE_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_show_vehicle_color\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_VEHICLE_COLOR\nstrhelp  = STR_CONFIG_DEPARTURE_VEHICLE_COLOR_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_larger_font\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_LARGER_FONT\nstrhelp  = STR_CONFIG_DEPARTURE_LARGER_FONT_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_destination_type\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_DESTINATION_TYPE\nstrhelp  = STR_CONFIG_DEPARTURE_DESTINATION_TYPE_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_show_both\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_SHOW_BOTH\nstrhelp  = STR_CONFIG_DEPARTURE_SHOW_BOTH_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_only_passengers\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_ONLY_PASSENGERS\nstrhelp  = STR_CONFIG_DEPARTURE_ONLY_PASSENGERS_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_smart_terminus\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_SMART_TERMINUS\nstrhelp  = STR_CONFIG_DEPARTURE_SMART_TERMINUS_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_show_all_stops\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_SHOW_ALL_STOPS\nstrhelp  = STR_CONFIG_DEPARTURE_SHOW_ALL_STOPS_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.departure_merge_identical\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_DEPARTURE_MERGE_IDENTICAL\nstrhelp  = STR_CONFIG_DEPARTURE_MERGE_IDENTICAL_HELPTEXT\n\n[SDTC_VAR]\nvar      = gui.departure_conditionals\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_DEPARTURE_CONDITIONALS\nstrval   = STR_CONFIG_DEPARTURE_CONDITIONALS_1\nstrhelp  = STR_CONFIG_DEPARTURE_CONDITIONALS_HELPTEXT\nproc     = RedrawScreen\n\n[SDTC_BOOL]\nvar      = gui.quick_goto\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_QUICKGOTO\nstrhelp  = STR_CONFIG_SETTING_QUICKGOTO_HELPTEXT\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.loading_indicators\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_LOADING_INDICATORS\nstrhelp  = STR_CONFIG_SETTING_LOADING_INDICATORS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_COMPANIES_OFF\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.default_rail_type\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_DEFAULT_RAIL_TYPE\nstrhelp  = STR_CONFIG_SETTING_DEFAULT_RAIL_TYPE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_DEFAULT_RAIL_TYPE_FIRST\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.enable_signal_gui\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_ENABLE_SIGNAL_GUI\nstrhelp  = STR_CONFIG_SETTING_ENABLE_SIGNAL_GUI_HELPTEXT\nproc     = CloseSignalGUI\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.coloured_news_year\ntype     = SLE_INT32\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 2000\nmin      = MIN_YEAR\nmax      = MAX_YEAR\ninterval = 1\nstr      = STR_CONFIG_SETTING_COLOURED_NEWS_YEAR\nstrhelp  = STR_CONFIG_SETTING_COLOURED_NEWS_YEAR_HELPTEXT\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.drag_signals_density\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 4\nmin      = 1\nmax      = 20\nstr      = STR_CONFIG_SETTING_DRAG_SIGNALS_DENSITY\nstrhelp  = STR_CONFIG_SETTING_DRAG_SIGNALS_DENSITY_HELPTEXT\nstrval   = STR_CONFIG_SETTING_DRAG_SIGNALS_DENSITY_VALUE\nproc     = DragSignalsDensityChanged\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.drag_signals_fixed_distance\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_DRAG_SIGNALS_FIXED_DISTANCE\nstrhelp  = STR_CONFIG_SETTING_DRAG_SIGNALS_FIXED_DISTANCE_HELPTEXT\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.semaphore_build_before\ntype     = SLE_INT32\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 1950\nmin      = MIN_YEAR\nmax      = MAX_YEAR\ninterval = 1\nstr      = STR_CONFIG_SETTING_SEMAPHORE_BUILD_BEFORE_DATE\nstrhelp  = STR_CONFIG_SETTING_SEMAPHORE_BUILD_BEFORE_DATE_HELPTEXT\nstrval   = STR_JUST_INT\nproc     = ResetSignalVariant\n\n[SDTC_BOOL]\nvar      = gui.vehicle_income_warn\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_WARN_INCOME_LESS\nstrhelp  = STR_CONFIG_SETTING_WARN_INCOME_LESS_HELPTEXT\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.order_review_system\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_ORDER_REVIEW\nstrhelp  = STR_CONFIG_SETTING_ORDER_REVIEW_HELPTEXT\nstrval   = STR_CONFIG_SETTING_ORDER_REVIEW_OFF\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.no_depot_order_warn\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_WARN_NO_DEPOT_ORDER\nstrhelp  = STR_CONFIG_SETTING_WARN_NO_DEPOT_ORDER_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.lost_vehicle_warn\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_WARN_LOST_VEHICLE\nstrhelp  = STR_CONFIG_SETTING_WARN_LOST_VEHICLE_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.restriction_wait_vehicle_warn\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_WARN_RESTRICTION_WAIT_VEHICLE\nstrhelp  = STR_CONFIG_SETTING_WARN_RESTRICTION_WAIT_VEHICLE_HELPTEXT\n\n[SDTC_BOOL]\nvar      = gui.disable_unsuitable_building\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_DISABLE_UNSUITABLE_BUILDING\nstrhelp  = STR_CONFIG_SETTING_DISABLE_UNSUITABLE_BUILDING_HELPTEXT\nproc     = RedrawScreen\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.new_nonstop\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_NONSTOP_BY_DEFAULT\nstrhelp  = STR_CONFIG_SETTING_NONSTOP_BY_DEFAULT_HELPTEXT\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.stop_location\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_STOP_LOCATION\nstrhelp  = STR_CONFIG_SETTING_STOP_LOCATION_HELPTEXT\nstrval   = STR_CONFIG_SETTING_STOP_LOCATION_NEAR_END\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.keep_all_autosave\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\n\n[SDTC_BOOL]\nvar      = gui.autosave_on_exit\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.autosave_on_network_disconnect\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_AUTOSAVE_ON_NETWORK_DISCONNECT\nstrhelp  = STR_CONFIG_SETTING_AUTOSAVE_ON_NETWORK_DISCONNECT_HELPTEXT\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.max_num_autosaves\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 16\nmin      = 0\nmax      = 255\n\n[SDTC_OMANY]\nvar      = gui.savegame_overwrite_confirm\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nstr      = STR_CONFIG_SETTING_SAVEGAME_OVERWRITE_CONFIRM\nstrhelp  = STR_CONFIG_SETTING_SAVEGAME_OVERWRITE_CONFIRM_HELPTEXT\nstrval   = STR_CONFIG_SETTING_SAVEGAME_OVERWRITE_CONFIRM_DISABLED\nguiflags = SGF_MULTISTRING\nfull     = _savegame_overwrite_confirm\ndef      = 3\nmin      = 0\nmax      = 3\n\n[SDTC_BOOL]\nvar      = gui.auto_euro\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\n\n[SDTC_VAR]\nvar      = gui.news_message_timeout\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 2\nmin      = 1\nmax      = 255\n\n[SDTC_BOOL]\nvar      = gui.show_track_reservation\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SHOW_TRACK_RESERVATION\nstrhelp  = STR_CONFIG_SETTING_SHOW_TRACK_RESERVATION_HELPTEXT\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.default_signal_type\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_DEFAULT_SIGNAL_TYPE\nstrhelp  = STR_CONFIG_SETTING_DEFAULT_SIGNAL_TYPE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_DEFAULT_SIGNAL_NORMAL\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = gui.cycle_signal_types\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_CYCLE_SIGNAL_TYPES\nstrhelp  = STR_CONFIG_SETTING_CYCLE_SIGNAL_TYPES_HELPTEXT\nstrval   = STR_CONFIG_SETTING_CYCLE_SIGNAL_NORMAL\n\n[SDTC_VAR]\nvar      = gui.station_numtracks\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 1\nmin      = 1\nmax      = 7\n\n[SDTC_VAR]\nvar      = gui.station_platlength\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 5\nmin      = 1\nmax      = 7\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.station_dragdrop\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.station_show_coverage\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.persistent_buildingtools\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_PERSISTENT_BUILDINGTOOLS\nstrhelp  = STR_CONFIG_SETTING_PERSISTENT_BUILDINGTOOLS_HELPTEXT\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.expenses_layout\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_EXPENSES_LAYOUT\nstrhelp  = STR_CONFIG_SETTING_EXPENSES_LAYOUT_HELPTEXT\nproc     = RedrawScreen\n\n[SDTC_VAR]\nvar      = gui.station_gui_group_order\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 0\nmin      = 0\nmax      = 5\ninterval = 1\n\n[SDTC_VAR]\nvar      = gui.station_gui_sort_by\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 0\nmin      = 0\nmax      = 3\ninterval = 1\n\n[SDTC_VAR]\nvar      = gui.station_gui_sort_order\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 0\nmin      = 0\nmax      = 1\ninterval = 1\n\n[SDTC_VAR]\nvar      = gui.missing_strings_threshold\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 25\nmin      = 1\nmax      = UINT8_MAX\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.graph_line_thickness\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 3\nmin      = 1\nmax      = 5\nstr      = STR_CONFIG_SETTING_GRAPH_LINE_THICKNESS\nstrhelp  = STR_CONFIG_SETTING_GRAPH_LINE_THICKNESS_HELPTEXT\nstrval   = STR_JUST_COMMA\nproc     = RedrawScreen\n\n[SDTC_BOOL]\nvar      = gui.show_vehicle_route_steps\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SHOW_VEHICLE_ROUTE_STEPS\nproc     = RedrawScreen\n\n[SDTC_BOOL]\nvar      = gui.show_train_length_in_details\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SHOW_TRAIN_LENGTH_IN_DETAILS\nstrhelp  = STR_CONFIG_SETTING_SHOW_TRAIN_LENGTH_IN_DETAILS_HELPTEXT\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.show_train_weight_ratios_in_details\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SHOW_TRAIN_WEIGHT_RATIOS_IN_DETAILS\nstrhelp  = STR_CONFIG_SETTING_SHOW_TRAIN_WEIGHT_RATIOS_IN_DETAILS_HELPTEXT\nproc     = RedrawScreen\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.show_vehicle_group_in_details\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SHOW_VEHICLE_GROUP_IN_DETAILS\nstrhelp  = STR_CONFIG_SETTING_SHOW_VEHICLE_GROUP_IN_DETAILS_HELPTEXT\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.show_vehicle_list_company_colour\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SHOW_VEHICLE_LIST_COMPANY_COLOUR\nstrhelp  = STR_CONFIG_SETTING_SHOW_VEHICLE_LIST_COMPANY_COLOUR_HELPTEXT\nproc     = RedrawScreen\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = gui.show_restricted_signal_default\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SHOW_RESTRICTED_SIG_DEF\nstrhelp  = STR_CONFIG_SETTING_SHOW_RESTRICTED_SIG_DEF_HELPTEXT\nproc     = RedrawScreen\n\n[SDTC_BOOL]\nvar      = gui.show_adv_tracerestrict_features\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SHOW_ADV_TRACE_RESTRICT_FEATURES\nstrhelp  = STR_CONFIG_SETTING_SHOW_ADV_TRACE_RESTRICT_FEATURES_HELPTEXT\nproc     = RedrawScreen\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.show_progsig_ui\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SHOW_PROGSIG_FEATURES\nstrhelp  = STR_CONFIG_SETTING_SHOW_PROGSIG_FEATURES_HELPTEXT\nproc     = ProgrammableSignalsShownChanged\ncat      = SC_ADVANCED\n\n[SDTC_BOOL]\nvar      = gui.show_veh_list_cargo_filter\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SHOW_VEH_LIST_CARGO_FILTER\nstrhelp  = STR_CONFIG_SETTING_SHOW_VEH_LIST_CARGO_FILTER_HELPTEXT\nproc     = VehListCargoFilterShownChanged\n\n[SDTC_BOOL]\nvar      = gui.enable_single_veh_shared_order_gui\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_ENABLE_SINGLE_VEH_SHARED_ORDER_GUI\nstrhelp  = STR_CONFIG_SETTING_ENABLE_SINGLE_VEH_SHARED_ORDER_GUI_HELPTEXT\nproc     = EnableSingleVehSharedOrderGuiChanged\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.show_adv_load_mode_features\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SHOW_ADV_LOADING_MODE_FEATURES\nstrhelp  = STR_CONFIG_SETTING_SHOW_ADV_LOADING_MODE_FEATURES_HELPTEXT\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.disable_top_veh_list_mass_actions\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_DISABLE_TOP_VEH_LIST_MASS_ACTIONS\nstrhelp  = STR_CONFIG_SETTING_DISABLE_TOP_VEH_LIST_MASS_ACTIONS_HELPTEXT\nproc     = RedrawScreen\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.adv_sig_bridge_tun_modes\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_ADV_SIG_BRIDGE_TUN_MODES\nstrhelp  = STR_CONFIG_SETTING_ADV_SIG_BRIDGE_TUN_MODES_HELPTEXT\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.show_depot_sell_gui\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SHOW_DEPOT_SELL_GUI\nstrhelp  = STR_CONFIG_SETTING_SHOW_DEPOT_SELL_GUI_HELPTEXT\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.open_vehicle_gui_clone_share\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_OPEN_VEHICLE_GUI_CLONE_SHARE\nstrhelp  = STR_CONFIG_SETTING_OPEN_VEHICLE_GUI_CLONE_SHARE_HELPTEXT\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.show_newgrf_name\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SHOW_NEWGRF_NAME\nstrhelp  = STR_CONFIG_SETTING_SHOW_NEWGRF_NAME_HELPTEXT\nproc     = RedrawScreen\ncat      = SC_ADVANCED\n\n[SDTC_VAR]\nvar      = gui.linkgraph_colours\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 3\nstr      = STR_CONFIG_SETTING_LINKGRAPH_COLOURS\nstrhelp  = STR_CONFIG_SETTING_LINKGRAPH_COLOURS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_LINKGRAPH_COLOURS_GREEN_TO_RED\nproc     = UpdateLinkgraphColours\ncat      = SC_BASIC\n\n; For the dedicated build we'll enable dates in logs by default.\n[SDTC_BOOL]\nifdef    = DEDICATED\nvar      = gui.show_date_in_logs\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\n\n[SDTC_BOOL]\nifndef   = DEDICATED\nvar      = gui.show_date_in_logs\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\n\n[SDTC_VAR]\nvar      = gui.settings_restriction_mode\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 0\nmin      = 0\nmax      = 2\n\n[SDTC_VAR]\nvar      = gui.developer\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 1\nmin      = 0\nmax      = 2\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.newgrf_developer_tools\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nproc     = InvalidateNewGRFChangeWindows\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.ai_developer_tools\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nproc     = InvalidateAISettingsWindow\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.scenario_developer\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nproc     = InvalidateNewGRFChangeWindows\n\n[SDTC_BOOL]\nvar      = gui.newgrf_show_old_versions\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.newgrf_default_palette\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmin      = 0\nmax      = 1\nproc     = UpdateNewGRFConfigPalette\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = gui.console_show_unlisted\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.console_backlog_timeout\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 100\nmin      = 10\nmax      = 65500\n\n[SDTC_VAR]\nvar      = gui.console_backlog_length\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 100\nmin      = 10\nmax      = 65500\n\n[SDTC_BOOL]\nvar      = sound.news_ticker\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SOUND_TICKER\nstrhelp  = STR_CONFIG_SETTING_SOUND_TICKER_HELPTEXT\n\n[SDTC_BOOL]\nvar      = sound.news_full\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SOUND_NEWS\nstrhelp  = STR_CONFIG_SETTING_SOUND_NEWS_HELPTEXT\n\n[SDTC_BOOL]\nvar      = sound.new_year\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SOUND_NEW_YEAR\nstrhelp  = STR_CONFIG_SETTING_SOUND_NEW_YEAR_HELPTEXT\n\n[SDTC_BOOL]\nvar      = sound.confirm\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SOUND_CONFIRM\nstrhelp  = STR_CONFIG_SETTING_SOUND_CONFIRM_HELPTEXT\n\n[SDTC_BOOL]\nvar      = sound.click_beep\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SOUND_CLICK\nstrhelp  = STR_CONFIG_SETTING_SOUND_CLICK_HELPTEXT\n\n[SDTC_BOOL]\nvar      = sound.disaster\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SOUND_DISASTER\nstrhelp  = STR_CONFIG_SETTING_SOUND_DISASTER_HELPTEXT\n\n[SDTC_BOOL]\nvar      = sound.vehicle\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SOUND_VEHICLE\nstrhelp  = STR_CONFIG_SETTING_SOUND_VEHICLE_HELPTEXT\n\n[SDTC_BOOL]\nvar      = sound.ambient\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\nstr      = STR_CONFIG_SETTING_SOUND_AMBIENT\nstrhelp  = STR_CONFIG_SETTING_SOUND_AMBIENT_HELPTEXT\n\n[SDTC_VAR]\nvar      = music.playlist\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 0\nmin      = 0\nmax      = 5\ninterval = 1\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = music.music_vol\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 127\nmin      = 0\nmax      = 127\ninterval = 1\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = music.effect_vol\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 127\nmin      = 0\nmax      = 127\ninterval = 1\ncat      = SC_BASIC\n\n[SDTC_LIST]\nvar      = music.custom_1\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = nullptr\ncat      = SC_BASIC\n\n[SDTC_LIST]\nvar      = music.custom_2\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = nullptr\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = music.playing\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = true\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = music.shuffle\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\ncat      = SC_BASIC\n\n[SDTC_OMANY]\nvar      = news_display.arrival_player\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_ARRIVAL_FIRST_VEHICLE_OWN\nstrhelp  = STR_CONFIG_SETTING_NEWS_ARRIVAL_FIRST_VEHICLE_OWN_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.arrival_other\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_ARRIVAL_FIRST_VEHICLE_OTHER\nstrhelp  = STR_CONFIG_SETTING_NEWS_ARRIVAL_FIRST_VEHICLE_OTHER_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.accident\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_ACCIDENTS_DISASTERS\nstrhelp  = STR_CONFIG_SETTING_NEWS_ACCIDENTS_DISASTERS_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.company_info\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_COMPANY_INFORMATION\nstrhelp  = STR_CONFIG_SETTING_NEWS_COMPANY_INFORMATION_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.open\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_INDUSTRY_OPEN\nstrhelp  = STR_CONFIG_SETTING_NEWS_INDUSTRY_OPEN_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.close\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_INDUSTRY_CLOSE\nstrhelp  = STR_CONFIG_SETTING_NEWS_INDUSTRY_CLOSE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.economy\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_ECONOMY_CHANGES\nstrhelp  = STR_CONFIG_SETTING_NEWS_ECONOMY_CHANGES_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.production_player\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_INDUSTRY_CHANGES_COMPANY\nstrhelp  = STR_CONFIG_SETTING_NEWS_INDUSTRY_CHANGES_COMPANY_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.production_other\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_INDUSTRY_CHANGES_OTHER\nstrhelp  = STR_CONFIG_SETTING_NEWS_INDUSTRY_CHANGES_OTHER_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.production_nobody\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_INDUSTRY_CHANGES_UNSERVED\nstrhelp  = STR_CONFIG_SETTING_NEWS_INDUSTRY_CHANGES_UNSERVED_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.advice\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_ADVICE\nstrhelp  = STR_CONFIG_SETTING_NEWS_ADVICE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.new_vehicles\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_NEW_VEHICLES\nstrhelp  = STR_CONFIG_SETTING_NEWS_NEW_VEHICLES_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.acceptance\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_CHANGES_ACCEPTANCE\nstrhelp  = STR_CONFIG_SETTING_NEWS_CHANGES_ACCEPTANCE_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.subsidies\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 1\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_SUBSIDIES\nstrhelp  = STR_CONFIG_SETTING_NEWS_SUBSIDIES_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_OMANY]\nvar      = news_display.general\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 2\nmax      = 2\nfull     = _news_display\nstr      = STR_CONFIG_SETTING_NEWS_GENERAL_INFORMATION\nstrhelp  = STR_CONFIG_SETTING_NEWS_GENERAL_INFORMATION_HELPTEXT\nstrval   = STR_CONFIG_SETTING_NEWS_MESSAGES_OFF\n\n[SDTC_BOOL]\nvar      = scenario.multiple_buildings\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SCENARIO_MULTIPLE_BUILDINGS\nstrhelp  = STR_CONFIG_SETTING_SCENARIO_MULTIPLE_BUILDINGS_HELPTEXT\n\n[SDTC_BOOL]\nvar      = scenario.house_ignore_dates\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SCENARIO_HOUSE_IGNORE_DATES\nstrhelp  = STR_CONFIG_SETTING_SCENARIO_HOUSE_IGNORE_DATES_HELPTEXT\n\n[SDTC_VAR]\nvar      = scenario.house_ignore_zones\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\ninterval = 1\nstr      = STR_CONFIG_SETTING_SCENARIO_HOUSE_IGNORE_ZONES\nstrhelp  = STR_CONFIG_SETTING_SCENARIO_HOUSE_IGNORE_ZONES_HELPTEXT\nstrval   = STR_CONFIG_SETTING_SCENARIO_HOUSE_IGNORE_ZONES_OFF\n\n[SDTC_BOOL]\nvar      = scenario.house_ignore_grf\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\nstr      = STR_CONFIG_SETTING_SCENARIO_HOUSE_IGNORE_GRF\nstrhelp  = STR_CONFIG_SETTING_SCENARIO_HOUSE_IGNORE_GRF_HELPTEXT\n\n[SDTC_VAR]\nvar      = gui.network_chat_box_width_pct\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 40\nmin      = 10\nmax      = 100\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.network_chat_box_height\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 25\nmin      = 5\nmax      = 255\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = gui.network_chat_timeout\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 20\nmin      = 1\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.sync_freq\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NOT_IN_CONFIG | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 100\nmin      = 0\nmax      = 100\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.frame_freq\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NOT_IN_CONFIG | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 0\nmin      = 0\nmax      = 100\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.commands_per_frame\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 2\nmin      = 1\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.max_commands_in_queue\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 16\nmin      = 1\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.bytes_per_frame\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 8\nmin      = 1\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.bytes_per_frame_burst\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 256\nmin      = 1\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.max_init_time\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 100\nmin      = 0\nmax      = 32000\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.max_join_time\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 500\nmin      = 0\nmax      = 32000\n\n[SDTC_VAR]\nvar      = network.max_download_time\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 1000\nmin      = 0\nmax      = 32000\n\n[SDTC_VAR]\nvar      = network.max_password_time\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 2000\nmin      = 0\nmax      = 32000\n\n[SDTC_VAR]\nvar      = network.max_lag_time\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 500\nmin      = 0\nmax      = 32000\n\n[SDTC_BOOL]\nvar      = network.pause_on_join\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = true\n\n[SDTC_VAR]\nvar      = network.server_port\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = NETWORK_DEFAULT_PORT\nmin      = 0\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.server_admin_port\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = NETWORK_ADMIN_PORT\nmin      = 0\nmax      = 65535\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = network.server_admin_chat\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = true\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = network.server_advertise\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = false\n\n[SDTC_VAR]\nvar      = network.lan_internet\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 1\nmin      = 0\nmax      = 1\n\n[SDTC_STR]\nvar      = network.client_name\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = nullptr\nproc     = UpdateClientName\ncat      = SC_BASIC\n\n[SDTC_STR]\nvar      = network.server_password\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = nullptr\nproc     = UpdateServerPassword\ncat      = SC_BASIC\n\n[SDTC_STR]\nvar      = network.rcon_password\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = nullptr\nproc     = UpdateRconPassword\ncat      = SC_BASIC\n\n[SDTC_STR]\nvar      = network.admin_password\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = nullptr\ncat      = SC_BASIC\n\n[SDTC_STR]\nvar      = network.settings_password\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = nullptr\nproc     = UpdateSettingsPassword\ncat      = SC_EXPERT\n\n[SDTC_STR]\nvar      = network.default_company_pass\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = nullptr\n\n[SDTC_STR]\nvar      = network.server_name\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = nullptr\ncat      = SC_BASIC\n\n[SDTC_STR]\nvar      = network.connect_to_ip\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = nullptr\n\n[SDTC_STR]\nvar      = network.network_id\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = nullptr\n\n[SDTC_BOOL]\nvar      = network.autoclean_companies\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = false\n\n[SDTC_VAR]\nvar      = network.autoclean_unprotected\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_0ISDISABLED | SGF_NETWORK_ONLY\ndef      = 12\nmin      = 0\nmax      = 240\n\n[SDTC_VAR]\nvar      = network.autoclean_protected\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_0ISDISABLED | SGF_NETWORK_ONLY\ndef      = 36\nmin      = 0\nmax      = 240\n\n[SDTC_VAR]\nvar      = network.autoclean_novehicles\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_0ISDISABLED | SGF_NETWORK_ONLY\ndef      = 0\nmin      = 0\nmax      = 240\n\n[SDTC_VAR]\nvar      = network.max_companies\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 15\nmin      = 1\nmax      = MAX_COMPANIES\nproc     = UpdateClientConfigValues\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = network.max_clients\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 25\nmin      = 2\nmax      = MAX_CLIENTS\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = network.max_spectators\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 15\nmin      = 0\nmax      = MAX_CLIENTS\nproc     = UpdateClientConfigValues\ncat      = SC_BASIC\n\n[SDTC_VAR]\nvar      = network.restart_game_year\ntype     = SLE_INT32\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_0ISDISABLED | SGF_NETWORK_ONLY\ndef      = 0\nmin      = MIN_YEAR\nmax      = MAX_YEAR\ninterval = 1\n\n[SDTC_VAR]\nvar      = network.min_active_clients\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 0\nmin      = 0\nmax      = MAX_CLIENTS\n\n[SDTC_OMANY]\nvar      = network.server_lang\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = 0\nmax      = 35\nfull     = _server_langs\ncat      = SC_BASIC\n\n[SDTC_BOOL]\nvar      = network.reload_cfg\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_NETWORK_ONLY\ndef      = false\ncat      = SC_EXPERT\n\n[SDTC_STR]\nvar      = network.last_host\ntype     = SLE_STRB\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = \"\"\"\"\ncat      = SC_EXPERT\n\n[SDTC_VAR]\nvar      = network.last_port\ntype     = SLE_UINT16\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = 0\nmin      = 0\nmax      = UINT16_MAX\ncat      = SC_EXPERT\n\n[SDTC_BOOL]\nvar      = network.no_http_content_downloads\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\ndef      = false\ncat      = SC_EXPERT\n\n; Since the network code (CmdChangeSetting and friends) use the index in this array to decide\n; which setting the server is talking about all conditional compilation of this array must be at the\n; end. This isn't really the best solution, the settings the server can tell the client about should\n; either use a separate array or some other form of identifier.\n\n;\n; We might need to emulate a right mouse button on mac\n[SDTC_VAR]\nifdef    = __APPLE__\nvar      = gui.right_mouse_btn_emulation\ntype     = SLE_UINT8\nflags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC\nguiflags = SGF_MULTISTRING\ndef      = 0\nmin      = 0\nmax      = 2\nstr      = STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU\nstrhelp  = STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU_HELPTEXT\nstrval   = STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU_COMMAND\ncat      = SC_BASIC\n\n[SDT_BOOL]\nbase     = GameSettings\nvar      = vehicle.pay_for_repair\ndef      = true\nstr      = STR_CONFIG_SETTING_PAY_FOR_REPAIR_VEHICLE\nstrhelp  = STR_CONFIG_SETTING_PAY_FOR_REPAIR_VEHICLE_HELPTEXT\ncat      = SC_EXPERT\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_VEHICLE_REPAIR_COST)\npatxname = \"\"vehicle_repair_cost.vehicle.pay_for_repair\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = vehicle.repair_cost\ntype     = SLE_UINT8\ndef      = 100\nmin      = 1\nmax      = 255\ninterval = 1\nstr      = STR_CONFIG_SETTING_REPAIR_COST\nstrhelp  = STR_CONFIG_SETTING_REPAIR_COST_HELPTEXT\nstrval   = STR_JUST_INT\ncat      = SC_EXPERT\nextver   = SlXvFeatureTest(XSLFTO_AND, XSLFI_VEHICLE_REPAIR_COST)\npatxname = \"\"vehicle_repair_cost.vehicle.repair_cost\"\"\n\n[SDT_VAR]\nbase     = GameSettings\nvar      = debug.chicken_bits\ntype     = SLE_UINT32\nflags    = SLF_NOT_IN_CONFIG\nguiflags = SGF_NO_NEWGAME\ndef      = 0\nmin      = 0\nmax      = 0xFFFFFFFF\ncat      = SC_EXPERT\npatxname = \"\"debug.chicken_bits\"\"\n\n[SDT_END]\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/table/settings.ini b/src/table/settings.ini
--- a/src/table/settings.ini	(revision 4eb175746c01e644311535ded9c993e381c3e6cb)
+++ b/src/table/settings.ini	(date 1642741627573)
@@ -34,8 +34,6 @@
 static bool ChangeDynamicEngines(int32 p1);
 static bool StationCatchmentChanged(int32 p1);
 static bool InvalidateVehTimetableWindow(int32 p1);
-static bool UpdateTimeSettings(int32 p1);
-static bool ChangeTimeOverrideMode(int32 p1);
 static bool InvalidateCompanyLiveryWindow(int32 p1);
 static bool InvalidateNewGRFChangeWindows(int32 p1);
 static bool InvalidateIndustryViewWindow(int32 p1);
Index: src/train_cmd.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * This file is part of OpenTTD.\n * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.\n * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.\n */\n\n /** @file train_cmd.cpp Handling of trains. */\n\n#include \"stdafx.h\"\n#include \"error.h\"\n#include \"articulated_vehicles.h\"\n#include \"command_func.h\"\n#include \"pathfinder/npf/npf_func.h\"\n#include \"pathfinder/yapf/yapf.hpp\"\n#include \"news_func.h\"\n#include \"company_func.h\"\n#include \"newgrf_sound.h\"\n#include \"newgrf_text.h\"\n#include \"strings_func.h\"\n#include \"viewport_func.h\"\n#include \"vehicle_func.h\"\n#include \"sound_func.h\"\n#include \"ai/ai.hpp\"\n#include \"game/game.hpp\"\n#include \"newgrf_station.h\"\n#include \"effectvehicle_func.h\"\n#include \"network/network.h\"\n#include \"spritecache.h\"\n#include \"core/random_func.hpp\"\n#include \"company_base.h\"\n#include \"newgrf.h\"\n#include \"infrastructure_func.h\"\n#include \"order_backup.h\"\n#include \"zoom_func.h\"\n#include \"newgrf_debug.h\"\n#include \"framerate_type.h\"\n#include \"tracerestrict.h\"\n#include \"tbtr_template_vehicle_func.h\"\n#include \"autoreplace_func.h\"\n#include \"engine_func.h\"\n#include \"bridge_signal_map.h\"\n#include \"scope_info.h\"\n#include \"core/checksum_func.hpp\"\n\n#include \"table/strings.h\"\n#include \"table/train_cmd.h\"\n\n#include \"safeguards.h\"\n\nstatic Track ChooseTrainTrack(Train* v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool force_res, bool* p_got_reservation, bool mark_stuck);\nstatic bool TrainApproachingLineEnd(Train* v, bool signal, bool reverse);\nstatic bool TrainCheckIfLineEnds(Train* v, bool reverse = true);\nstatic bool TrainCanLeaveTile(const Train* v);\nstatic inline bool CheckCompatibleRail(const Train* v, TileIndex tile, DiagDirection enterdir);\nbool TrainController(Train* v, Vehicle* nomove, bool reverse = true); // Also used in vehicle_sl.cpp.\nstatic TileIndex TrainApproachingCrossingTile(const Train* v);\nstatic void CheckIfTrainNeedsService(Train* v);\nstatic void CheckNextTrainTile(Train* v);\nTileIndex VehiclePosTraceRestrictPreviousSignalCallback(const Train* v, const void*);\nstatic void TrainEnterStation(Train* v, StationID station);\n\nstatic const byte _vehicle_initial_x_fract[4] = { 10, 8, 4,  8 };\nstatic const byte _vehicle_initial_y_fract[4] = { 8, 4, 8, 10 };\n\ntemplate <>\nbool IsValidImageIndex<VEH_TRAIN>(uint8 image_index)\n{\n\treturn image_index < lengthof(_engine_sprite_base);\n}\n\n\n/**\n * Return the cargo weight multiplier to use for a rail vehicle\n * @param cargo Cargo type to get multiplier for\n * @return Cargo weight multiplier\n */\nbyte FreightWagonMult(CargoID cargo)\n{\n\tif (!CargoSpec::Get(cargo)->is_freight) return 1;\n\treturn _settings_game.vehicle.freight_trains;\n}\n\n/** Checks if lengths of all rail vehicles are valid. If not, shows an error message. */\nvoid CheckTrainsLengths()\n{\n\tbool first = true;\n\n\tfor (const Train* v : Train::Iterate()) {\n\t\tif (v->First() == v && !(v->vehstatus & VS_CRASHED) && !v->IsVirtual()) {\n\t\t\tfor (const Train* u = v, *w = v->Next(); w != nullptr; u = w, w = w->Next()) {\n\t\t\t\tif (u->track != TRACK_BIT_DEPOT) {\n\t\t\t\t\tif ((w->track != TRACK_BIT_DEPOT &&\n\t\t\t\t\t\tmax(abs(u->x_pos - w->x_pos), abs(u->y_pos - w->y_pos)) != u->CalcNextVehicleOffset()) ||\n\t\t\t\t\t\t(w->track == TRACK_BIT_DEPOT && TicksToLeaveDepot(u) <= 0)) {\n\t\t\t\t\t\tSetDParam(0, v->index);\n\t\t\t\t\t\tSetDParam(1, v->owner);\n\t\t\t\t\t\tShowErrorMessage(STR_BROKEN_VEHICLE_LENGTH, INVALID_STRING_ID, WL_CRITICAL);\n\n\t\t\t\t\t\tif (!_networking && first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\tDoCommandP(0, PM_PAUSED_ERROR, 1, CMD_PAUSE);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Break so we warn only once for each train. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Checks the breakdown flags (VehicleRailFlags 9-12) and sets the correct value in the first vehicle of the consist.\n * This function is generally only called to check if a flag may be cleared.\n * @param v the front engine\n * @param flags bitmask of the flags to check.\n */\nvoid CheckBreakdownFlags(Train* v)\n{\n\tassert(v->IsFrontEngine());\n\t/* clear the flags we're gonna check first, we'll set them again later (if applicable) */\n\tCLRBITS(v->flags, (1 << VRF_BREAKDOWN_BRAKING) | VRF_IS_BROKEN);\n\n\tfor (const Train* w = v; w != nullptr; w = w->Next()) {\n\t\tif (v->IsEngine() || w->IsMultiheaded()) {\n\t\t\tif (w->breakdown_ctr == 2) {\n\t\t\t\tSetBit(v->flags, VRF_BREAKDOWN_BRAKING);\n\t\t\t}\n\t\t\telse if (w->breakdown_ctr == 1) {\n\t\t\t\tswitch (w->breakdown_type) {\n\t\t\t\tcase BREAKDOWN_CRITICAL:\n\t\t\t\tcase BREAKDOWN_RV_CRASH:\n\t\t\t\tcase BREAKDOWN_EM_STOP:   SetBit(v->flags, VRF_BREAKDOWN_STOPPED); break;\n\t\t\t\tcase BREAKDOWN_LOW_SPEED: SetBit(v->flags, VRF_BREAKDOWN_SPEED);   break;\n\t\t\t\tcase BREAKDOWN_LOW_POWER: SetBit(v->flags, VRF_BREAKDOWN_POWER);   break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nuint16 GetTrainVehicleMaxSpeed(const Train* u, const RailVehicleInfo* rvi_u, const Train* front)\n{\n\tconst uint16 base_speed = GetVehicleProperty(u, PROP_TRAIN_SPEED, rvi_u->max_speed);\n\tuint16 speed = base_speed;\n\tif (HasBit(u->flags, VRF_NEED_REPAIR) && front->IsFrontEngine()) {\n\t\tfor (uint i = 0; i < u->critical_breakdown_count; i++) {\n\t\t\tspeed = min(speed - (speed / (front->tcache.cached_num_engines + 2)) + 1, speed);\n\t\t}\n\t}\n\n\t/* clamp speed to be no less than lower of 5mph and 1/8 of base speed */\n\tspeed = max<uint16>(speed, min<uint16>(5, (base_speed + 7) >> 3));\n\n\tif (HasBit(u->flags, VRF_HAS_HIT_RV) && front->IsFrontEngine()) {\n\t\tspeed = min(speed, 30);\n\t}\n\treturn speed;\n}\n\n/**\n * Recalculates the cached stuff of a train. Should be called each time a vehicle is added\n * to/removed from the chain, and when the game is loaded.\n * Note: this needs to be called too for 'wagon chains' (in the depot, without an engine)\n * @param allowed_changes Stuff that is allowed to change.\n */\nvoid Train::ConsistChanged(ConsistChangeFlags allowed_changes)\n{\n\tuint16 max_speed = UINT16_MAX;\n\tbool isSetMaxSpeed = false;\n\n\tassert(this->IsFrontEngine() || this->IsFreeWagon());\n\n\tconst RailVehicleInfo* rvi_v = RailVehInfo(this->engine_type);\n\tEngineID first_engine = this->IsFrontEngine() ? this->engine_type : INVALID_ENGINE;\n\tthis->gcache.cached_total_length = 0;\n\tthis->compatible_railtypes = RAILTYPES_NONE;\n\tthis->tcache.cached_num_engines = 0;\n\n\tbool train_can_tilt = true;\n\n\tfor (Train* u = this; u != nullptr; u = u->Next()) {\n\t\tconst RailVehicleInfo* rvi_u = RailVehInfo(u->engine_type);\n\n\t\t/* Check the this->first cache. */\n\t\tassert_msg(u->First() == this, \"u: %s, this: %s\",\n\t\t\tscope_dumper().VehicleInfo(u), scope_dumper().VehicleInfo(this));\n\n\t\t/* update the 'first engine' */\n\t\tu->gcache.first_engine = this == u ? INVALID_ENGINE : first_engine;\n\t\tu->railtype = rvi_u->railtype;\n\n\t\tif (u->IsEngine()) first_engine = u->engine_type;\n\n\t\t/* Set user defined data to its default value */\n\t\tu->tcache.user_def_data = rvi_u->user_def_data;\n\t\tthis->InvalidateNewGRFCache();\n\t\tu->InvalidateNewGRFCache();\n\t}\n\n\tfor (Train* u = this; u != nullptr; u = u->Next()) {\n\t\t/* Update user defined data (must be done before other properties) */\n\t\tu->tcache.user_def_data = GetVehicleProperty(u, PROP_TRAIN_USER_DATA, u->tcache.user_def_data);\n\t\tthis->InvalidateNewGRFCache();\n\t\tu->InvalidateNewGRFCache();\n\n\t\tif (!u->IsArticulatedPart()) {\n\t\t\tif (u->IsEngine() || u->IsMultiheaded()) {\n\t\t\t\tthis->tcache.cached_num_engines++;\n\t\t\t}\n\t\t}\n\t}\n\n\tVehicle* last_vis_effect = this;\n\tfor (Train* u = this; u != nullptr; u = u->Next()) {\n\t\tconst Engine* e_u = u->GetEngine();\n\t\tconst RailVehicleInfo* rvi_u = &e_u->u.rail;\n\n\t\tif (!HasBit(e_u->info.misc_flags, EF_RAIL_TILTS)) train_can_tilt = false;\n\n\t\t/* Cache wagon override sprite group. nullptr is returned if there is none */\n\t\tu->tcache.cached_override = GetWagonOverrideSpriteSet(u->engine_type, u->cargo_type, u->gcache.first_engine);\n\n\t\t/* Reset colour map */\n\t\tu->colourmap = PAL_NONE;\n\n\t\t/* Update powered-wagon-status and visual effect */\n\t\tu->UpdateVisualEffect(true);\n\t\tClrBit(u->vcache.cached_veh_flags, VCF_LAST_VISUAL_EFFECT);\n\t\tif (!(HasBit(u->vcache.cached_vis_effect, VE_ADVANCED_EFFECT) && GB(u->vcache.cached_vis_effect, 0, VE_ADVANCED_EFFECT) == VESM_NONE)) last_vis_effect = u;\n\n\t\tif (rvi_v->pow_wag_power != 0 && rvi_u->railveh_type == RAILVEH_WAGON &&\n\t\t\tUsesWagonOverride(u) && !HasBit(u->vcache.cached_vis_effect, VE_DISABLE_WAGON_POWER)) {\n\t\t\t/* wagon is powered */\n\t\t\tSetBit(u->flags, VRF_POWEREDWAGON); // cache 'powered' status\n\t\t}\n\t\telse {\n\t\t\tClrBit(u->flags, VRF_POWEREDWAGON);\n\t\t}\n\n\t\tif (!u->IsArticulatedPart()) {\n\t\t\t/* Do not count powered wagons for the compatible railtypes, as wagons always\n\t\t\t   have railtype normal */\n\t\t\tif (rvi_u->power > 0) {\n\t\t\t\tthis->compatible_railtypes |= GetRailTypeInfo(u->railtype)->powered_railtypes;\n\t\t\t}\n\n\t\t\t/* Some electric engines can be allowed to run on normal rail. It happens to all\n\t\t\t * existing electric engines when elrails are disabled and then re-enabled */\n\t\t\tif (HasBit(u->flags, VRF_EL_ENGINE_ALLOWED_NORMAL_RAIL)) {\n\t\t\t\tu->railtype = RAILTYPE_RAIL;\n\t\t\t\tu->compatible_railtypes |= RAILTYPES_RAIL;\n\t\t\t}\n\n\t\t\t//u->compatible_railtypes |= RAILTYPES_RAIL;\n\n\t\t\t/* max speed is the minimum of the speed limits of all vehicles in the consist */\n\t\t\tif ((rvi_u->railveh_type != RAILVEH_WAGON || _settings_game.vehicle.wagon_speed_limits) && !UsesWagonOverride(u)) {\n\t\t\t\tuint16 speed = GetTrainVehicleMaxSpeed(u, rvi_u, this);\n\t\t\t\tif (_settings_game.vehicle.max_locomotive_speed_limits) {\n\t\t\t\t\tif (speed != 0 && HasPowerOnRail(u->railtype, GetRailType(tile))) {\n\t\t\t\t\t\tuint16 toCompare = isSetMaxSpeed ? max_speed : 0;\n\t\t\t\t\t\tmax_speed = rvi_u->railveh_type != RAILVEH_WAGON ? max(speed, toCompare) : min(speed, max_speed);\n\t\t\t\t\t\tisSetMaxSpeed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (speed != 0) {\n\t\t\t\t\tmax_speed = min(speed, max_speed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tuint16 new_cap = e_u->DetermineCapacity(u);\n\t\tif (allowed_changes & CCF_CAPACITY) {\n\t\t\t/* Update vehicle capacity. */\n\t\t\tif (u->cargo_cap > new_cap) u->cargo.Truncate(new_cap);\n\t\t\tu->refit_cap = min(new_cap, u->refit_cap);\n\t\t\tu->cargo_cap = new_cap;\n\t\t}\n\t\telse {\n\t\t\t/* Verify capacity hasn't changed. */\n\t\t\tif (new_cap != u->cargo_cap) ShowNewGrfVehicleError(u->engine_type, STR_NEWGRF_BROKEN, STR_NEWGRF_BROKEN_CAPACITY, GBUG_VEH_CAPACITY, true);\n\t\t}\n\t\tu->vcache.cached_cargo_age_period = GetVehicleProperty(u, PROP_TRAIN_CARGO_AGE_PERIOD, e_u->info.cargo_age_period);\n\n\t\t/* check the vehicle length (callback) */\n\t\tuint16 veh_len = CALLBACK_FAILED;\n\t\tif (e_u->GetGRF() != nullptr && e_u->GetGRF()->grf_version >= 8) {\n\t\t\t/* Use callback 36 */\n\t\t\tveh_len = GetVehicleProperty(u, PROP_TRAIN_SHORTEN_FACTOR, CALLBACK_FAILED);\n\n\t\t\tif (veh_len != CALLBACK_FAILED && veh_len >= VEHICLE_LENGTH) {\n\t\t\t\tErrorUnknownCallbackResult(e_u->GetGRFID(), CBID_VEHICLE_LENGTH, veh_len);\n\t\t\t}\n\t\t}\n\t\telse if (HasBit(e_u->info.callback_mask, CBM_VEHICLE_LENGTH)) {\n\t\t\t/* Use callback 11 */\n\t\t\tveh_len = GetVehicleCallback(CBID_VEHICLE_LENGTH, 0, 0, u->engine_type, u);\n\t\t}\n\t\tif (veh_len == CALLBACK_FAILED) veh_len = rvi_u->shorten_factor;\n\t\tveh_len = VEHICLE_LENGTH - Clamp(veh_len, 0, VEHICLE_LENGTH - 1);\n\n\t\tif (allowed_changes & CCF_LENGTH) {\n\t\t\t/* Update vehicle length. */\n\t\t\tu->gcache.cached_veh_length = veh_len;\n\t\t}\n\t\telse {\n\t\t\t/* Verify length hasn't changed. */\n\t\t\tif (veh_len != u->gcache.cached_veh_length) VehicleLengthChanged(u);\n\t\t}\n\n\t\tthis->gcache.cached_total_length += u->gcache.cached_veh_length;\n\t\tthis->InvalidateNewGRFCache();\n\t\tu->InvalidateNewGRFCache();\n\t}\n\tSetBit(last_vis_effect->vcache.cached_veh_flags, VCF_LAST_VISUAL_EFFECT);\n\n\t/* store consist weight/max speed in cache */\n\tthis->vcache.cached_max_speed = max_speed;\n\tthis->tcache.cached_tilt = train_can_tilt;\n\tthis->tcache.cached_max_curve_speed = this->GetCurveSpeedLimit();\n\n\t/* recalculate cached weights and power too (we do this *after* the rest, so it is known which wagons are powered and need extra weight added) */\n\tthis->CargoChanged();\n\n\tif (this->IsFrontEngine()) {\n\t\tthis->UpdateAcceleration();\n\t\tif (!HasBit(this->subtype, GVSF_VIRTUAL)) SetWindowDirty(WC_VEHICLE_DETAILS, this->index);\n\t\tInvalidateWindowData(WC_VEHICLE_REFIT, this->index, VIWD_CONSIST_CHANGED);\n\t\tInvalidateWindowData(WC_VEHICLE_ORDERS, this->index, VIWD_CONSIST_CHANGED);\n\t\tInvalidateNewGRFInspectWindow(GSF_TRAINS, this->index);\n\t}\n}\n\n/**\n * Get the fraction of the vehicle's current tile which is in front of it.\n * This is equal to how many more steps it could travel without having to stop/reverse if it was an end of line.\n *\n * See also wrapper without x_pos, y_pos in train.h\n *\n * @param v              the vehicle to use (not required to be the front)\n * @param x_pos          vehicle x position\n * @param y_pos          vehicle y position\n * @return the fraction of the current tile in front of the vehicle\n */\nint GetTileMarginInFrontOfTrain(const Train* v, int x_pos, int y_pos)\n{\n\tif (IsDiagonalDirection(v->direction)) {\n\t\tDiagDirection dir = DirToDiagDir(v->direction);\n\t\tint offset = ((DiagDirToAxis(dir) == AXIS_X) ? x_pos : y_pos) & 0xF;\n\t\treturn ((dir == DIAGDIR_SE || dir == DIAGDIR_SW) ? TILE_SIZE - 1 - offset : offset) - ((v->gcache.cached_veh_length + 1) / 2);\n\t}\n\telse {\n\t\t/* Calc position within the current tile */\n\t\tuint x = x_pos & 0xF;\n\t\tuint y = y_pos & 0xF;\n\n\t\t/* for non-diagonal directions, x will be 1, 3, 5, ..., 15 */\n\t\tswitch (v->direction) {\n\t\tcase DIR_N: x = ~x + ~y + 25; break;\n\t\tcase DIR_E: x = ~x + y + 9;   break;\n\t\tcase DIR_S: x = x + y - 7;    break;\n\t\tcase DIR_W: x = ~y + x + 9;   break;\n\t\tdefault: break;\n\t\t}\n\t\tx >>= 1; // x is now in range 0 ... 7\n\t\treturn (TILE_SIZE / 2) - 1 - x - (v->gcache.cached_veh_length + 1) / 2;\n\t}\n}\n\n/**\n * Get the stop location of (the center) of the front vehicle of a train at\n * a platform of a station.\n *\n * See also wrapper without x_pos, y_pos in train.h\n *\n * @param station_id     the ID of the station where we're stopping\n * @param tile           the tile where the vehicle currently is\n * @param v              the vehicle to get the stop location of\n * @param station_ahead  'return' the amount of 1/16th tiles in front of the train\n * @param station_length 'return' the station length in 1/16th tiles\n * @param x_pos          vehicle x position\n * @param y_pos          vehicle y position\n * @return the location, calculated from the begin of the station to stop at.\n */\nint GetTrainStopLocation(StationID station_id, TileIndex tile, Train* v, int* station_ahead, int* station_length, int x_pos, int y_pos)\n{\n\tTrain* front = v->First();\n\tif (IsRailWaypoint(tile)) {\n\t\t*station_ahead = *station_length = TILE_SIZE;\n\t}\n\telse {\n\t\tconst Station* st = Station::Get(station_id);\n\t\t*station_ahead = st->GetPlatformLength(tile, DirToDiagDir(v->direction)) * TILE_SIZE;\n\t\t*station_length = st->GetPlatformLength(tile) * TILE_SIZE;\n\t}\n\n\t/* Default to the middle of the station for stations stops that are not in\n\t * the order list like intermediate stations when non-stop is disabled */\n\tOrderStopLocation osl = OSL_PLATFORM_MIDDLE;\n\tif (front->current_order.IsType(OT_GOTO_STATION) && front->current_order.GetDestination() == station_id) {\n\t\tosl = front->current_order.GetStopLocation();\n\t}\n\telse if (front->current_order.IsType(OT_LOADING_ADVANCE) && front->current_order.GetDestination() == station_id) {\n\t\tosl = OSL_PLATFORM_THROUGH;\n\t}\n\telse if (front->current_order.IsType(OT_GOTO_WAYPOINT) && front->current_order.GetDestination() == station_id) {\n\t\tosl = OSL_PLATFORM_FAR_END;\n\t}\n\tint overhang = front->gcache.cached_total_length - *station_length;\n\tint adjust = 0;\n\tif (osl == OSL_PLATFORM_THROUGH && overhang > 0) {\n\t\tfor (Train* u = front; u != nullptr; u = u->Next()) {\n\t\t\t/* Passengers may not be through-loaded */\n\t\t\tif (u->cargo_cap > 0 && IsCargoInClass(u->cargo_type, CC_PASSENGERS)) {\n\t\t\t\tosl = OSL_PLATFORM_FAR_END;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (osl == OSL_PLATFORM_THROUGH && overhang > 0) {\n\t\t/* The train is longer than the station, and we can run through the station to load/unload */\n\t\tfor (Train* u = v; u != nullptr; u = u->Next()) {\n\t\t\tif (overhang > 0 && !HasBit(u->flags, VRF_BEYOND_PLATFORM_END) && !u->IsArticulatedPart()) {\n\t\t\t\tbool skip = true;\n\t\t\t\tfor (const Train* part = u; part != nullptr; part = part->HasArticulatedPart() ? part->GetNextArticulatedPart() : nullptr) {\n\t\t\t\t\tif (part->cargo_cap != 0) {\n\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (skip) {\n\t\t\t\t\tfor (Train* part = u; part != nullptr; part = part->HasArticulatedPart() ? part->GetNextArticulatedPart() : nullptr) {\n\t\t\t\t\t\tSetBit(part->flags, VRF_BEYOND_PLATFORM_END);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (HasBit(u->flags, VRF_BEYOND_PLATFORM_END)) {\n\t\t\t\toverhang -= u->gcache.cached_veh_length;\n\t\t\t\tadjust += u->gcache.cached_veh_length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (Train* u = front; u != v; u = u->Next()) overhang -= u->gcache.cached_veh_length; // only advance until rear of train is in platform\n\t\tif (overhang < 0) adjust += overhang;\n\t}\n\telse if (overhang >= 0) {\n\t\t/* The train is longer than the station, make it stop at the far end of the platform */\n\t\tosl = OSL_PLATFORM_FAR_END;\n\t}\n\n\t/* The stop location of the FRONT! of the train */\n\tint stop;\n\tswitch (osl) {\n\tdefault: NOT_REACHED();\n\n\tcase OSL_PLATFORM_NEAR_END:\n\t\tstop = front->gcache.cached_total_length;\n\t\tbreak;\n\n\tcase OSL_PLATFORM_MIDDLE:\n\t\tstop = *station_length - (*station_length - front->gcache.cached_total_length) / 2;\n\t\tbreak;\n\n\tcase OSL_PLATFORM_FAR_END:\n\tcase OSL_PLATFORM_THROUGH:\n\t\tstop = *station_length;\n\t\tbreak;\n\t}\n\n\t/* Subtract half the front vehicle length of the train so we get the real\n\t * stop location of the train. */\n\tint result = stop - ((v->gcache.cached_veh_length + 1) / 2) + adjust;\n\n\tif (osl == OSL_PLATFORM_THROUGH && v != front) {\n\t\t/* Check front of train for obstructions */\n\n\t\tif (TrainCanLeaveTile(front)) {\n\t\t\t/* Determine the non-diagonal direction in which we will exit this tile */\n\t\t\tDiagDirection dir = VehicleExitDir(front->direction, front->track);\n\t\t\t/* Calculate next tile */\n\t\t\tTileIndex tile = front->tile + TileOffsByDiagDir(dir);\n\n\t\t\t/* Determine the track status on the next tile */\n\t\t\tTrackStatus ts = GetTileTrackStatus(tile, TRANSPORT_RAIL, 0, ReverseDiagDir(dir));\n\t\t\tTrackdirBits trackdirbits = TrackStatusToTrackdirBits(ts) & DiagdirReachesTrackdirs(dir);\n\n\t\t\t/* mask unreachable track bits if we are forbidden to do 90deg turns */\n\t\t\tTrackBits bits = TrackdirBitsToTrackBits(trackdirbits);\n\t\t\tif (_settings_game.pf.forbid_90_deg) {\n\t\t\t\tbits &= ~TrackCrossesTracks(FindFirstTrack(front->track));\n\t\t\t}\n\n\t\t\tif (bits == TRACK_BIT_NONE || !CheckCompatibleRail(front, tile, dir) || IsRailDepotTile(tile) ||\n\t\t\t\t(KillFirstBit(trackdirbits) == TRACKDIR_BIT_NONE && HasOnewaySignalBlockingTrackdir(tile, FindFirstTrackdir(trackdirbits)))) {\n\t\t\t\t/* next tile is an effective dead end */\n\t\t\t\tint current_platform_remaining = *station_ahead - TILE_SIZE + GetTileMarginInFrontOfTrain(v);\n\t\t\t\tint limit = GetTileMarginInFrontOfTrain(front) + (*station_length - current_platform_remaining) - ((v->gcache.cached_veh_length + 1) / 2);\n\t\t\t\tresult = min(limit, result);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n\n/**\n * Computes train speed limit caused by curves\n * @return imposed speed limit\n */\nint Train::GetCurveSpeedLimit() const\n{\n\tassert(this->First() == this);\n\n\tstatic const int absolute_max_speed = UINT16_MAX;\n\tint max_speed = absolute_max_speed;\n\n\tif (_settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) return max_speed;\n\n\tint curvecount[2] = { 0, 0 };\n\n\t/* first find the curve speed limit */\n\tint numcurve = 0;\n\tint sum = 0;\n\tint pos = 0;\n\tint lastpos = -1;\n\tfor (const Vehicle* u = this; u->Next() != nullptr; u = u->Next(), pos++) {\n\t\tDirection this_dir = u->direction;\n\t\tDirection next_dir = u->Next()->direction;\n\n\t\tDirDiff dirdiff = DirDifference(this_dir, next_dir);\n\t\tif (dirdiff == DIRDIFF_SAME) continue;\n\n\t\tif (dirdiff == DIRDIFF_45LEFT) curvecount[0]++;\n\t\tif (dirdiff == DIRDIFF_45RIGHT) curvecount[1]++;\n\t\tif (dirdiff == DIRDIFF_45LEFT || dirdiff == DIRDIFF_45RIGHT) {\n\t\t\tif (lastpos != -1) {\n\t\t\t\tnumcurve++;\n\t\t\t\tsum += pos - lastpos;\n\t\t\t\tif (pos - lastpos == 1 && max_speed > 88) {\n\t\t\t\t\tmax_speed = 88;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastpos = pos;\n\t\t}\n\n\t\t/* if we have a 90 degree turn, fix the speed limit to 60 */\n\t\tif (dirdiff == DIRDIFF_90LEFT || dirdiff == DIRDIFF_90RIGHT) {\n\t\t\tmax_speed = 61;\n\t\t}\n\t}\n\n\tif (numcurve > 0 && max_speed > 88) {\n\t\tif (curvecount[0] == 1 && curvecount[1] == 1) {\n\t\t\tmax_speed = absolute_max_speed;\n\t\t}\n\t\telse {\n\t\t\tsum /= numcurve;\n\t\t\tmax_speed = 232 - (13 - Clamp(sum, 1, 12)) * (13 - Clamp(sum, 1, 12));\n\t\t}\n\t}\n\n\tif (max_speed != absolute_max_speed) {\n\t\t/* Apply the engine's rail type curve speed advantage, if it slowed by curves */\n\t\tconst RailtypeInfo* rti = GetRailTypeInfo(this->railtype);\n\t\tmax_speed += (max_speed / 2) * rti->curve_speed;\n\n\t\tif (this->tcache.cached_tilt) {\n\t\t\t/* Apply max_speed bonus of 20% for a tilting train */\n\t\t\tmax_speed += max_speed / 5;\n\t\t}\n\t}\n\n\treturn max_speed;\n}\n\n/**\n * Calculates the maximum speed of the vehicle under its current conditions.\n * @return Maximum speed of the vehicle.\n */\nint Train::GetCurrentMaxSpeed() const\n{\n\tint max_speed = _settings_game.vehicle.train_acceleration_model == AM_ORIGINAL ?\n\t\tthis->gcache.cached_max_track_speed :\n\t\tthis->tcache.cached_max_curve_speed;\n\n\tif (_settings_game.vehicle.train_acceleration_model == AM_REALISTIC) {\n\t\tTrain* v_platform = const_cast<Train*>(this->GetStationLoadingVehicle());\n\t\tTileIndex platform_tile = v_platform->tile;\n\t\tif (HasStationTileRail(platform_tile)) {\n\t\t\tStationID sid = GetStationIndex(platform_tile);\n\t\t\tif (this->current_order.ShouldStopAtStation(this, sid, IsRailWaypoint(platform_tile))) {\n\t\t\t\tint station_ahead;\n\t\t\t\tint station_length;\n\t\t\t\tint stop_at = GetTrainStopLocation(sid, platform_tile, v_platform, &station_ahead, &station_length);\n\n\t\t\t\t/* The distance to go is whatever is still ahead of the train minus the\n\t\t\t\t * distance from the train's stop location to the end of the platform */\n\t\t\t\tint distance_to_go = station_ahead / TILE_SIZE - (station_length - stop_at) / TILE_SIZE;\n\n\t\t\t\tif (distance_to_go > 0) {\n\t\t\t\t\tint st_max_speed = 120;\n\n\t\t\t\t\tint delta_v = this->cur_speed / (distance_to_go + 1);\n\t\t\t\t\tif (max_speed > (this->cur_speed - delta_v)) {\n\t\t\t\t\t\tst_max_speed = this->cur_speed - (delta_v / 10);\n\t\t\t\t\t}\n\n\t\t\t\t\tst_max_speed = max(st_max_speed, 25 * distance_to_go);\n\t\t\t\t\tmax_speed = min(max_speed, st_max_speed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (HasBit(this->flags, VRF_CONSIST_SPEED_REDUCTION)) {\n\t\tClrBit(const_cast<Train*>(this)->flags, VRF_CONSIST_SPEED_REDUCTION);\n\t\tfor (const Train* u = this; u != nullptr; u = u->Next()) {\n\t\t\tif (u->track == TRACK_BIT_DEPOT) {\n\t\t\t\tSetBit(const_cast<Train*>(this)->flags, VRF_CONSIST_SPEED_REDUCTION);\n\t\t\t\tif (_settings_game.vehicle.train_acceleration_model == AM_REALISTIC) {\n\t\t\t\t\tmax_speed = min(max_speed, 61);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Vehicle is on the middle part of a bridge. */\n\t\t\tif (u->track & TRACK_BIT_WORMHOLE && !(u->vehstatus & VS_HIDDEN)) {\n\t\t\t\tSetBit(const_cast<Train*>(this)->flags, VRF_CONSIST_SPEED_REDUCTION);\n\t\t\t\tmax_speed = min(max_speed, GetBridgeSpec(GetBridgeType(u->tile))->speed);\n\t\t\t}\n\t\t}\n\t}\n\n\tmax_speed = min(max_speed, this->current_order.GetMaxSpeed());\n\tif (HasBit(this->flags, VRF_BREAKDOWN_SPEED)) {\n\t\tmax_speed = min(max_speed, this->GetBreakdownSpeed());\n\t}\n\tif (this->speed_restriction != 0) {\n\t\tmax_speed = min(max_speed, this->speed_restriction);\n\t}\n\n\tif (this->current_order.IsType(OT_LOADING_ADVANCE)) max_speed = min(max_speed, 15);\n\n\treturn min(max_speed, this->gcache.cached_max_track_speed);\n}\n\n/** Update acceleration of the train from the cached power and weight. */\nvoid Train::UpdateAcceleration()\n{\n\tassert(this->IsFrontEngine() || this->IsFreeWagon());\n\n\tuint power = this->gcache.cached_power;\n\tuint weight = this->gcache.cached_weight;\n\tassert(weight != 0);\n\tthis->acceleration = Clamp(power / weight * 4, 1, 255);\n\n\tif (_settings_game.vehicle.improved_breakdowns) {\n\t\tif (_settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) {\n\t\t\tthis->breakdown_chance_factor = max(128 * 3 / (this->tcache.cached_num_engines + 2), 5);\n\t\t}\n\t}\n}\n\n/**\n * Get the width of a train vehicle image in the GUI.\n * @param offset Additional offset for positioning the sprite; set to nullptr if not needed\n * @return Width in pixels\n */\nint Train::GetDisplayImageWidth(Point* offset) const\n{\n\tint reference_width = TRAININFO_DEFAULT_VEHICLE_WIDTH;\n\tint vehicle_pitch = 0;\n\n\tconst Engine* e = this->GetEngine();\n\tif (e->GetGRF() != nullptr && is_custom_sprite(e->u.rail.image_index)) {\n\t\treference_width = e->GetGRF()->traininfo_vehicle_width;\n\t\tvehicle_pitch = e->GetGRF()->traininfo_vehicle_pitch;\n\t}\n\n\tif (offset != nullptr) {\n\t\toffset->x = ScaleGUITrad(reference_width) / 2;\n\t\toffset->y = ScaleGUITrad(vehicle_pitch);\n\t}\n\treturn ScaleGUITrad(this->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH);\n}\n\nstatic SpriteID GetDefaultTrainSprite(uint8 spritenum, Direction direction)\n{\n\tassert(IsValidImageIndex<VEH_TRAIN>(spritenum));\n\treturn ((direction + _engine_sprite_add[spritenum]) & _engine_sprite_and[spritenum]) + _engine_sprite_base[spritenum];\n}\n\n/**\n * Get the sprite to display the train.\n * @param direction Direction of view/travel.\n * @param image_type Visualisation context.\n * @return Sprite to display.\n */\nvoid Train::GetImage(Direction direction, EngineImageType image_type, VehicleSpriteSeq* result) const\n{\n\tuint8 spritenum = this->spritenum;\n\n\tif (HasBit(this->flags, VRF_REVERSE_DIRECTION)) direction = ReverseDir(direction);\n\n\tif (is_custom_sprite(spritenum)) {\n\t\tGetCustomVehicleSprite(this, (Direction)(direction + 4 * IS_CUSTOM_SECONDHEAD_SPRITE(spritenum)), image_type, result);\n\t\tif (result->IsValid()) return;\n\n\t\tspritenum = this->GetEngine()->original_image_index;\n\t}\n\n\tassert(IsValidImageIndex<VEH_TRAIN>(spritenum));\n\tSpriteID sprite = GetDefaultTrainSprite(spritenum, direction);\n\n\tif (this->cargo.StoredCount() >= this->cargo_cap / 2U) sprite += _wagon_full_adder[spritenum];\n\n\tresult->Set(sprite);\n}\n\nstatic void GetRailIcon(EngineID engine, bool rear_head, int& y, EngineImageType image_type, VehicleSpriteSeq* result)\n{\n\tconst Engine* e = Engine::Get(engine);\n\tDirection dir = rear_head ? DIR_E : DIR_W;\n\tuint8 spritenum = e->u.rail.image_index;\n\n\tif (is_custom_sprite(spritenum)) {\n\t\tGetCustomVehicleIcon(engine, dir, image_type, result);\n\t\tif (result->IsValid()) {\n\t\t\tif (e->GetGRF() != nullptr) {\n\t\t\t\ty += ScaleGUITrad(e->GetGRF()->traininfo_vehicle_pitch);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tspritenum = Engine::Get(engine)->original_image_index;\n\t}\n\n\tif (rear_head) spritenum++;\n\n\tresult->Set(GetDefaultTrainSprite(spritenum, DIR_W));\n}\n\nvoid DrawTrainEngine(int left, int right, int preferred_x, int y, EngineID engine, PaletteID pal, EngineImageType image_type)\n{\n\tif (RailVehInfo(engine)->railveh_type == RAILVEH_MULTIHEAD) {\n\t\tint yf = y;\n\t\tint yr = y;\n\n\t\tVehicleSpriteSeq seqf, seqr;\n\t\tGetRailIcon(engine, false, yf, image_type, &seqf);\n\t\tGetRailIcon(engine, true, yr, image_type, &seqr);\n\n\t\tRect16 rectf = seqf.GetBounds();\n\t\tRect16 rectr = seqr.GetBounds();\n\n\t\tpreferred_x = SoftClamp(preferred_x,\n\t\t\tleft - UnScaleGUI(rectf.left) + ScaleGUITrad(14),\n\t\t\tright - UnScaleGUI(rectr.right) - ScaleGUITrad(15));\n\n\t\tseqf.Draw(preferred_x - ScaleGUITrad(14), yf, pal, pal == PALETTE_CRASH);\n\t\tseqr.Draw(preferred_x + ScaleGUITrad(15), yr, pal, pal == PALETTE_CRASH);\n\t}\n\telse {\n\t\tVehicleSpriteSeq seq;\n\t\tGetRailIcon(engine, false, y, image_type, &seq);\n\n\t\tRect16 rect = seq.GetBounds();\n\t\tpreferred_x = Clamp(preferred_x,\n\t\t\tleft - UnScaleGUI(rect.left),\n\t\t\tright - UnScaleGUI(rect.right));\n\n\t\tseq.Draw(preferred_x, y, pal, pal == PALETTE_CRASH);\n\t}\n}\n\n/**\n * Get the size of the sprite of a train sprite heading west, or both heads (used for lists).\n * @param engine The engine to get the sprite from.\n * @param[out] width The width of the sprite.\n * @param[out] height The height of the sprite.\n * @param[out] xoffs Number of pixels to shift the sprite to the right.\n * @param[out] yoffs Number of pixels to shift the sprite downwards.\n * @param image_type Context the sprite is used in.\n */\nvoid GetTrainSpriteSize(EngineID engine, uint& width, uint& height, int& xoffs, int& yoffs, EngineImageType image_type)\n{\n\tint y = 0;\n\n\tVehicleSpriteSeq seq;\n\tGetRailIcon(engine, false, y, image_type, &seq);\n\n\tRect16 rect = seq.GetBounds();\n\n\twidth = UnScaleGUI(rect.right - rect.left + 1);\n\theight = UnScaleGUI(rect.bottom - rect.top + 1);\n\txoffs = UnScaleGUI(rect.left);\n\tyoffs = UnScaleGUI(rect.top);\n\n\tif (RailVehInfo(engine)->railveh_type == RAILVEH_MULTIHEAD) {\n\t\tGetRailIcon(engine, true, y, image_type, &seq);\n\t\trect = seq.GetBounds();\n\n\t\t/* Calculate values relative to an imaginary center between the two sprites. */\n\t\twidth = ScaleGUITrad(TRAININFO_DEFAULT_VEHICLE_WIDTH) + UnScaleGUI(rect.right) - xoffs;\n\t\theight = max<uint>(height, UnScaleGUI(rect.bottom - rect.top + 1));\n\t\txoffs = xoffs - ScaleGUITrad(TRAININFO_DEFAULT_VEHICLE_WIDTH) / 2;\n\t\tyoffs = min(yoffs, UnScaleGUI(rect.top));\n\t}\n}\n\n/**\n * Build a railroad wagon.\n * @param tile     tile of the depot where rail-vehicle is built.\n * @param flags    type of operation.\n * @param e        the engine to build.\n * @param[out] ret the vehicle that has been built.\n * @return the cost of this operation or an error.\n */\nstatic CommandCost CmdBuildRailWagon(TileIndex tile, DoCommandFlag flags, const Engine* e, Vehicle** ret)\n{\n\tconst RailVehicleInfo* rvi = &e->u.rail;\n\n\t/* Check that the wagon can drive on the track in question */\n\tif (!IsCompatibleRail(rvi->railtype, GetRailType(tile))) return CMD_ERROR;\n\n\tif (flags & DC_EXEC) {\n\t\tTrain* v = new Train();\n\t\t*ret = v;\n\t\tv->spritenum = rvi->image_index;\n\n\t\tv->engine_type = e->index;\n\t\tv->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback\n\n\t\tDiagDirection dir = GetRailDepotDirection(tile);\n\n\t\tv->direction = DiagDirToDir(dir);\n\t\tv->tile = tile;\n\n\t\tint x = TileX(tile) * TILE_SIZE | _vehicle_initial_x_fract[dir];\n\t\tint y = TileY(tile) * TILE_SIZE | _vehicle_initial_y_fract[dir];\n\n\t\tv->x_pos = x;\n\t\tv->y_pos = y;\n\t\tv->z_pos = GetSlopePixelZ(x, y);\n\t\tv->owner = _current_company;\n\t\tv->track = TRACK_BIT_DEPOT;\n\t\tv->vehstatus = VS_HIDDEN | VS_DEFPAL;\n\t\tv->reverse_distance = 0;\n\t\tv->speed_restriction = 0;\n\n\t\tv->SetWagon();\n\n\t\tv->SetFreeWagon();\n\t\tInvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);\n\n\t\tv->cargo_type = e->GetDefaultCargoType();\n\t\tv->cargo_cap = rvi->capacity;\n\t\tv->refit_cap = 0;\n\n\t\tv->railtype = rvi->railtype;\n\n\t\tv->date_of_last_service = _date;\n\t\tv->build_year = _cur_year;\n\t\tv->sprite_seq.Set(SPR_IMG_QUERY);\n\t\tv->random_bits = VehicleRandomBits();\n\n\t\tv->group_id = DEFAULT_GROUP;\n\n\t\tAddArticulatedParts(v);\n\n\t\t_new_vehicle_id = v->index;\n\n\t\tv->UpdatePosition();\n\t\tv->First()->ConsistChanged(CCF_ARRANGE);\n\t\tUpdateTrainGroupID(v->First());\n\n\t\tCheckConsistencyOfArticulatedVehicle(v);\n\n\t\t/* Try to connect the vehicle to one of free chains of wagons. */\n\t\tfor (Train* w : Train::Iterate()) {\n\t\t\tif (w->tile == tile &&              ///< Same depot\n\t\t\t\tw->IsFreeWagon() &&             ///< A free wagon chain\n\t\t\t\tw->engine_type == e->index &&   ///< Same type\n\t\t\t\tw->First() != v &&              ///< Don't connect to ourself\n\t\t\t\t!(w->vehstatus & VS_CRASHED) && ///< Not crashed/flooded\n\t\t\t\tw->owner == v->owner &&         ///< Same owner\n\t\t\t\t!w->IsVirtual()) {              ///< Not virtual\n\t\t\t\tDoCommand(0, v->index | 1 << 20, w->Last()->index, DC_EXEC, CMD_MOVE_RAIL_VEHICLE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tInvalidateVehicleTickCaches();\n\t}\n\n\treturn CommandCost();\n}\n\n/** Move all free vehicles in the depot to the train */\nstatic void NormalizeTrainVehInDepot(const Train* u)\n{\n\tfor (const Train* v : Train::Iterate()) {\n\t\tif (v->IsFreeWagon() && v->tile == u->tile &&\n\t\t\tv->track == TRACK_BIT_DEPOT &&\n\t\t\tv->owner == u->owner &&\n\t\t\t!v->IsVirtual()) {\n\t\t\tif (DoCommand(0, v->index | 1 << 20, u->index, DC_EXEC,\n\t\t\t\tCMD_MOVE_RAIL_VEHICLE).Failed())\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void AddRearEngineToMultiheadedTrain(Train* v)\n{\n\tTrain* u = new Train();\n\tv->value >>= 1;\n\tu->value = v->value;\n\tu->direction = v->direction;\n\tu->owner = v->owner;\n\tu->tile = v->tile;\n\tu->x_pos = v->x_pos;\n\tu->y_pos = v->y_pos;\n\tu->z_pos = v->z_pos;\n\tu->track = TRACK_BIT_DEPOT;\n\tu->vehstatus = v->vehstatus & ~VS_STOPPED;\n\tu->spritenum = v->spritenum + 1;\n\tu->cargo_type = v->cargo_type;\n\tu->cargo_subtype = v->cargo_subtype;\n\tu->cargo_cap = v->cargo_cap;\n\tu->refit_cap = v->refit_cap;\n\tu->railtype = v->railtype;\n\tu->engine_type = v->engine_type;\n\tu->reliability = v->reliability;\n\tu->reliability_spd_dec = v->reliability_spd_dec;\n\tu->date_of_last_service = v->date_of_last_service;\n\tu->build_year = v->build_year;\n\tu->sprite_seq.Set(SPR_IMG_QUERY);\n\tu->random_bits = VehicleRandomBits();\n\tv->SetMultiheaded();\n\tu->SetMultiheaded();\n\tif (v->IsVirtual()) u->SetVirtual();\n\tv->SetNext(u);\n\tu->UpdatePosition();\n\n\t/* Now we need to link the front and rear engines together */\n\tv->other_multiheaded_part = u;\n\tu->other_multiheaded_part = v;\n}\n\n/**\n * Build a railroad vehicle.\n * @param tile     tile of the depot where rail-vehicle is built.\n * @param flags    type of operation.\n * @param e        the engine to build.\n * @param data     bit 0 prevents any free cars from being added to the train.\n * @param[out] ret the vehicle that has been built.\n * @return the cost of this operation or an error.\n */\nCommandCost CmdBuildRailVehicle(TileIndex tile, DoCommandFlag flags, const Engine* e, uint16 data, Vehicle** ret)\n{\n\tconst RailVehicleInfo* rvi = &e->u.rail;\n\n\tif (rvi->railveh_type == RAILVEH_WAGON) return CmdBuildRailWagon(tile, flags, e, ret);\n\n\t/* Check if depot and new engine uses the same kind of tracks *\n\t * We need to see if the engine got power on the tile to avoid electric engines in non-electric depots */\n\tif (!HasPowerOnRail(rvi->railtype, GetRailType(tile))) return_cmd_error(STR_ERROR_DEPOT_HAS_WRONG_RAIL_TYPE);\n\n\tif (flags & DC_EXEC) {\n\t\tDiagDirection dir = GetRailDepotDirection(tile);\n\t\tint x = TileX(tile) * TILE_SIZE + _vehicle_initial_x_fract[dir];\n\t\tint y = TileY(tile) * TILE_SIZE + _vehicle_initial_y_fract[dir];\n\n\t\tTrain* v = new Train();\n\t\t*ret = v;\n\t\tv->direction = DiagDirToDir(dir);\n\t\tv->tile = tile;\n\t\tv->owner = _current_company;\n\t\tv->x_pos = x;\n\t\tv->y_pos = y;\n\t\tv->z_pos = GetSlopePixelZ(x, y);\n\t\tv->track = TRACK_BIT_DEPOT;\n\t\tSetBit(v->flags, VRF_CONSIST_SPEED_REDUCTION);\n\t\tv->vehstatus = VS_HIDDEN | VS_STOPPED | VS_DEFPAL;\n\t\tv->spritenum = rvi->image_index;\n\t\tv->cargo_type = e->GetDefaultCargoType();\n\t\tv->cargo_cap = rvi->capacity;\n\t\tv->refit_cap = 0;\n\t\tv->last_station_visited = INVALID_STATION;\n\t\tv->last_loading_station = INVALID_STATION;\n\t\tv->reverse_distance = 0;\n\t\tv->speed_restriction = 0;\n\n\t\tv->engine_type = e->index;\n\t\tv->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback\n\n\t\tv->reliability = e->reliability;\n\t\tv->reliability_spd_dec = e->reliability_spd_dec;\n\t\tv->max_age = e->GetLifeLengthInDays();\n\n\t\tv->railtype = rvi->railtype;\n\t\t_new_vehicle_id = v->index;\n\n\t\tv->SetServiceInterval(Company::Get(_current_company)->settings.vehicle.servint_trains);\n\t\tv->date_of_last_service = _date;\n\t\tv->build_year = _cur_year;\n\t\tv->sprite_seq.Set(SPR_IMG_QUERY);\n\t\tv->random_bits = VehicleRandomBits();\n\n\t\tif (e->flags & ENGINE_EXCLUSIVE_PREVIEW) SetBit(v->vehicle_flags, VF_BUILT_AS_PROTOTYPE);\n\t\tv->SetServiceIntervalIsPercent(Company::Get(_current_company)->settings.vehicle.servint_ispercent);\n\t\tSB(v->vehicle_flags, VF_AUTOMATE_TIMETABLE, 1, Company::Get(_current_company)->settings.vehicle.auto_timetable_by_default);\n\t\tSB(v->vehicle_flags, VF_TIMETABLE_SEPARATION, 1, Company::Get(_current_company)->settings.vehicle.auto_separation_by_default);\n\n\t\tv->group_id = DEFAULT_GROUP;\n\n\t\tv->SetFrontEngine();\n\t\tv->SetEngine();\n\n\t\tv->UpdatePosition();\n\n\t\tif (rvi->railveh_type == RAILVEH_MULTIHEAD) {\n\t\t\tAddRearEngineToMultiheadedTrain(v);\n\t\t}\n\t\telse {\n\t\t\tAddArticulatedParts(v);\n\t\t}\n\n\t\tv->ConsistChanged(CCF_ARRANGE);\n\t\tUpdateTrainGroupID(v);\n\n\t\tif (!HasBit(data, 0) && !(flags & DC_AUTOREPLACE)) { // check if the cars should be added to the new vehicle\n\t\t\tNormalizeTrainVehInDepot(v);\n\t\t}\n\n\t\tCheckConsistencyOfArticulatedVehicle(v);\n\n\t\tInvalidateVehicleTickCaches();\n\t}\n\n\treturn CommandCost();\n}\n\nstatic Train* FindGoodVehiclePos(const Train* src)\n{\n\tEngineID eng = src->engine_type;\n\tTileIndex tile = src->tile;\n\n\tfor (Train* dst : Train::Iterate()) {\n\t\tif (dst->IsFreeWagon() && dst->tile == tile && !(dst->vehstatus & VS_CRASHED) && dst->owner == src->owner && !dst->IsVirtual()) {\n\t\t\t/* check so all vehicles in the line have the same engine. */\n\t\t\tTrain* t = dst;\n\t\t\twhile (t->engine_type == eng) {\n\t\t\t\tt = t->Next();\n\t\t\t\tif (t == nullptr) return dst;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nullptr;\n}\n\n/** Helper type for lists/vectors of trains */\ntypedef std::vector<Train*> TrainList;\n\n/**\n * Make a backup of a train into a train list.\n * @param list to make the backup in\n * @param t    the train to make the backup of\n */\nstatic void MakeTrainBackup(TrainList& list, Train* t)\n{\n\tfor (; t != nullptr; t = t->Next()) list.push_back(t);\n}\n\n/**\n * Restore the train from the backup list.\n * @param list the train to restore.\n */\nstatic void RestoreTrainBackup(TrainList& list)\n{\n\t/* No train, nothing to do. */\n\tif (list.size() == 0) return;\n\n\tTrain* prev = nullptr;\n\t/* Iterate over the list and rebuild it. */\n\tfor (Train* t : list) {\n\t\tif (prev != nullptr) {\n\t\t\tprev->SetNext(t);\n\t\t}\n\t\telse if (t->Previous() != nullptr) {\n\t\t\t/* Make sure the head of the train is always the first in the chain. */\n\t\t\tt->Previous()->SetNext(nullptr);\n\t\t}\n\t\tprev = t;\n\t}\n}\n\n/**\n * Remove the given wagon from its consist.\n * @param part the part of the train to remove.\n * @param chain whether to remove the whole chain.\n */\nstatic void RemoveFromConsist(Train* part, bool chain = false)\n{\n\tTrain* tail = chain ? part->Last() : part->GetLastEnginePart();\n\n\t/* Unlink at the front, but make it point to the next\n\t * vehicle after the to be remove part. */\n\tif (part->Previous() != nullptr) part->Previous()->SetNext(tail->Next());\n\n\t/* Unlink at the back */\n\ttail->SetNext(nullptr);\n}\n\n/**\n * Inserts a chain into the train at dst.\n * @param dst   the place where to append after.\n * @param chain the chain to actually add.\n */\nstatic void InsertInConsist(Train* dst, Train* chain)\n{\n\t/* We do not want to add something in the middle of an articulated part. */\n\tassert(dst != nullptr && (dst->Next() == nullptr || !dst->Next()->IsArticulatedPart()));\n\n\tchain->Last()->SetNext(dst->Next());\n\tdst->SetNext(chain);\n}\n\n/**\n * Normalise the dual heads in the train, i.e. if one is\n * missing move that one to this train.\n * @param t the train to normalise.\n */\nstatic void NormaliseDualHeads(Train* t)\n{\n\tfor (; t != nullptr; t = t->GetNextVehicle()) {\n\t\tif (!t->IsMultiheaded() || !t->IsEngine()) continue;\n\n\t\t/* Make sure that there are no free cars before next engine */\n\t\tTrain* u;\n\t\tfor (u = t; u->Next() != nullptr && !u->Next()->IsEngine(); u = u->Next()) {}\n\n\t\tif (u == t->other_multiheaded_part) continue;\n\n\t\t/* Remove the part from the 'wrong' train */\n\t\tRemoveFromConsist(t->other_multiheaded_part);\n\t\t/* And add it to the 'right' train */\n\t\tInsertInConsist(u, t->other_multiheaded_part);\n\t}\n}\n\n/**\n * Normalise the sub types of the parts in this chain.\n * @param chain the chain to normalise.\n */\nstatic void NormaliseSubtypes(Train* chain)\n{\n\t/* Nothing to do */\n\tif (chain == nullptr) return;\n\n\t/* We must be the first in the chain. */\n\tassert(chain->Previous() == nullptr);\n\n\t/* Set the appropriate bits for the first in the chain. */\n\tif (chain->IsWagon()) {\n\t\tchain->SetFreeWagon();\n\t}\n\telse {\n\t\tassert(chain->IsEngine());\n\t\tchain->SetFrontEngine();\n\t}\n\n\t/* Now clear the bits for the rest of the chain */\n\tfor (Train* t = chain->Next(); t != nullptr; t = t->Next()) {\n\t\tt->ClearFreeWagon();\n\t\tt->ClearFrontEngine();\n\t}\n}\n\n/**\n * Check/validate whether we may actually build a new train.\n * @note All vehicles are/were 'heads' of their chains.\n * @param original_dst The original destination chain.\n * @param dst          The destination chain after constructing the train.\n * @param original_src The original source chain.\n * @param src          The source chain after constructing the train.\n * @return possible error of this command.\n */\nstatic CommandCost CheckNewTrain(Train* original_dst, Train* dst, Train* original_src, Train* src)\n{\n\t/* Just add 'new' engines and subtract the original ones.\n\t * If that's less than or equal to 0 we can be sure we did\n\t * not add any engines (read: trains) along the way. */\n\tif ((src != nullptr && src->IsEngine() ? 1 : 0) +\n\t\t(dst != nullptr && dst->IsEngine() ? 1 : 0) -\n\t\t(original_src != nullptr && original_src->IsEngine() ? 1 : 0) -\n\t\t(original_dst != nullptr && original_dst->IsEngine() ? 1 : 0) <= 0) {\n\t\treturn CommandCost();\n\t}\n\n\t/* Get a free unit number and check whether it's within the bounds.\n\t * There will always be a maximum of one new train. */\n\tif (GetFreeUnitNumber(VEH_TRAIN) <= _settings_game.vehicle.max_trains) return CommandCost();\n\n\treturn_cmd_error(STR_ERROR_TOO_MANY_VEHICLES_IN_GAME);\n}\n\n/**\n * Check whether the train parts can be attached.\n * @param t the train to check\n * @return possible error of this command.\n */\nstatic CommandCost CheckTrainAttachment(Train* t)\n{\n\t/* No multi-part train, no need to check. */\n\tif (t == nullptr || t->Next() == nullptr || !t->IsEngine()) return CommandCost();\n\n\t/* The maximum length for a train. For each part we decrease this by one\n\t * and if the result is negative the train is simply too long. */\n\tint allowed_len = _settings_game.vehicle.max_train_length * TILE_SIZE - t->gcache.cached_veh_length;\n\n\tTrain* head = t;\n\tTrain* prev = t;\n\n\t/* Break the prev -> t link so it always holds within the loop. */\n\tt = t->Next();\n\tprev->SetNext(nullptr);\n\n\t/* Make sure the cache is cleared. */\n\thead->InvalidateNewGRFCache();\n\n\twhile (t != nullptr) {\n\t\tallowed_len -= t->gcache.cached_veh_length;\n\n\t\tTrain* next = t->Next();\n\n\t\t/* Unlink the to-be-added piece; it is already unlinked from the previous\n\t\t * part due to the fact that the prev -> t link is broken. */\n\t\tt->SetNext(nullptr);\n\n\t\t/* Don't check callback for articulated or rear dual headed parts */\n\t\tif (!t->IsArticulatedPart() && !t->IsRearDualheaded()) {\n\t\t\t/* Back up and clear the first_engine data to avoid using wagon override group */\n\t\t\tEngineID first_engine = t->gcache.first_engine;\n\t\t\tt->gcache.first_engine = INVALID_ENGINE;\n\n\t\t\t/* We don't want the cache to interfere. head's cache is cleared before\n\t\t\t * the loop and after each callback does not need to be cleared here. */\n\t\t\tt->InvalidateNewGRFCache();\n\n\t\t\tuint16 callback = GetVehicleCallbackParent(CBID_TRAIN_ALLOW_WAGON_ATTACH, 0, 0, head->engine_type, t, head);\n\n\t\t\t/* Restore original first_engine data */\n\t\t\tt->gcache.first_engine = first_engine;\n\n\t\t\t/* We do not want to remember any cached variables from the test run */\n\t\t\tt->InvalidateNewGRFCache();\n\t\t\thead->InvalidateNewGRFCache();\n\n\t\t\tif (callback != CALLBACK_FAILED) {\n\t\t\t\t/* A failing callback means everything is okay */\n\t\t\t\tStringID error = STR_NULL;\n\n\t\t\t\tif (head->GetGRF()->grf_version < 8) {\n\t\t\t\t\tif (callback == 0xFD) error = STR_ERROR_INCOMPATIBLE_RAIL_TYPES;\n\t\t\t\t\tif (callback < 0xFD) error = GetGRFStringID(head->GetGRFID(), 0xD000 + callback);\n\t\t\t\t\tif (callback >= 0x100) ErrorUnknownCallbackResult(head->GetGRFID(), CBID_TRAIN_ALLOW_WAGON_ATTACH, callback);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (callback < 0x400) {\n\t\t\t\t\t\terror = GetGRFStringID(head->GetGRFID(), 0xD000 + callback);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tswitch (callback) {\n\t\t\t\t\t\tcase 0x400: // allow if railtypes match (always the case for OpenTTD)\n\t\t\t\t\t\tcase 0x401: // allow\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:    // unknown reason -> disallow\n\t\t\t\t\t\tcase 0x402: // disallow attaching\n\t\t\t\t\t\t\terror = STR_ERROR_INCOMPATIBLE_RAIL_TYPES;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (error != STR_NULL) return_cmd_error(error);\n\t\t\t}\n\t\t}\n\n\t\t/* And link it to the new part. */\n\t\tprev->SetNext(t);\n\t\tprev = t;\n\t\tt = next;\n\t}\n\n\tif (allowed_len < 0) return_cmd_error(STR_ERROR_TRAIN_TOO_LONG);\n\treturn CommandCost();\n}\n\n/**\n * Validate whether we are going to create valid trains.\n * @note All vehicles are/were 'heads' of their chains.\n * @param original_dst The original destination chain.\n * @param dst          The destination chain after constructing the train.\n * @param original_src The original source chain.\n * @param src          The source chain after constructing the train.\n * @param check_limit  Whether to check the vehicle limit.\n * @return possible error of this command.\n */\nstatic CommandCost ValidateTrains(Train* original_dst, Train* dst, Train* original_src, Train* src, bool check_limit)\n{\n\t/* Check whether we may actually construct the trains. */\n\tCommandCost ret = CheckTrainAttachment(src);\n\tif (ret.Failed()) return ret;\n\tret = CheckTrainAttachment(dst);\n\tif (ret.Failed()) return ret;\n\n\t/* Check whether we need to build a new train. */\n\treturn check_limit ? CheckNewTrain(original_dst, dst, original_src, src) : CommandCost();\n}\n\n/**\n * Arrange the trains in the wanted way.\n * @param dst_head   The destination chain of the to be moved vehicle.\n * @param dst        The destination for the to be moved vehicle.\n * @param src_head   The source chain of the to be moved vehicle.\n * @param src        The to be moved vehicle.\n * @param move_chain Whether to move all vehicles after src or not.\n */\nstatic void ArrangeTrains(Train** dst_head, Train* dst, Train** src_head, Train* src, bool move_chain)\n{\n\t/* First determine the front of the two resulting trains */\n\tif (*src_head == *dst_head) {\n\t\t/* If we aren't moving part(s) to a new train, we are just moving the\n\t\t * front back and there is not destination head. */\n\t\t*dst_head = nullptr;\n\t}\n\telse if (*dst_head == nullptr) {\n\t\t/* If we are moving to a new train the head of the move train would become\n\t\t * the head of the new vehicle. */\n\t\t*dst_head = src;\n\t}\n\n\tif (src == *src_head) {\n\t\t/* If we are moving the front of a train then we are, in effect, creating\n\t\t * a new head for the train. Point to that. Unless we are moving the whole\n\t\t * train in which case there is not 'source' train anymore.\n\t\t * In case we are a multiheaded part we want the complete thing to come\n\t\t * with us, so src->GetNextUnit(), however... when we are e.g. a wagon\n\t\t * that is followed by a rear multihead we do not want to include that. */\n\t\t*src_head = move_chain ? nullptr :\n\t\t\t(src->IsMultiheaded() ? src->GetNextUnit() : src->GetNextVehicle());\n\t}\n\n\t/* Now it's just simply removing the part that we are going to move from the\n\t * source train and *if* the destination is a not a new train add the chain\n\t * at the destination location. */\n\tRemoveFromConsist(src, move_chain);\n\tif (*dst_head != src) InsertInConsist(dst, src);\n\n\t/* Now normalise the dual heads, that is move the dual heads around in such\n\t * a way that the head and rear of a dual head are in the same train */\n\tNormaliseDualHeads(*src_head);\n\tNormaliseDualHeads(*dst_head);\n}\n\n/**\n * Normalise the head of the train again, i.e. that is tell the world that\n * we have changed and update all kinds of variables.\n * @param head the train to update.\n */\nstatic void NormaliseTrainHead(Train* head)\n{\n\t/* Not much to do! */\n\tif (head == nullptr) return;\n\n\t/* Tell the 'world' the train changed. */\n\thead->ConsistChanged(CCF_ARRANGE);\n\tUpdateTrainGroupID(head);\n\tSetBit(head->flags, VRF_CONSIST_SPEED_REDUCTION);\n\n\t/* Not a front engine, i.e. a free wagon chain. No need to do more. */\n\tif (!head->IsFrontEngine()) return;\n\n\t/* Update the refit button and window */\n\tInvalidateWindowData(WC_VEHICLE_REFIT, head->index, VIWD_CONSIST_CHANGED);\n\tSetWindowWidgetDirty(WC_VEHICLE_VIEW, head->index, WID_VV_REFIT);\n\n\t/* If we don't have a unit number yet, set one. */\n\tif (head->unitnumber != 0 || HasBit(head->subtype, GVSF_VIRTUAL)) return;\n\thead->unitnumber = GetFreeUnitNumber(VEH_TRAIN);\n}\n\n/**\n * Move a rail vehicle around inside the depot.\n * @param tile unused\n * @param flags type of operation\n *              Note: DC_AUTOREPLACE is set when autoreplace tries to undo its modifications or moves vehicles to temporary locations inside the depot.\n * @param p1 various bitstuffed elements\n * - p1 (bit  0 - 19) source vehicle index\n * - p1 (bit      20) move all vehicles following the source vehicle\n * - p1 (bit      21) this is a virtual vehicle (for creating TemplateVehicles)\n * - p1 (bit      22) when moving a head vehicle, always reset the head state\n * - p1 (bit      23) if move fails, and source vehicle is virtual, delete it\n * @param p2 what wagon to put the source wagon AFTER, XXX - INVALID_VEHICLE to make a new line\n * @param text unused\n * @return the cost of this operation or an error\n */\nCommandCost CmdMoveRailVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char* text)\n{\n\tVehicleID s = GB(p1, 0, 20);\n\tVehicleID d = GB(p2, 0, 20);\n\tbool move_chain = HasBit(p1, 20);\n\tbool new_head = HasBit(p1, 22);\n\tbool delete_failed_virtual = HasBit(p1, 23);\n\n\tTrain* src = Train::GetIfValid(s);\n\tif (src == nullptr) return CMD_ERROR;\n\n\tauto check_on_failure = [&](CommandCost cost) -> CommandCost {\n\t\tif (delete_failed_virtual && src->IsVirtual()) {\n\t\t\treturn DoCommand(src->tile, src->index | (1 << 21), 0, flags, CMD_SELL_VEHICLE);\n\t\t}\n\t\telse {\n\t\t\treturn cost;\n\t\t}\n\t};\n\n\tCommandCost ret = CheckOwnership(src->owner);\n\tif (ret.Failed()) return check_on_failure(ret);\n\n\t/* Do not allow moving crashed vehicles inside the depot, it is likely to cause asserts later */\n\tif (src->vehstatus & VS_CRASHED) return CMD_ERROR;\n\n\t/* if nothing is selected as destination, try and find a matching vehicle to drag to. */\n\tTrain* dst;\n\tif (d == INVALID_VEHICLE) {\n\t\tdst = src->IsEngine() ? nullptr : FindGoodVehiclePos(src);\n\t}\n\telse {\n\t\tdst = Train::GetIfValid(d);\n\t\tif (dst == nullptr) return check_on_failure(CMD_ERROR);\n\n\t\tCommandCost ret = CheckOwnership(dst->owner);\n\t\tif (ret.Failed()) return check_on_failure(ret);\n\n\t\t/* Do not allow appending to crashed vehicles, too */\n\t\tif (dst->vehstatus & VS_CRASHED) return CMD_ERROR;\n\t}\n\n\t/* if an articulated part is being handled, deal with its parent vehicle */\n\tsrc = src->GetFirstEnginePart();\n\tif (dst != nullptr) {\n\t\tdst = dst->GetFirstEnginePart();\n\t\tassert(HasBit(dst->subtype, GVSF_VIRTUAL) == HasBit(src->subtype, GVSF_VIRTUAL));\n\t}\n\n\t/* don't move the same vehicle.. */\n\tif (src == dst) return CommandCost();\n\n\t/* locate the head of the two chains */\n\tTrain* src_head = src->First();\n\tassert(HasBit(src_head->subtype, GVSF_VIRTUAL) == HasBit(src->subtype, GVSF_VIRTUAL));\n\tTrain* dst_head;\n\tif (dst != nullptr) {\n\t\tdst_head = dst->First();\n\t\tassert(HasBit(dst_head->subtype, GVSF_VIRTUAL) == HasBit(dst->subtype, GVSF_VIRTUAL));\n\t\tif (dst_head->tile != src_head->tile) return CMD_ERROR;\n\t\t/* Now deal with articulated part of destination wagon */\n\t\tdst = dst->GetLastEnginePart();\n\t}\n\telse {\n\t\tdst_head = nullptr;\n\t}\n\n\tif (src->IsRearDualheaded()) return_cmd_error(STR_ERROR_REAR_ENGINE_FOLLOW_FRONT);\n\n\t/* When moving all wagons, we can't have the same src_head and dst_head */\n\tif (move_chain && src_head == dst_head) return CommandCost();\n\n\t/* When moving a multiheaded part to be place after itself, bail out. */\n\tif (!move_chain && dst != nullptr && dst->IsRearDualheaded() && src == dst->other_multiheaded_part) return CommandCost();\n\n\t/* Check if all vehicles in the source train are stopped inside a depot. */\n\t/* Do this check only if the vehicle to be moved is non-virtual */\n\tif (!HasBit(p1, 21)) {\n\t\tif (!src_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);\n\t}\n\n\t/* Check if all vehicles in the destination train are stopped inside a depot. */\n\t/* Do this check only if the destination vehicle is non-virtual */\n\tif (!HasBit(p1, 21)) {\n\t\tif (dst_head != nullptr && !dst_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);\n\t}\n\n\t/* First make a backup of the order of the trains. That way we can do\n\t * whatever we want with the order and later on easily revert. */\n\tTrainList original_src;\n\tTrainList original_dst;\n\n\tMakeTrainBackup(original_src, src_head);\n\tMakeTrainBackup(original_dst, dst_head);\n\n\t/* Also make backup of the original heads as ArrangeTrains can change them.\n\t * For the destination head we do not care if it is the same as the source\n\t * head because in that case it's just a copy. */\n\tTrain* original_src_head = src_head;\n\tTrain* original_dst_head = (dst_head == src_head ? nullptr : dst_head);\n\n\t/* We want this information from before the rearrangement, but execute this after the validation.\n\t * original_src_head can't be nullptr; src is by definition != nullptr, so src_head can't be nullptr as\n\t * src->GetFirst() always yields non-nullptr, so eventually original_src_head != nullptr as well. */\n\tbool original_src_head_front_engine = original_src_head->IsFrontEngine();\n\tbool original_dst_head_front_engine = original_dst_head != nullptr && original_dst_head->IsFrontEngine();\n\n\t/* (Re)arrange the trains in the wanted arrangement. */\n\tArrangeTrains(&dst_head, dst, &src_head, src, move_chain);\n\n\tif ((flags & DC_AUTOREPLACE) == 0) {\n\t\t/* If the autoreplace flag is set we do not need to test for the validity\n\t\t * because we are going to revert the train to its original state. As we\n\t\t * assume the original state was correct autoreplace can skip this. */\n\t\tCommandCost ret = ValidateTrains(original_dst_head, dst_head, original_src_head, src_head, true);\n\t\tif (ret.Failed()) {\n\t\t\t/* Restore the train we had. */\n\t\t\tRestoreTrainBackup(original_src);\n\t\t\tRestoreTrainBackup(original_dst);\n\t\t\treturn check_on_failure(ret);\n\t\t}\n\t}\n\n\t/* do it? */\n\tif (flags & DC_EXEC) {\n\t\t/* Remove old heads from the statistics */\n\t\tif (original_src_head_front_engine) GroupStatistics::CountVehicle(original_src_head, -1);\n\t\tif (original_dst_head_front_engine) GroupStatistics::CountVehicle(original_dst_head, -1);\n\n\t\t/* First normalise the sub types of the chains. */\n\t\tNormaliseSubtypes(src_head);\n\t\tNormaliseSubtypes(dst_head);\n\n\t\t/* There are 14 different cases:\n\t\t *  1) front engine gets moved to a new train, it stays a front engine.\n\t\t *     a) the 'next' part is a wagon that becomes a free wagon chain.\n\t\t *     b) the 'next' part is an engine that becomes a front engine.\n\t\t *     c) there is no 'next' part, nothing else happens\n\t\t *  2) front engine gets moved to another train, it is not a front engine anymore\n\t\t *     a) the 'next' part is a wagon that becomes a free wagon chain.\n\t\t *     b) the 'next' part is an engine that becomes a front engine.\n\t\t *     c) there is no 'next' part, nothing else happens\n\t\t *  3) front engine gets moved to later in the current train, it is not a front engine anymore.\n\t\t *     a) the 'next' part is a wagon that becomes a free wagon chain.\n\t\t *     b) the 'next' part is an engine that becomes a front engine.\n\t\t *  4) free wagon gets moved\n\t\t *     a) the 'next' part is a wagon that becomes a free wagon chain.\n\t\t *     b) the 'next' part is an engine that becomes a front engine.\n\t\t *     c) there is no 'next' part, nothing else happens\n\t\t *  5) non front engine gets moved and becomes a new train, nothing else happens\n\t\t *  6) non front engine gets moved within a train / to another train, nothing happens\n\t\t *  7) wagon gets moved, nothing happens\n\t\t */\n\t\tif (src == original_src_head && src->IsEngine() && (!src->IsFrontEngine() || new_head)) {\n\t\t\t/* Cases #2 and #3: the front engine gets trashed. */\n\t\t\tDeleteWindowById(WC_VEHICLE_VIEW, src->index);\n\t\t\tDeleteWindowById(WC_VEHICLE_ORDERS, src->index);\n\t\t\tDeleteWindowById(WC_VEHICLE_REFIT, src->index);\n\t\t\tDeleteWindowById(WC_VEHICLE_DETAILS, src->index);\n\t\t\tDeleteWindowById(WC_VEHICLE_TIMETABLE, src->index);\n\t\t\tDeleteNewGRFInspectWindow(GSF_TRAINS, src->index);\n\t\t\tSetWindowDirty(WC_COMPANY, _current_company);\n\n\t\t\t/* Delete orders, group stuff and the unit number as we're not the\n\t\t\t * front of any vehicle anymore. */\n\t\t\tDeleteVehicleOrders(src);\n\t\t\tRemoveVehicleFromGroup(src);\n\t\t\tsrc->unitnumber = 0;\n\t\t\tif (HasBit(src->flags, VRF_HAVE_SLOT)) {\n\t\t\t\tTraceRestrictRemoveVehicleFromAllSlots(src->index);\n\t\t\t\tClrBit(src->flags, VRF_HAVE_SLOT);\n\t\t\t}\n\t\t\tOrderBackup::ClearVehicle(src);\n\t\t}\n\n\t\t/* We weren't a front engine but are becoming one. So\n\t\t * we should be put in the default group. */\n\t\tif ((original_src_head != src || new_head) && dst_head == src) {\n\t\t\tSetTrainGroupID(src, DEFAULT_GROUP);\n\t\t\tSetWindowDirty(WC_COMPANY, _current_company);\n\t\t}\n\n\t\t/* Add new heads to statistics */\n\t\tif (src_head != nullptr && src_head->IsFrontEngine()) GroupStatistics::CountVehicle(src_head, 1);\n\t\tif (dst_head != nullptr && dst_head->IsFrontEngine()) GroupStatistics::CountVehicle(dst_head, 1);\n\n\t\t/* Handle 'new engine' part of cases #1b, #2b, #3b, #4b and #5 in NormaliseTrainHead. */\n\t\tNormaliseTrainHead(src_head);\n\t\tNormaliseTrainHead(dst_head);\n\n\t\tif ((flags & DC_NO_CARGO_CAP_CHECK) == 0) {\n\t\t\tCheckCargoCapacity(src_head);\n\t\t\tCheckCargoCapacity(dst_head);\n\t\t}\n\n\t\tif (src_head != nullptr) {\n\t\t\tsrc_head->last_loading_station = INVALID_STATION;\n\t\t\tClrBit(src_head->vehicle_flags, VF_LAST_LOAD_ST_SEP);\n\t\t}\n\t\tif (dst_head != nullptr) {\n\t\t\tdst_head->last_loading_station = INVALID_STATION;\n\t\t\tClrBit(dst_head->vehicle_flags, VF_LAST_LOAD_ST_SEP);\n\t\t}\n\n\t\tif (src_head != nullptr) src_head->First()->MarkDirty();\n\t\tif (dst_head != nullptr) dst_head->First()->MarkDirty();\n\n\t\t/* We are undoubtedly changing something in the depot and train list. */\n\t\t/* But only if the moved vehicle is not virtual */\n\t\tif (!HasBit(src->subtype, GVSF_VIRTUAL)) {\n\t\t\tInvalidateWindowData(WC_VEHICLE_DEPOT, src->tile);\n\t\t\tInvalidateWindowClassesData(WC_TRAINS_LIST, 0);\n\t\t\tInvalidateWindowClassesData(WC_TRACE_RESTRICT_SLOTS, 0);\n\t\t\tInvalidateWindowClassesData(WC_DEPARTURES_BOARD, 0);\n\t\t}\n\t}\n\telse {\n\t\t/* We don't want to execute what we're just tried. */\n\t\tRestoreTrainBackup(original_src);\n\t\tRestoreTrainBackup(original_dst);\n\t}\n\n\tInvalidateVehicleTickCaches();\n\n\treturn CommandCost();\n}\n\n/**\n * Sell a (single) train wagon/engine.\n * @param flags type of operation\n * @param t     the train wagon to sell\n * @param data  the selling mode\n * - data = 0: only sell the single dragged wagon/engine (and any belonging rear-engines)\n * - data = 1: sell the vehicle and all vehicles following it in the chain\n *             if the wagon is dragged, don't delete the possibly belonging rear-engine to some front\n * @param user  the user for the order backup.\n * @return the cost of this operation or an error\n */\nCommandCost CmdSellRailWagon(DoCommandFlag flags, Vehicle* t, uint16 data, uint32 user)\n{\n\t/* Sell a chain of vehicles or not? */\n\tbool sell_chain = HasBit(data, 0);\n\n\tTrain* v = Train::From(t)->GetFirstEnginePart();\n\tTrain* first = v->First();\n\n\tif (v->IsRearDualheaded()) return_cmd_error(STR_ERROR_REAR_ENGINE_FOLLOW_FRONT);\n\n\t/* First make a backup of the order of the train. That way we can do\n\t * whatever we want with the order and later on easily revert. */\n\tTrainList original;\n\tMakeTrainBackup(original, first);\n\n\t/* We need to keep track of the new head and the head of what we're going to sell. */\n\tTrain* new_head = first;\n\tTrain* sell_head = nullptr;\n\n\t/* Split the train in the wanted way. */\n\tArrangeTrains(&sell_head, nullptr, &new_head, v, sell_chain);\n\n\t/* We don't need to validate the second train; it's going to be sold. */\n\tCommandCost ret = ValidateTrains(nullptr, nullptr, first, new_head, (flags & DC_AUTOREPLACE) == 0);\n\tif (ret.Failed()) {\n\t\t/* Restore the train we had. */\n\t\tRestoreTrainBackup(original);\n\t\treturn ret;\n\t}\n\n\tif (first->orders.list == nullptr && !OrderList::CanAllocateItem()) {\n\t\t/* Restore the train we had. */\n\t\tRestoreTrainBackup(original);\n\t\treturn_cmd_error(STR_ERROR_NO_MORE_SPACE_FOR_ORDERS);\n\t}\n\n\tCommandCost cost(EXPENSES_NEW_VEHICLES);\n\tfor (Train* t = sell_head; t != nullptr; t = t->Next()) cost.AddCost(-t->value);\n\n\t/* do it? */\n\tif (flags & DC_EXEC) {\n\t\t/* First normalise the sub types of the chain. */\n\t\tNormaliseSubtypes(new_head);\n\n\t\tif (v == first && v->IsEngine() && !sell_chain && new_head != nullptr && new_head->IsFrontEngine()) {\n\t\t\t/* We are selling the front engine. In this case we want to\n\t\t\t * 'give' the order, unit number and such to the new head. */\n\t\t\tnew_head->orders.list = first->orders.list;\n\t\t\tnew_head->AddToShared(first);\n\t\t\tDeleteVehicleOrders(first);\n\n\t\t\t/* Copy other important data from the front engine */\n\t\t\tnew_head->CopyVehicleConfigAndStatistics(first);\n\t\t\tnew_head->speed_restriction = first->speed_restriction;\n\t\t\tGroupStatistics::CountVehicle(new_head, 1); // after copying over the profit\n\t\t}\n\t\telse if (v->IsPrimaryVehicle() && data & (MAKE_ORDER_BACKUP_FLAG >> 20)) {\n\t\t\tOrderBackup::Backup(v, user);\n\t\t}\n\n\t\t/* We need to update the information about the train. */\n\t\tNormaliseTrainHead(new_head);\n\n\t\t/* We are undoubtedly changing something in the depot and train list. */\n\t\t/* Unless its a virtual train */\n\t\tif (!HasBit(v->subtype, GVSF_VIRTUAL)) {\n\t\t\tInvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);\n\t\t\tInvalidateWindowClassesData(WC_TRAINS_LIST, 0);\n\t\t\tInvalidateWindowClassesData(WC_TRACE_RESTRICT_SLOTS, 0);\n\t\t\tInvalidateWindowClassesData(WC_DEPARTURES_BOARD, 0);\n\t\t}\n\n\t\t/* Actually delete the sold 'goods' */\n\t\tdelete sell_head;\n\t}\n\telse {\n\t\t/* We don't want to execute what we're just tried. */\n\t\tRestoreTrainBackup(original);\n\t}\n\n\treturn cost;\n}\n\nvoid Train::UpdateDeltaXY()\n{\n\t/* Set common defaults. */\n\tthis->x_offs = -1;\n\tthis->y_offs = -1;\n\tthis->x_extent = 3;\n\tthis->y_extent = 3;\n\tthis->z_extent = 6;\n\tthis->x_bb_offs = 0;\n\tthis->y_bb_offs = 0;\n\n\tif (!IsDiagonalDirection(this->direction)) {\n\t\tstatic const int _sign_table[] =\n\t\t{\n\t\t\t/* x, y */\n\t\t\t-1, -1, // DIR_N\n\t\t\t-1,  1, // DIR_E\n\t\t\t 1,  1, // DIR_S\n\t\t\t 1, -1, // DIR_W\n\t\t};\n\n\t\tint half_shorten = (VEHICLE_LENGTH - this->gcache.cached_veh_length) / 2;\n\n\t\t/* For all straight directions, move the bound box to the centre of the vehicle, but keep the size. */\n\t\tthis->x_offs -= half_shorten * _sign_table[this->direction];\n\t\tthis->y_offs -= half_shorten * _sign_table[this->direction + 1];\n\t\tthis->x_extent += this->x_bb_offs = half_shorten * _sign_table[direction];\n\t\tthis->y_extent += this->y_bb_offs = half_shorten * _sign_table[direction + 1];\n\t}\n\telse {\n\t\tswitch (this->direction) {\n\t\t\t/* Shorten southern corner of the bounding box according the vehicle length\n\t\t\t * and center the bounding box on the vehicle. */\n\t\tcase DIR_NE:\n\t\t\tthis->x_offs = 1 - (this->gcache.cached_veh_length + 1) / 2;\n\t\t\tthis->x_extent = this->gcache.cached_veh_length - 1;\n\t\t\tthis->x_bb_offs = -1;\n\t\t\tbreak;\n\n\t\tcase DIR_NW:\n\t\t\tthis->y_offs = 1 - (this->gcache.cached_veh_length + 1) / 2;\n\t\t\tthis->y_extent = this->gcache.cached_veh_length - 1;\n\t\t\tthis->y_bb_offs = -1;\n\t\t\tbreak;\n\n\t\t\t/* Move northern corner of the bounding box down according to vehicle length\n\t\t\t * and center the bounding box on the vehicle. */\n\t\tcase DIR_SW:\n\t\t\tthis->x_offs = 1 + (this->gcache.cached_veh_length + 1) / 2 - VEHICLE_LENGTH;\n\t\t\tthis->x_extent = VEHICLE_LENGTH - 1;\n\t\t\tthis->x_bb_offs = VEHICLE_LENGTH - this->gcache.cached_veh_length - 1;\n\t\t\tbreak;\n\n\t\tcase DIR_SE:\n\t\t\tthis->y_offs = 1 + (this->gcache.cached_veh_length + 1) / 2 - VEHICLE_LENGTH;\n\t\t\tthis->y_extent = VEHICLE_LENGTH - 1;\n\t\t\tthis->y_bb_offs = VEHICLE_LENGTH - this->gcache.cached_veh_length - 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tNOT_REACHED();\n\t\t}\n\t}\n}\n\n/**\n * Mark a train as stuck and stop it if it isn't stopped right now.\n * @param v %Train to mark as being stuck.\n */\nstatic void MarkTrainAsStuck(Train* v, bool waiting_restriction = false)\n{\n\tif (!HasBit(v->flags, VRF_TRAIN_STUCK)) {\n\t\t/* It is the first time the problem occurred, set the \"train stuck\" flag. */\n\t\tSetBit(v->flags, VRF_TRAIN_STUCK);\n\t\tSB(v->flags, VRF_WAITING_RESTRICTION, 1, waiting_restriction ? 1 : 0);\n\n\t\tv->wait_counter = 0;\n\n\t\t/* Stop train */\n\t\tv->cur_speed = 0;\n\t\tv->subspeed = 0;\n\t\tv->SetLastSpeed();\n\n\t\tSetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n\t}\n\telse if (waiting_restriction != HasBit(v->flags, VRF_WAITING_RESTRICTION)) {\n\t\tToggleBit(v->flags, VRF_WAITING_RESTRICTION);\n\t\tSetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n\t}\n}\n\n/**\n * Swap the two up/down flags in two ways:\n * - Swap values of \\a swap_flag1 and \\a swap_flag2, and\n * - If going up previously (#GVF_GOINGUP_BIT set), the #GVF_GOINGDOWN_BIT is set, and vice versa.\n * @param[in,out] swap_flag1 First train flag.\n * @param[in,out] swap_flag2 Second train flag.\n */\nstatic void SwapTrainFlags(uint16* swap_flag1, uint16* swap_flag2)\n{\n\tuint16 flag1 = *swap_flag1;\n\tuint16 flag2 = *swap_flag2;\n\n\t/* Clear the flags */\n\tClrBit(*swap_flag1, GVF_GOINGUP_BIT);\n\tClrBit(*swap_flag1, GVF_GOINGDOWN_BIT);\n\tClrBit(*swap_flag1, GVF_CHUNNEL_BIT);\n\tClrBit(*swap_flag2, GVF_GOINGUP_BIT);\n\tClrBit(*swap_flag2, GVF_GOINGDOWN_BIT);\n\tClrBit(*swap_flag2, GVF_CHUNNEL_BIT);\n\n\t/* Reverse the rail-flags (if needed) */\n\tif (HasBit(flag1, GVF_GOINGUP_BIT)) {\n\t\tSetBit(*swap_flag2, GVF_GOINGDOWN_BIT);\n\t}\n\telse if (HasBit(flag1, GVF_GOINGDOWN_BIT)) {\n\t\tSetBit(*swap_flag2, GVF_GOINGUP_BIT);\n\t}\n\tif (HasBit(flag2, GVF_GOINGUP_BIT)) {\n\t\tSetBit(*swap_flag1, GVF_GOINGDOWN_BIT);\n\t}\n\telse if (HasBit(flag2, GVF_GOINGDOWN_BIT)) {\n\t\tSetBit(*swap_flag1, GVF_GOINGUP_BIT);\n\t}\n\tif (HasBit(flag1, GVF_CHUNNEL_BIT)) {\n\t\tSetBit(*swap_flag2, GVF_CHUNNEL_BIT);\n\t}\n\tif (HasBit(flag2, GVF_CHUNNEL_BIT)) {\n\t\tSetBit(*swap_flag1, GVF_CHUNNEL_BIT);\n\t}\n}\n\n/**\n * Updates some variables after swapping the vehicle.\n * @param v swapped vehicle\n */\nstatic void UpdateStatusAfterSwap(Train* v)\n{\n\tv->InvalidateImageCache();\n\n\t/* Reverse the direction. */\n\tif (v->track != TRACK_BIT_DEPOT) v->direction = ReverseDir(v->direction);\n\n\tv->UpdateIsDrawn();\n\n\t/* Call the proper EnterTile function unless we are in a wormhole. */\n\tif (!(v->track & TRACK_BIT_WORMHOLE)) {\n\t\tVehicleEnterTile(v, v->tile, v->x_pos, v->y_pos);\n\t}\n\telse {\n\t\t/* VehicleEnter_TunnelBridge() may set TRACK_BIT_WORMHOLE when the vehicle\n\t\t * is on the last bit of the bridge head (frame == TILE_SIZE - 1).\n\t\t * If we were swapped with such a vehicle, we have set TRACK_BIT_WORMHOLE,\n\t\t * when we shouldn't have. Check if this is the case. */\n\t\tTileIndex vt = TileVirtXY(v->x_pos, v->y_pos);\n\t\tif (IsTileType(vt, MP_TUNNELBRIDGE)) {\n\t\t\tVehicleEnterTile(v, vt, v->x_pos, v->y_pos);\n\t\t\tif (!(v->track & TRACK_BIT_WORMHOLE) && IsBridgeTile(v->tile)) {\n\t\t\t\t/* We have just left the wormhole, possibly set the\n\t\t\t\t * \"goingdown\" bit. UpdateInclination() can be used\n\t\t\t\t * because we are at the border of the tile. */\n\t\t\t\tv->UpdatePosition();\n\t\t\t\tv->UpdateInclination(true, true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tv->UpdatePosition();\n\tif (v->track & TRACK_BIT_WORMHOLE) v->UpdateInclination(false, false, true);\n\tv->UpdateViewport(true, true);\n}\n\n/**\n * Swap vehicles \\a l and \\a r in consist \\a v, and reverse their direction.\n * @param v Consist to change.\n * @param l %Vehicle index in the consist of the first vehicle.\n * @param r %Vehicle index in the consist of the second vehicle.\n */\nvoid ReverseTrainSwapVeh(Train* v, int l, int r)\n{\n\tTrain* a, * b;\n\n\t/* locate vehicles to swap */\n\tfor (a = v; l != 0; l--) a = a->Next();\n\tfor (b = v; r != 0; r--) b = b->Next();\n\n\tif (a != b) {\n\t\t/* swap the hidden bits */\n\t\t{\n\t\t\tuint16 tmp = (a->vehstatus & ~VS_HIDDEN) | (b->vehstatus & VS_HIDDEN);\n\t\t\tb->vehstatus = (b->vehstatus & ~VS_HIDDEN) | (a->vehstatus & VS_HIDDEN);\n\t\t\ta->vehstatus = tmp;\n\t\t}\n\n\t\tSwap(a->track, b->track);\n\t\tSwap(a->direction, b->direction);\n\t\tSwap(a->x_pos, b->x_pos);\n\t\tSwap(a->y_pos, b->y_pos);\n\t\tSwap(a->tile, b->tile);\n\t\tSwap(a->z_pos, b->z_pos);\n\n\t\tSwapTrainFlags(&a->gv_flags, &b->gv_flags);\n\n\t\tUpdateStatusAfterSwap(a);\n\t\tUpdateStatusAfterSwap(b);\n\t}\n\telse {\n\t\t/* Swap GVF_GOINGUP_BIT/GVF_GOINGDOWN_BIT.\n\t\t * This is a little bit redundant way, a->gv_flags will\n\t\t * be (re)set twice, but it reduces code duplication */\n\t\tSwapTrainFlags(&a->gv_flags, &a->gv_flags);\n\t\tUpdateStatusAfterSwap(a);\n\t}\n}\n\n\n/**\n * Check if the vehicle is a train\n * @param v vehicle on tile\n * @return v if it is a train, nullptr otherwise\n */\nstatic Vehicle* TrainOnTileEnum(Vehicle* v, void*)\n{\n\treturn v;\n}\n\n\n/**\n * Checks if a train is approaching a rail-road crossing\n * @param v vehicle on tile\n * @param data tile with crossing we are testing\n * @return v if it is approaching a crossing, nullptr otherwise\n */\nstatic Vehicle* TrainApproachingCrossingEnum(Vehicle* v, void* data)\n{\n\tif ((v->vehstatus & VS_CRASHED)) return nullptr;\n\n\tTrain* t = Train::From(v);\n\tif (!t->IsFrontEngine()) return nullptr;\n\n\tTileIndex tile = (TileIndex) reinterpret_cast<uintptr_t>(data);\n\n\tif (TrainApproachingCrossingTile(t) != tile) return nullptr;\n\n\treturn t;\n}\n\n\n/**\n * Finds a vehicle approaching rail-road crossing\n * @param tile tile to test\n * @return true if a vehicle is approaching the crossing\n * @pre tile is a rail-road crossing\n */\nstatic bool TrainApproachingCrossing(TileIndex tile)\n{\n\tassert_tile(IsLevelCrossingTile(tile), tile);\n\n\tDiagDirection dir = AxisToDiagDir(GetCrossingRailAxis(tile));\n\tTileIndex tile_from = tile + TileOffsByDiagDir(dir);\n\n\tif (HasVehicleOnPos(tile_from, VEH_TRAIN, reinterpret_cast<void*>(tile), &TrainApproachingCrossingEnum)) return true;\n\n\tdir = ReverseDiagDir(dir);\n\ttile_from = tile + TileOffsByDiagDir(dir);\n\n\treturn HasVehicleOnPos(tile_from, VEH_TRAIN, reinterpret_cast<void*>(tile), &TrainApproachingCrossingEnum);\n}\n\n/** Check if the crossing should be closed\n *  @return train on crossing || train approaching crossing || reserved\n */\nstatic inline bool CheckLevelCrossing(TileIndex tile)\n{\n\t/* reserved || train on crossing || train approaching crossing */\n\treturn HasCrossingReservation(tile) || HasVehicleOnPos(tile, VEH_TRAIN, nullptr, &TrainOnTileEnum) || TrainApproachingCrossing(tile);\n}\n\n/**\n * Sets correct crossing state\n * @param tile tile to update\n * @param sound should we play sound?\n * @param is_forced force set the crossing state to that of forced_state\n * @param forced_state the crossing state to set when using is_forced\n * @pre tile is a rail-road crossing\n */\nstatic void UpdateLevelCrossingTile(TileIndex tile, bool sound, bool is_forced, bool forced_state)\n{\n\tassert_tile(IsLevelCrossingTile(tile), tile);\n\tbool new_state;\n\n\tif (is_forced) {\n\t\tnew_state = forced_state;\n\t}\n\telse {\n\t\tnew_state = CheckLevelCrossing(tile);\n\t}\n\n\tif (new_state != IsCrossingBarred(tile)) {\n\t\tif (new_state && sound) {\n\t\t\tif (_settings_client.sound.ambient) SndPlayTileFx(SND_0E_LEVEL_CROSSING, tile);\n\t\t}\n\t\tSetCrossingBarred(tile, new_state);\n\t\tMarkTileDirtyByTile(tile, ZOOM_LVL_DRAW_MAP);\n\t}\n}\n\n/**\n * Cycles the adjacent crossings and sets their state\n * @param tile tile to update\n * @param sound should we play sound?\n * @param force_close force close the crossing\n */\nvoid UpdateLevelCrossing(TileIndex tile, bool sound, bool force_close)\n{\n\tbool forced_state = force_close;\n\tif (!IsLevelCrossingTile(tile)) return;\n\n\tconst Axis axis = GetCrossingRoadAxis(tile);\n\tconst DiagDirection dir = AxisToDiagDir(axis);\n\tconst DiagDirection reverse_dir = ReverseDiagDir(dir);\n\n\tconst bool adjacent_crossings = _settings_game.vehicle.adjacent_crossings;\n\tif (adjacent_crossings) {\n\t\tfor (TileIndex t = tile; !forced_state && IsLevelCrossingTile(t) && GetCrossingRoadAxis(t) == axis; t = TileAddByDiagDir(t, dir)) {\n\t\t\tforced_state |= CheckLevelCrossing(t);\n\t\t}\n\t\tfor (TileIndex t = TileAddByDiagDir(tile, reverse_dir); !forced_state && IsLevelCrossingTile(t) && GetCrossingRoadAxis(t) == axis; t = TileAddByDiagDir(t, reverse_dir)) {\n\t\t\tforced_state |= CheckLevelCrossing(t);\n\t\t}\n\t}\n\n\tUpdateLevelCrossingTile(tile, sound, adjacent_crossings || force_close, forced_state);\n\tfor (TileIndex t = TileAddByDiagDir(tile, dir); IsLevelCrossingTile(t) && GetCrossingRoadAxis(t) == axis; t = TileAddByDiagDir(t, dir)) {\n\t\tUpdateLevelCrossingTile(t, sound, adjacent_crossings, forced_state);\n\t}\n\tfor (TileIndex t = TileAddByDiagDir(tile, reverse_dir); IsLevelCrossingTile(t) && GetCrossingRoadAxis(t) == axis; t = TileAddByDiagDir(t, reverse_dir)) {\n\t\tUpdateLevelCrossingTile(t, sound, adjacent_crossings, forced_state);\n\t}\n}\n\n/**\n * Check if the level crossing is occupied by road vehicle(s).\n * @param t The tile to query.\n * @pre IsLevelCrossing(t)\n * @return True if the level crossing is marked as occupied.\n */\nbool IsCrossingOccupiedByRoadVehicle(TileIndex t)\n{\n\tif (!IsCrossingPossiblyOccupiedByRoadVehicle(t)) return false;\n\tconst bool occupied = EnsureNoRoadVehicleOnGround(t).Failed();\n\tSetCrossingOccupiedByRoadVehicle(t, occupied);\n\treturn occupied;\n}\n\n\n/**\n * Bars crossing and plays ding-ding sound if not barred already\n * @param tile tile with crossing\n * @pre tile is a rail-road crossing\n */\nstatic inline void MaybeBarCrossingWithSound(TileIndex tile)\n{\n\tif (!IsCrossingBarred(tile)) {\n\t\tUpdateLevelCrossing(tile, true, true);\n\t}\n}\n\n\n/**\n * Advances wagons for train reversing, needed for variable length wagons.\n * This one is called before the train is reversed.\n * @param v First vehicle in chain\n */\nstatic void AdvanceWagonsBeforeSwap(Train* v)\n{\n\tTrain* base = v;\n\tTrain* first = base; // first vehicle to move\n\tTrain* last = v->Last(); // last vehicle to move\n\tuint length = CountVehiclesInChain(v);\n\n\twhile (length > 2) {\n\t\tlast = last->Previous();\n\t\tfirst = first->Next();\n\n\t\tint differential = base->CalcNextVehicleOffset() - last->CalcNextVehicleOffset();\n\n\t\t/* do not update images now\n\t\t * negative differential will be handled in AdvanceWagonsAfterSwap() */\n\t\tfor (int i = 0; i < differential; i++) TrainController(first, last->Next());\n\n\t\tbase = first; // == base->Next()\n\t\tlength -= 2;\n\t}\n}\n\n\n/**\n * Advances wagons for train reversing, needed for variable length wagons.\n * This one is called after the train is reversed.\n * @param v First vehicle in chain\n */\nstatic void AdvanceWagonsAfterSwap(Train* v)\n{\n\t/* first of all, fix the situation when the train was entering a depot */\n\tTrain* dep = v; // last vehicle in front of just left depot\n\twhile (dep->Next() != nullptr && (dep->track == TRACK_BIT_DEPOT || dep->Next()->track != TRACK_BIT_DEPOT)) {\n\t\tdep = dep->Next(); // find first vehicle outside of a depot, with next vehicle inside a depot\n\t}\n\n\tTrain* leave = dep->Next(); // first vehicle in a depot we are leaving now\n\n\tif (leave != nullptr) {\n\t\t/* 'pull' next wagon out of the depot, so we won't miss it (it could stay in depot forever) */\n\t\tint d = TicksToLeaveDepot(dep);\n\n\t\tif (d <= 0) {\n\t\t\tleave->vehstatus &= ~VS_HIDDEN; // move it out of the depot\n\t\t\tleave->track = TrackToTrackBits(GetRailDepotTrack(leave->tile));\n\t\t\tfor (int i = 0; i >= d; i--) TrainController(leave, nullptr); // maybe move it, and maybe let another wagon leave\n\t\t}\n\t}\n\telse {\n\t\tdep = nullptr; // no vehicle in a depot, so no vehicle leaving a depot\n\t}\n\n\tTrain* base = v;\n\tTrain* first = base; // first vehicle to move\n\tTrain* last = v->Last(); // last vehicle to move\n\tuint length = CountVehiclesInChain(v);\n\n\t/* We have to make sure all wagons that leave a depot because of train reversing are moved correctly\n\t * they have already correct spacing, so we have to make sure they are moved how they should */\n\tbool nomove = (dep == nullptr); // If there is no vehicle leaving a depot, limit the number of wagons moved immediately.\n\n\twhile (length > 2) {\n\t\t/* we reached vehicle (originally) in front of a depot, stop now\n\t\t * (we would move wagons that are already moved with new wagon length). */\n\t\tif (base == dep) break;\n\n\t\t/* the last wagon was that one leaving a depot, so do not move it anymore */\n\t\tif (last == dep) nomove = true;\n\n\t\tlast = last->Previous();\n\t\tfirst = first->Next();\n\n\t\tint differential = last->CalcNextVehicleOffset() - base->CalcNextVehicleOffset();\n\n\t\t/* do not update images now */\n\t\tfor (int i = 0; i < differential; i++) TrainController(first, (nomove ? last->Next() : nullptr));\n\n\t\tbase = first; // == base->Next()\n\t\tlength -= 2;\n\t}\n}\n\n/**\n * Turn a train around.\n * @param v %Train to turn around.\n */\nvoid ReverseTrainDirection(Train* v)\n{\n\tif (IsRailDepotTile(v->tile)) {\n\t\tInvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);\n\t}\n\n\tif (_local_company == v->owner && (v->current_order.IsType(OT_LOADING_ADVANCE) || HasBit(v->flags, VRF_BEYOND_PLATFORM_END))) {\n\t\tSetDParam(0, v->index);\n\t\tSetDParam(1, v->current_order.GetDestination());\n\t\tAddNewsItem(STR_VEHICLE_LOAD_THROUGH_ABORTED_INSUFFICIENT_TRACK, NT_ADVICE, NF_INCOLOUR | NF_SMALL | NF_VEHICLE_PARAM0,\n\t\t\tNR_VEHICLE, v->index,\n\t\t\tNR_STATION, v->current_order.GetDestination());\n\t}\n\tif (v->current_order.IsType(OT_LOADING_ADVANCE)) {\n\t\tv->LeaveStation();\n\n\t\t/* Only advance to next order if we are loading at the current one */\n\t\tconst Order* order = v->GetOrder(v->cur_implicit_order_index);\n\t\tif (order != nullptr && order->IsType(OT_GOTO_STATION) && order->GetDestination() == v->last_station_visited) {\n\t\t\tv->IncrementImplicitOrderIndex();\n\t\t}\n\t}\n\n\tfor (Train* u = v; u != nullptr; u = u->Next()) {\n\t\tClrBit(u->flags, VRF_BEYOND_PLATFORM_END);\n\t\tClrBit(u->flags, VRF_NOT_YET_IN_PLATFORM);\n\t}\n\n\tv->reverse_distance = 0;\n\n\t/* Clear path reservation in front if train is not stuck. */\n\tif (!HasBit(v->flags, VRF_TRAIN_STUCK)) FreeTrainTrackReservation(v);\n\n\tstd::vector<Train*> re_reserve_trains;\n\t{\n\t\t/* Temporarily clear and restore reservations to bidi tunnel/bridge entrances when reversing train inside,\n\t\t * to avoid outgoing and incoming reservations becoming merged */\n\t\tauto find_train_reservations = [&re_reserve_trains, &v](TileIndex tile) {\n\t\t\tTrackBits reserved = GetAcrossTunnelBridgeReservationTrackBits(tile);\n\t\t\tTrack track;\n\t\t\twhile ((track = RemoveFirstTrack(&reserved)) != INVALID_TRACK) {\n\t\t\t\tTrain* res_train = GetTrainForReservation(tile, track);\n\t\t\t\tif (res_train != nullptr && res_train != v) {\n\t\t\t\t\tFreeTrainTrackReservation(res_train);\n\t\t\t\t\tre_reserve_trains.push_back(res_train);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (IsTunnelBridgeWithSignalSimulation(v->tile) && IsTunnelBridgeSignalSimulationBidirectional(v->tile)) {\n\t\t\tfind_train_reservations(v->tile);\n\t\t\tfind_train_reservations(GetOtherTunnelBridgeEnd(v->tile));\n\t\t}\n\t\tTrain* last = v->Last();\n\t\tif (IsTunnelBridgeWithSignalSimulation(last->tile) && IsTunnelBridgeSignalSimulationBidirectional(last->tile)) {\n\t\t\tfind_train_reservations(last->tile);\n\t\t\tfind_train_reservations(GetOtherTunnelBridgeEnd(last->tile));\n\t\t}\n\t}\n\n\tif ((v->track & TRACK_BIT_WORMHOLE) && IsTunnelBridgeWithSignalSimulation(v->tile)) {\n\t\t/* Clear exit tile reservation if train was on approach to exit and had reserved it */\n\t\tAxis axis = DiagDirToAxis(GetTunnelBridgeDirection(v->tile));\n\t\tDiagDirection axial_dir = DirToDiagDirAlongAxis(v->direction, axis);\n\t\tTileIndex next_tile = TileVirtXY(v->x_pos, v->y_pos) + TileOffsByDiagDir(axial_dir);\n\t\tif (next_tile == v->tile || next_tile == GetOtherTunnelBridgeEnd(v->tile)) {\n\t\t\tTrackdir exit_td = TrackEnterdirToTrackdir(FindFirstTrack(GetAcrossTunnelBridgeTrackBits(next_tile)), ReverseDiagDir(GetTunnelBridgeDirection(next_tile)));\n\t\t\tCFollowTrackRail ft(GetTileOwner(next_tile), GetRailTypeInfo(v->railtype)->compatible_railtypes);\n\t\t\tif (ft.Follow(next_tile, exit_td)) {\n\t\t\t\tTrackdirBits reserved = ft.m_new_td_bits & TrackBitsToTrackdirBits(GetReservedTrackbits(ft.m_new_tile));\n\t\t\t\tif (reserved == TRACKDIR_BIT_NONE) {\n\t\t\t\t\tUnreserveAcrossRailTunnelBridge(next_tile);\n\t\t\t\t\tMarkTileDirtyByTile(next_tile, ZOOM_LVL_DRAW_MAP);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUnreserveAcrossRailTunnelBridge(next_tile);\n\t\t\t\tMarkTileDirtyByTile(next_tile, ZOOM_LVL_DRAW_MAP);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if we were approaching a rail/road-crossing */\n\tTileIndex crossing = TrainApproachingCrossingTile(v);\n\n\t/* count number of vehicles */\n\tint r = CountVehiclesInChain(v) - 1;  // number of vehicles - 1\n\n\tAdvanceWagonsBeforeSwap(v);\n\n\t/* swap start<>end, start+1<>end-1, ... */\n\tint l = 0;\n\tdo {\n\t\tReverseTrainSwapVeh(v, l++, r--);\n\t} while (l <= r);\n\n\tAdvanceWagonsAfterSwap(v);\n\n\tClrBit(v->vcache.cached_veh_flags, VCF_GV_ZERO_SLOPE_RESIST);\n\n\tif (IsRailDepotTile(v->tile)) {\n\t\tInvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);\n\t}\n\n\tToggleBit(v->flags, VRF_TOGGLE_REVERSE);\n\n\tClrBit(v->flags, VRF_REVERSING);\n\n\t/* recalculate cached data */\n\tv->ConsistChanged(CCF_TRACK);\n\n\t/* update all images */\n\tfor (Train* u = v; u != nullptr; u = u->Next()) u->UpdateViewport(false, false);\n\n\t/* update crossing we were approaching */\n\tif (crossing != INVALID_TILE) UpdateLevelCrossing(crossing);\n\n\t/* maybe we are approaching crossing now, after reversal */\n\tcrossing = TrainApproachingCrossingTile(v);\n\tif (crossing != INVALID_TILE) MaybeBarCrossingWithSound(crossing);\n\n\tfor (uint i = 0; i < re_reserve_trains.size(); ++i) {\n\t\tTryPathReserve(re_reserve_trains[i], true);\n\t}\n\n\tif (HasBit(v->flags, VRF_PENDING_SPEED_RESTRICTION)) {\n\t\tauto range = pending_speed_restriction_change_map.equal_range(v->index);\n\t\tfor (auto it = range.first; it != range.second;) {\n\t\t\tit->second.distance = (v->gcache.cached_total_length + (HasBit(it->second.flags, PSRCF_DIAGONAL) ? 8 : 4)) - it->second.distance;\n\t\t\tif (it->second.distance == 0) {\n\t\t\t\tv->speed_restriction = it->second.prev_speed;\n\t\t\t\tit = pending_speed_restriction_change_map.erase(it);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::swap(it->second.prev_speed, it->second.new_speed);\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If we are inside a depot after reversing, don't bother with path reserving. */\n\tif (v->track == TRACK_BIT_DEPOT) {\n\t\t/* Can't be stuck here as inside a depot is always a safe tile. */\n\t\tif (HasBit(v->flags, VRF_TRAIN_STUCK)) SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n\t\tClrBit(v->flags, VRF_TRAIN_STUCK);\n\t\treturn;\n\t}\n\n\t/* We are inside tunnel/bridge with signals, reversing will close the entrance. */\n\tif (IsTunnelBridgeWithSignalSimulation(v->tile) && IsTunnelBridgeSignalSimulationEntrance(v->tile)) {\n\t\t/* Flip signal on tunnel entrance tile red. */\n\t\tSetTunnelBridgeEntranceSignalState(v->tile, SIGNAL_STATE_RED);\n\t\tMarkTileDirtyByTile(v->tile);\n\t\t/* Clear counters. */\n\t\tv->wait_counter = 0;\n\t\tv->tunnel_bridge_signal_num = 0;\n\t\treturn;\n\t}\n\n\t/* VehicleExitDir does not always produce the desired dir for depots and\n\t * tunnels/bridges that is needed for UpdateSignalsOnSegment. */\n\tDiagDirection dir = VehicleExitDir(v->direction, v->track);\n\tif (IsRailDepotTile(v->tile) || (IsTileType(v->tile, MP_TUNNELBRIDGE) && (v->track & TRACK_BIT_WORMHOLE || dir == GetTunnelBridgeDirection(v->tile)))) dir = INVALID_DIAGDIR;\n\n\tif (UpdateSignalsOnSegment(v->tile, dir, v->owner) == SIGSEG_PBS || _settings_game.pf.reserve_paths) {\n\t\t/* If we are currently on a tile with conventional signals, we can't treat the\n\t\t * current tile as a safe tile or we would enter a PBS block without a reservation. */\n\t\tbool first_tile_okay = !(IsTileType(v->tile, MP_RAILWAY) &&\n\t\t\tHasSignalOnTrackdir(v->tile, v->GetVehicleTrackdir()) &&\n\t\t\t!IsPbsSignal(GetSignalType(v->tile, FindFirstTrack(v->track))));\n\n\t\t/* If we are on a depot tile facing outwards, do not treat the current tile as safe. */\n\t\tif (IsRailDepotTile(v->tile) && TrackdirToExitdir(v->GetVehicleTrackdir()) == GetRailDepotDirection(v->tile)) first_tile_okay = false;\n\n\t\tif (IsRailStationTile(v->tile)) SetRailStationPlatformReservation(v->tile, TrackdirToExitdir(v->GetVehicleTrackdir()), true);\n\t\tif (TryPathReserve(v, false, first_tile_okay)) {\n\t\t\t/* Do a look-ahead now in case our current tile was already a safe tile. */\n\t\t\tCheckNextTrainTile(v);\n\t\t}\n\t\telse if (v->current_order.GetType() != OT_LOADING) {\n\t\t\t/* Do not wait for a way out when we're still loading */\n\t\t\tMarkTrainAsStuck(v);\n\t\t}\n\t}\n\telse if (HasBit(v->flags, VRF_TRAIN_STUCK)) {\n\t\t/* A train not inside a PBS block can't be stuck. */\n\t\tClrBit(v->flags, VRF_TRAIN_STUCK);\n\t\tv->wait_counter = 0;\n\t}\n}\n\n/**\n * Reverse train.\n * @param tile unused\n * @param flags type of operation\n * @param p1 train to reverse\n * @param p2 if true, reverse a unit in a train (needs to be in a depot)\n * @param text unused\n * @return the cost of this operation or an error\n */\nCommandCost CmdReverseTrainDirection(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char* text)\n{\n\tTrain* v = Train::GetIfValid(p1);\n\tif (v == nullptr) return CMD_ERROR;\n\n\tCommandCost ret = CheckOwnership(v->owner);\n\tif (ret.Failed()) return ret;\n\n\tif (p2 != 0) {\n\t\t/* turn a single unit around */\n\n\t\tif (v->IsMultiheaded() || HasBit(EngInfo(v->engine_type)->callback_mask, CBM_VEHICLE_ARTIC_ENGINE)) {\n\t\t\treturn_cmd_error(STR_ERROR_CAN_T_REVERSE_DIRECTION_RAIL_VEHICLE_MULTIPLE_UNITS);\n\t\t}\n\t\tif (!HasBit(EngInfo(v->engine_type)->misc_flags, EF_RAIL_FLIPS) && !_settings_game.vehicle.flip_direction_all_trains) return CMD_ERROR;\n\n\t\tTrain* front = v->First();\n\t\t/* make sure the vehicle is stopped in the depot */\n\t\tif (!front->IsStoppedInDepot()) {\n\t\t\treturn_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);\n\t\t}\n\n\t\tif (flags & DC_EXEC) {\n\t\t\tToggleBit(v->flags, VRF_REVERSE_DIRECTION);\n\n\t\t\tfront->ConsistChanged(CCF_ARRANGE);\n\t\t\tSetWindowDirty(WC_VEHICLE_DEPOT, front->tile);\n\t\t\tSetWindowDirty(WC_VEHICLE_DETAILS, front->index);\n\t\t\tSetWindowDirty(WC_VEHICLE_VIEW, front->index);\n\t\t\tSetWindowClassesDirty(WC_TRAINS_LIST);\n\t\t\tSetWindowClassesDirty(WC_TRACE_RESTRICT_SLOTS);\n\t\t}\n\t}\n\telse {\n\t\t/* turn the whole train around */\n\t\tif ((v->vehstatus & VS_CRASHED) || HasBit(v->flags, VRF_BREAKDOWN_STOPPED)) return CMD_ERROR;\n\n\t\tif (flags & DC_EXEC) {\n\t\t\t/* Properly leave the station if we are loading and won't be loading anymore */\n\t\t\tif (v->current_order.IsAnyLoadingType()) {\n\t\t\t\tconst Vehicle* last = v;\n\t\t\t\twhile (last->Next() != nullptr) last = last->Next();\n\n\t\t\t\t/* not a station || different station --> leave the station */\n\t\t\t\tif (!IsTileType(last->tile, MP_STATION) || !IsTileType(v->tile, MP_STATION) ||\n\t\t\t\t\tGetStationIndex(last->tile) != GetStationIndex(v->tile) ||\n\t\t\t\t\tHasBit(v->flags, VRF_BEYOND_PLATFORM_END) ||\n\t\t\t\t\tv->current_order.IsType(OT_LOADING_ADVANCE)) {\n\t\t\t\t\tv->LeaveStation();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* We cancel any 'skip signal at dangers' here */\n\t\t\tv->force_proceed = TFP_NONE;\n\t\t\tSetWindowDirty(WC_VEHICLE_VIEW, v->index);\n\n\t\t\tif (_settings_game.vehicle.train_acceleration_model != AM_ORIGINAL && v->cur_speed != 0) {\n\t\t\t\tToggleBit(v->flags, VRF_REVERSING);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv->cur_speed = 0;\n\t\t\t\tv->SetLastSpeed();\n\t\t\t\tHideFillingPercent(&v->fill_percent_te_id);\n\t\t\t\tReverseTrainDirection(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn CommandCost();\n}\n\n/**\n * Force a train through a red signal\n * @param tile unused\n * @param flags type of operation\n * @param p1 train to ignore the red signal\n * @param p2 unused\n * @param text unused\n * @return the cost of this operation or an error\n */\nCommandCost CmdForceTrainProceed(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char* text)\n{\n\tTrain* t = Train::GetIfValid(p1);\n\tif (t == nullptr) return CMD_ERROR;\n\n\tif (!t->IsPrimaryVehicle()) return CMD_ERROR;\n\n\tCommandCost ret = CheckVehicleControlAllowed(t);\n\tif (ret.Failed()) return ret;\n\n\n\tif (flags & DC_EXEC) {\n\t\t/* If we are forced to proceed, cancel that order.\n\t\t * If we are marked stuck we would want to force the train\n\t\t * to proceed to the next signal. In the other cases we\n\t\t * would like to pass the signal at danger and run till the\n\t\t * next signal we encounter. */\n\t\tt->force_proceed = t->force_proceed == TFP_SIGNAL ? TFP_NONE : HasBit(t->flags, VRF_TRAIN_STUCK) || t->IsChainInDepot() ? TFP_STUCK : TFP_SIGNAL;\n\t\tSetWindowDirty(WC_VEHICLE_VIEW, t->index);\n\t}\n\n\treturn CommandCost();\n}\n\n/**\n * Try to find a depot nearby.\n * @param v %Train that wants a depot.\n * @param max_distance Maximal search distance.\n * @return Information where the closest train depot is located.\n * @pre The given vehicle must not be crashed!\n */\nstatic FindDepotData FindClosestTrainDepot(Train* v, int max_distance)\n{\n\tassert(!(v->vehstatus & VS_CRASHED));\n\n\tif (IsRailDepotTile(v->tile)) return FindDepotData(v->tile, 0);\n\n\tPBSTileInfo origin = FollowTrainReservation(v);\n\tif (IsRailDepotTile(origin.tile)) return FindDepotData(origin.tile, 0);\n\n\tswitch (_settings_game.pf.pathfinder_for_trains) {\n\tcase VPF_NPF: return NPFTrainFindNearestDepot(v, max_distance);\n\tcase VPF_YAPF: return YapfTrainFindNearestDepot(v, max_distance);\n\n\tdefault: NOT_REACHED();\n\t}\n}\n\n/**\n * Locate the closest depot for this consist, and return the information to the caller.\n * @param[out] location    If not \\c nullptr and a depot is found, store its location in the given address.\n * @param[out] destination If not \\c nullptr and a depot is found, store its index in the given address.\n * @param[out] reverse     If not \\c nullptr and a depot is found, store reversal information in the given address.\n * @return A depot has been found.\n */\nbool Train::FindClosestDepot(TileIndex* location, DestinationID* destination, bool* reverse)\n{\n\tFindDepotData tfdd = FindClosestTrainDepot(this, 0);\n\tif (tfdd.best_length == UINT_MAX) return false;\n\n\tif (location != nullptr) *location = tfdd.tile;\n\tif (destination != nullptr) *destination = GetDepotIndex(tfdd.tile);\n\tif (reverse != nullptr) *reverse = tfdd.reverse;\n\n\treturn true;\n}\n\n/** Play a sound for a train leaving the station. */\nvoid Train::PlayLeaveStationSound() const\n{\n\tstatic const SoundFx sfx[] = {\n\t\tSND_04_TRAIN,\n\t\tSND_0A_TRAIN_HORN,\n\t\tSND_0A_TRAIN_HORN,\n\t\tSND_47_MAGLEV_2,\n\t\tSND_41_MAGLEV\n\t};\n\n\tif (PlayVehicleSound(this, VSE_START)) return;\n\n\tEngineID engtype = this->engine_type;\n\tSndPlayVehicleFx(sfx[RailVehInfo(engtype)->engclass], this);\n}\n\n/**\n * Check if the train is on the last reserved tile and try to extend the path then.\n * @param v %Train that needs its path extended.\n */\nstatic void CheckNextTrainTile(Train* v)\n{\n\t/* Don't do any look-ahead if path_backoff_interval is 255. */\n\tif (_settings_game.pf.path_backoff_interval == 255) return;\n\n\t/* Exit if we are inside a depot. */\n\tif (v->track == TRACK_BIT_DEPOT) return;\n\n\t/* Exit if we are on a station tile and are going to stop. */\n\tif (HasStationTileRail(v->tile) && v->current_order.ShouldStopAtStation(v, GetStationIndex(v->tile), IsRailWaypoint(v->tile))) return;\n\n\tswitch (v->current_order.GetType()) {\n\t\t/* Exit if we reached our destination depot. */\n\tcase OT_GOTO_DEPOT:\n\t\tif (v->tile == v->dest_tile) return;\n\t\tbreak;\n\n\tcase OT_GOTO_WAYPOINT:\n\t\t/* If we reached our waypoint, make sure we see that. */\n\t\tif (IsRailWaypointTile(v->tile) && GetStationIndex(v->tile) == v->current_order.GetDestination()) ProcessOrders(v);\n\t\tbreak;\n\n\tcase OT_NOTHING:\n\tcase OT_LEAVESTATION:\n\tcase OT_LOADING:\n\t\t/* Exit if the current order doesn't have a destination, but the train has orders. */\n\t\tif (v->GetNumOrders() > 0) return;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tTrackdir td = v->GetVehicleTrackdir();\n\n\t/* On a tile with a red non-pbs signal, don't look ahead. */\n\tif (IsTileType(v->tile, MP_RAILWAY) && HasSignalOnTrackdir(v->tile, td) &&\n\t\t!IsPbsSignal(GetSignalType(v->tile, TrackdirToTrack(td))) &&\n\t\tGetSignalStateByTrackdir(v->tile, td) == SIGNAL_STATE_RED) return;\n\n\tCFollowTrackRail ft(v);\n\tif (!ft.Follow(v->tile, td)) return;\n\n\tif (!HasReservedTracks(ft.m_new_tile, TrackdirBitsToTrackBits(ft.m_new_td_bits))) {\n\t\t/* Next tile is not reserved. */\n\t\tif (KillFirstBit(ft.m_new_td_bits) == TRACKDIR_BIT_NONE) {\n\t\t\tif (HasPbsSignalOnTrackdir(ft.m_new_tile, FindFirstTrackdir(ft.m_new_td_bits))) {\n\t\t\t\t/* If the next tile is a PBS signal, try to make a reservation. */\n\t\t\t\tTrackBits tracks = TrackdirBitsToTrackBits(ft.m_new_td_bits);\n\t\t\t\tif (ft.m_tiles_skipped == 0 && Rail90DegTurnDisallowedTilesFromTrackdir(ft.m_old_tile, ft.m_new_tile, ft.m_old_td)) {\n\t\t\t\t\ttracks &= ~TrackCrossesTracks(TrackdirToTrack(ft.m_old_td));\n\t\t\t\t}\n\t\t\t\tChooseTrainTrack(v, ft.m_new_tile, ft.m_exitdir, tracks, false, nullptr, false);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Will the train stay in the depot the next tick?\n * @param v %Train to check.\n * @return True if it stays in the depot, false otherwise.\n */\nstatic bool CheckTrainStayInDepot(Train* v)\n{\n\t/* bail out if not all wagons are in the same depot or not in a depot at all */\n\tfor (const Train* u = v; u != nullptr; u = u->Next()) {\n\t\tif (u->track != TRACK_BIT_DEPOT || u->tile != v->tile) return false;\n\t}\n\n\t/* if the train got no power, then keep it in the depot */\n\tif (v->gcache.cached_power == 0) {\n\t\tv->vehstatus |= VS_STOPPED;\n\t\tSetWindowDirty(WC_VEHICLE_DEPOT, v->tile);\n\t\treturn true;\n\t}\n\n\tif (v->current_order.IsWaitTimetabled()) {\n\t\tv->HandleWaiting(false);\n\t}\n\tif (v->current_order.IsType(OT_WAITING)) {\n\t\treturn true;\n\t}\n\n\tSigSegState seg_state;\n\n\tif (v->force_proceed == TFP_NONE) {\n\t\t/* force proceed was not pressed */\n\t\tif (++v->wait_counter < 37) {\n\t\t\tSetWindowClassesDirty(WC_TRAINS_LIST);\n\t\t\tSetWindowClassesDirty(WC_TRACE_RESTRICT_SLOTS);\n\t\t\treturn true;\n\t\t}\n\n\t\tv->wait_counter = 0;\n\n\t\tseg_state = _settings_game.pf.reserve_paths ? SIGSEG_PBS : UpdateSignalsOnSegment(v->tile, INVALID_DIAGDIR, v->owner);\n\t\tif (seg_state == SIGSEG_FULL || HasDepotReservation(v->tile)) {\n\t\t\t/* Full and no PBS signal in block or depot reserved, can't exit. */\n\t\t\tSetWindowClassesDirty(WC_TRAINS_LIST);\n\t\t\tSetWindowClassesDirty(WC_TRACE_RESTRICT_SLOTS);\n\t\t\treturn true;\n\t\t}\n\t}\n\telse {\n\t\tseg_state = _settings_game.pf.reserve_paths ? SIGSEG_PBS : UpdateSignalsOnSegment(v->tile, INVALID_DIAGDIR, v->owner);\n\t}\n\n\t/* We are leaving a depot, but have to go to the exact same one; re-enter. */\n\tif (v->current_order.IsType(OT_GOTO_DEPOT) && v->tile == v->dest_tile) {\n\t\t/* Service when depot has no reservation. */\n\t\tif (!HasDepotReservation(v->tile)) VehicleEnterDepot(v);\n\t\treturn true;\n\t}\n\n\t/* Only leave when we can reserve a path to our destination. */\n\tif (seg_state == SIGSEG_PBS && !TryPathReserve(v) && v->force_proceed == TFP_NONE) {\n\t\t/* No path and no force proceed. */\n\t\tSetWindowClassesDirty(WC_TRAINS_LIST);\n\t\tSetWindowClassesDirty(WC_TRACE_RESTRICT_SLOTS);\n\t\tMarkTrainAsStuck(v);\n\t\treturn true;\n\t}\n\n\tSetDepotReservation(v->tile, true);\n\tif (_settings_client.gui.show_track_reservation) MarkTileDirtyByTile(v->tile, ZOOM_LVL_DRAW_MAP);\n\n\tVehicleServiceInDepot(v);\n\tSetWindowClassesDirty(WC_TRAINS_LIST);\n\tSetWindowClassesDirty(WC_TRACE_RESTRICT_SLOTS);\n\tv->PlayLeaveStationSound();\n\n\tv->track = TRACK_BIT_X;\n\tif (v->direction & 2) v->track = TRACK_BIT_Y;\n\n\tv->vehstatus &= ~VS_HIDDEN;\n\tv->UpdateIsDrawn();\n\tv->cur_speed = 0;\n\n\tv->UpdateViewport(true, true);\n\tv->UpdatePosition();\n\tUpdateSignalsOnSegment(v->tile, INVALID_DIAGDIR, v->owner);\n\tv->UpdateAcceleration();\n\tInvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);\n\n\treturn false;\n}\n\nstatic int GetAndClearLastBridgeEntranceSetSignalIndex(TileIndex bridge_entrance)\n{\n\tuint16 m = _m[bridge_entrance].m2;\n\tif (m & BRIDGE_M2_SIGNAL_STATE_EXT_FLAG) {\n\t\tauto it = _long_bridge_signal_sim_map.find(bridge_entrance);\n\t\tif (it != _long_bridge_signal_sim_map.end()) {\n\t\t\tLongBridgeSignalStorage& lbss = it->second;\n\t\t\tsize_t slot = lbss.signal_red_bits.size();\n\t\t\twhile (slot > 0) {\n\t\t\t\tslot--;\n\t\t\t\tuint64& slot_bits = lbss.signal_red_bits[slot];\n\t\t\t\tif (slot_bits) {\n\t\t\t\t\tuint8 i = FindLastBit(slot_bits);\n\t\t\t\t\tClrBit(slot_bits, i);\n\t\t\t\t\treturn 1 + BRIDGE_M2_SIGNAL_STATE_COUNT + (64 * slot) + i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuint16 m_masked = GB(m & (~BRIDGE_M2_SIGNAL_STATE_EXT_FLAG), BRIDGE_M2_SIGNAL_STATE_OFFSET, BRIDGE_M2_SIGNAL_STATE_FIELD_SIZE);\n\tif (m_masked) {\n\t\tuint8 i = FindLastBit(m_masked);\n\t\tClrBit(_m[bridge_entrance].m2, BRIDGE_M2_SIGNAL_STATE_OFFSET + i);\n\t\treturn 1 + i;\n\t}\n\n\treturn 0;\n}\n\nstatic void HandleLastTunnelBridgeSignals(TileIndex tile, TileIndex end, DiagDirection dir, bool free)\n{\n\tif (IsBridge(end) && _m[end].m2 != 0) {\n\t\t/* Clearing last bridge signal. */\n\t\tint signal_offset = GetAndClearLastBridgeEntranceSetSignalIndex(end);\n\t\tif (signal_offset) {\n\t\t\tTileIndex last_signal_tile = end + (TileOffsByDiagDir(dir) * _settings_game.construction.simulated_wormhole_signals * signal_offset);\n\t\t\tMarkTileDirtyByTile(last_signal_tile);\n\t\t}\n\t\tMarkTileDirtyByTile(tile);\n\t}\n\tif (free) {\n\t\t/* Open up the wormhole and clear m2. */\n\t\tif (IsBridge(end)) {\n\t\t\tif (IsTunnelBridgeSignalSimulationEntrance(tile)) SetAllBridgeEntranceSimulatedSignalsGreen(tile);\n\t\t\tif (IsTunnelBridgeSignalSimulationEntrance(end)) SetAllBridgeEntranceSimulatedSignalsGreen(end);\n\t\t}\n\n\t\tif (IsTunnelBridgeSignalSimulationEntrance(end) && GetTunnelBridgeEntranceSignalState(end) == SIGNAL_STATE_RED) {\n\t\t\tSetTunnelBridgeEntranceSignalState(end, SIGNAL_STATE_GREEN);\n\t\t\tMarkTileDirtyByTile(end);\n\t\t}\n\t\tif (IsTunnelBridgeSignalSimulationEntrance(tile) && GetTunnelBridgeEntranceSignalState(tile) == SIGNAL_STATE_RED) {\n\t\t\tSetTunnelBridgeEntranceSignalState(tile, SIGNAL_STATE_GREEN);\n\t\t\tMarkTileDirtyByTile(tile);\n\t\t}\n\t}\n}\n\nstatic void UnreserveBridgeTunnelTile(TileIndex tile)\n{\n\tUnreserveAcrossRailTunnelBridge(tile);\n\tif (IsTunnelBridgeSignalSimulationExit(tile) && IsTunnelBridgePBS(tile)) SetTunnelBridgeExitSignalState(tile, SIGNAL_STATE_RED);\n}\n\n/**\n * Clear the reservation of \\a tile that was just left by a wagon on \\a track_dir.\n * @param v %Train owning the reservation.\n * @param tile Tile with reservation to clear.\n * @param track_dir Track direction to clear.\n * @param tunbridge_clear_unsignaled_other_end Whether to clear the far end of unsignalled tunnels/bridges.\n */\nstatic void ClearPathReservation(const Train* v, TileIndex tile, Trackdir track_dir, bool tunbridge_clear_unsignaled_other_end = false)\n{\n\tif (IsTileType(tile, MP_TUNNELBRIDGE)) {\n\t\tif (IsTrackAcrossTunnelBridge(tile, TrackdirToTrack(track_dir))) {\n\t\t\tUnreserveBridgeTunnelTile(tile);\n\n\t\t\tif (IsTunnelBridgeWithSignalSimulation(tile)) {\n\t\t\t\t/* Are we just leaving a tunnel/bridge? */\n\t\t\t\tif (TrackdirExitsTunnelBridge(tile, track_dir)) {\n\t\t\t\t\tTileIndex end = GetOtherTunnelBridgeEnd(tile);\n\t\t\t\t\tbool free = TunnelBridgeIsFree(tile, end, v, true).Succeeded();\n\t\t\t\t\tHandleLastTunnelBridgeSignals(tile, end, ReverseDiagDir(GetTunnelBridgeDirection(tile)), free);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tunbridge_clear_unsignaled_other_end) {\n\t\t\t\tTileIndex end = GetOtherTunnelBridgeEnd(tile);\n\t\t\t\tUnreserveAcrossRailTunnelBridge(end);\n\t\t\t\tif (_settings_client.gui.show_track_reservation) {\n\t\t\t\t\tMarkTileDirtyByTile(end, ZOOM_LVL_DRAW_MAP);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_settings_client.gui.show_track_reservation) {\n\t\t\t\tMarkBridgeOrTunnelDirtyOnReservationChange(tile, ZOOM_LVL_DRAW_MAP);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tUnreserveRailTrack(tile, TrackdirToTrack(track_dir));\n\t\t\tif (_settings_client.gui.show_track_reservation) {\n\t\t\t\tMarkTileDirtyByTile(tile, ZOOM_LVL_DRAW_MAP);\n\t\t\t}\n\t\t}\n\t}\n\telse if (IsRailStationTile(tile)) {\n\t\tDiagDirection dir = TrackdirToExitdir(track_dir);\n\t\tTileIndex new_tile = TileAddByDiagDir(tile, dir);\n\t\t/* If the new tile is not a further tile of the same station, we\n\t\t * clear the reservation for the whole platform. */\n\t\tif (!IsCompatibleTrainStationTile(new_tile, tile)) {\n\t\t\tSetRailStationPlatformReservation(tile, ReverseDiagDir(dir), false);\n\t\t}\n\t}\n\telse {\n\t\t/* Any other tile */\n\t\tUnreserveRailTrack(tile, TrackdirToTrack(track_dir));\n\t}\n}\n\n/**\n * Free the reserved path in front of a vehicle.\n * @param v %Train owning the reserved path.\n * @param origin %Tile to start clearing (if #INVALID_TILE, use the current tile of \\a v).\n * @param orig_td Track direction (if #INVALID_TRACKDIR, use the track direction of \\a v).\n */\nvoid FreeTrainTrackReservation(const Train* v, TileIndex origin, Trackdir orig_td)\n{\n\tassert(v->IsFrontEngine());\n\n\tTileIndex tile = origin != INVALID_TILE ? origin : v->tile;\n\tTrackdir  td = orig_td != INVALID_TRACKDIR ? orig_td : v->GetVehicleTrackdir();\n\tbool      free_tile = tile != v->tile || !(IsRailStationTile(v->tile) || IsTileType(v->tile, MP_TUNNELBRIDGE));\n\tStationID station_id = IsRailStationTile(v->tile) ? GetStationIndex(v->tile) : INVALID_STATION;\n\n\t/* Can't be holding a reservation if we enter a depot. */\n\tif (IsRailDepotTile(tile) && TrackdirToExitdir(td) != GetRailDepotDirection(tile)) return;\n\tif (v->track == TRACK_BIT_DEPOT) {\n\t\t/* Front engine is in a depot. We enter if some part is not in the depot. */\n\t\tfor (const Train* u = v; u != nullptr; u = u->Next()) {\n\t\t\tif (u->track != TRACK_BIT_DEPOT || u->tile != v->tile) return;\n\t\t}\n\t}\n\t/* Don't free reservation if it's not ours. */\n\tif (TracksOverlap(GetReservedTrackbits(tile) | TrackToTrackBits(TrackdirToTrack(td)))) return;\n\n\t/* Do not attempt to unreserve out of a signalled tunnel/bridge entrance, as this would unreserve the reservations of another train coming in */\n\tif (IsTunnelBridgeWithSignalSimulation(tile) && TrackdirExitsTunnelBridge(tile, td) && IsTunnelBridgeSignalSimulationEntranceOnly(tile)) return;\n\n\tCFollowTrackRail ft(v, GetRailTypeInfo(v->railtype)->compatible_railtypes);\n\twhile (ft.Follow(tile, td)) {\n\t\ttile = ft.m_new_tile;\n\t\tTrackdirBits bits = ft.m_new_td_bits & TrackBitsToTrackdirBits(GetReservedTrackbits(tile));\n\t\ttd = RemoveFirstTrackdir(&bits);\n\t\tassert(bits == TRACKDIR_BIT_NONE);\n\n\t\tif (!IsValidTrackdir(td)) break;\n\n\t\tif (IsTileType(tile, MP_RAILWAY)) {\n\t\t\tif (HasSignalOnTrackdir(tile, td) && !IsPbsSignal(GetSignalType(tile, TrackdirToTrack(td)))) {\n\t\t\t\t/* Conventional signal along trackdir: remove reservation and stop. */\n\t\t\t\tUnreserveRailTrack(tile, TrackdirToTrack(td));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (HasPbsSignalOnTrackdir(tile, td)) {\n\t\t\t\tif (GetSignalStateByTrackdir(tile, td) == SIGNAL_STATE_RED) {\n\t\t\t\t\t/* Red PBS signal? Can't be our reservation, would be green then. */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* Turn the signal back to red. */\n\t\t\t\t\tSetSignalStateByTrackdir(tile, td, SIGNAL_STATE_RED);\n\t\t\t\t\tMarkSingleSignalDirty(tile, td);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (HasSignalOnTrackdir(tile, ReverseTrackdir(td)) && IsOnewaySignal(tile, TrackdirToTrack(td))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (IsTunnelBridgeWithSignalSimulation(tile) && TrackdirExitsTunnelBridge(tile, td)) {\n\t\t\tTileIndex end = GetOtherTunnelBridgeEnd(tile);\n\t\t\tbool free = TunnelBridgeIsFree(tile, end, v, true).Succeeded();\n\t\t\tif (!free) break;\n\t\t}\n\n\t\t/* Don't free first station/bridge/tunnel if we are on it. */\n\t\tif (free_tile || (!(ft.m_is_station && GetStationIndex(ft.m_new_tile) == station_id) && !ft.m_is_tunnel && !ft.m_is_bridge)) ClearPathReservation(v, tile, td);\n\n\t\tfree_tile = true;\n\t}\n}\n\nstatic const byte _initial_tile_subcoord[6][4][3] = {\n{{ 15, 8, 1 }, { 0, 0, 0 }, { 0, 8, 5 }, { 0,  0, 0 }},\n{{  0, 0, 0 }, { 8, 0, 3 }, { 0, 0, 0 }, { 8, 15, 7 }},\n{{  0, 0, 0 }, { 7, 0, 2 }, { 0, 7, 6 }, { 0,  0, 0 }},\n{{ 15, 8, 2 }, { 0, 0, 0 }, { 0, 0, 0 }, { 8, 15, 6 }},\n{{ 15, 7, 0 }, { 8, 0, 4 }, { 0, 0, 0 }, { 0,  0, 0 }},\n{{  0, 0, 0 }, { 0, 0, 0 }, { 0, 8, 4 }, { 7, 15, 0 }},\n};\n\n/**\n * Perform pathfinding for a train.\n *\n * @param v The train\n * @param tile The tile the train is about to enter\n * @param enterdir Diagonal direction the train is coming from\n * @param tracks Usable tracks on the new tile\n * @param[out] path_found Whether a path has been found or not.\n * @param do_track_reservation Path reservation is requested\n * @param[out] dest State and destination of the requested path\n * @return The best track the train should follow\n */\nstatic Track DoTrainPathfind(const Train* v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool& path_found, bool do_track_reservation, PBSTileInfo* dest)\n{\n\tswitch (_settings_game.pf.pathfinder_for_trains) {\n\tcase VPF_NPF: return NPFTrainChooseTrack(v, path_found, do_track_reservation, dest);\n\tcase VPF_YAPF: return YapfTrainChooseTrack(v, tile, enterdir, tracks, path_found, do_track_reservation, dest);\n\n\tdefault: NOT_REACHED();\n\t}\n}\n\n/**\n * Extend a train path as far as possible. Stops on encountering a safe tile,\n * another reservation or a track choice.\n * @param v The train.\n * @param origin The tile from which the reservation have to be extended\n * @param new_tracks [out] Tracks to choose from when encountering a choice\n * @param enterdir [out] The direction from which the choice tile is to be entered\n * @return INVALID_TILE indicates that the reservation failed.\n */\nstatic PBSTileInfo ExtendTrainReservation(const Train* v, const PBSTileInfo& origin, TrackBits* new_tracks, DiagDirection* enterdir)\n{\n\tCFollowTrackRail ft(v);\n\n\tTileIndex tile = origin.tile;\n\tTrackdir  cur_td = origin.trackdir;\n\twhile (ft.Follow(tile, cur_td)) {\n\t\tif (KillFirstBit(ft.m_new_td_bits) == TRACKDIR_BIT_NONE) {\n\t\t\t/* Possible signal tile. */\n\t\t\tif (HasOnewaySignalBlockingTrackdir(ft.m_new_tile, FindFirstTrackdir(ft.m_new_td_bits))) break;\n\t\t}\n\n\t\tif (ft.m_tiles_skipped == 0 && Rail90DegTurnDisallowedTilesFromTrackdir(ft.m_old_tile, ft.m_new_tile, ft.m_old_td)) {\n\t\t\tft.m_new_td_bits &= ~TrackdirCrossesTrackdirs(ft.m_old_td);\n\t\t\tif (ft.m_new_td_bits == TRACKDIR_BIT_NONE) break;\n\t\t}\n\n\t\t/* Station, depot or waypoint are a possible target. */\n\t\tbool target_seen = ft.m_is_station || (IsTileType(ft.m_new_tile, MP_RAILWAY) && !IsPlainRail(ft.m_new_tile));\n\t\tif (target_seen || KillFirstBit(ft.m_new_td_bits) != TRACKDIR_BIT_NONE) {\n\t\t\t/* Choice found or possible target encountered.\n\t\t\t * On finding a possible target, we need to stop and let the pathfinder handle the\n\t\t\t * remaining path. This is because we don't know if this target is in one of our\n\t\t\t * orders, so we might cause pathfinding to fail later on if we find a choice.\n\t\t\t * This failure would cause a bogous call to TryReserveSafePath which might reserve\n\t\t\t * a wrong path not leading to our next destination. */\n\t\t\tif (HasReservedTracks(ft.m_new_tile, TrackdirBitsToTrackBits(TrackdirReachesTrackdirs(ft.m_old_td)))) break;\n\n\t\t\t/* If we did skip some tiles, backtrack to the first skipped tile so the pathfinder\n\t\t\t * actually starts its search at the first unreserved tile. */\n\t\t\tif (ft.m_tiles_skipped != 0) ft.m_new_tile -= TileOffsByDiagDir(ft.m_exitdir) * ft.m_tiles_skipped;\n\n\t\t\t/* Choice found, path valid but not okay. Save info about the choice tile as well. */\n\t\t\tif (new_tracks != nullptr) *new_tracks = TrackdirBitsToTrackBits(ft.m_new_td_bits);\n\t\t\tif (enterdir != nullptr) *enterdir = ft.m_exitdir;\n\t\t\treturn PBSTileInfo(ft.m_new_tile, ft.m_old_td, false);\n\t\t}\n\n\t\ttile = ft.m_new_tile;\n\t\tcur_td = FindFirstTrackdir(ft.m_new_td_bits);\n\n\t\tif (IsSafeWaitingPosition(v, tile, cur_td, true, _settings_game.pf.forbid_90_deg)) {\n\t\t\tPBSWaitingPositionRestrictedSignalInfo restricted_signal_info;\n\t\t\tbool wp_free = IsWaitingPositionFree(v, tile, cur_td, _settings_game.pf.forbid_90_deg, &restricted_signal_info);\n\t\t\tif (!(wp_free && TryReserveRailTrack(tile, TrackdirToTrack(cur_td)))) break;\n\t\t\t/* Safe position is all good, path valid and okay. */\n\t\t\tif (restricted_signal_info.tile != INVALID_TILE) {\n\t\t\t\tconst TraceRestrictProgram* prog = GetExistingTraceRestrictProgram(restricted_signal_info.tile, TrackdirToTrack(restricted_signal_info.trackdir));\n\t\t\t\tif (prog && prog->actions_used_flags & TRPAUF_PBS_RES_END_SLOT) {\n\t\t\t\t\tTraceRestrictProgramResult out;\n\t\t\t\t\tTraceRestrictProgramInput input(restricted_signal_info.tile, restricted_signal_info.trackdir, &VehiclePosTraceRestrictPreviousSignalCallback, nullptr);\n\t\t\t\t\tinput.permitted_slot_operations = TRPISP_PBS_RES_END_ACQUIRE | TRPISP_PBS_RES_END_RELEASE;\n\t\t\t\t\tprog->Execute(v, input, out);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn PBSTileInfo(tile, cur_td, true);\n\t\t}\n\n\t\tif (!TryReserveRailTrackdir(tile, cur_td)) break;\n\t}\n\n\tif (ft.m_err == CFollowTrackRail::EC_OWNER || ft.m_err == CFollowTrackRail::EC_NO_WAY) {\n\t\t/* End of line, path valid and okay. */\n\t\treturn PBSTileInfo(ft.m_old_tile, ft.m_old_td, true);\n\t}\n\n\t/* Sorry, can't reserve path, back out. */\n\ttile = origin.tile;\n\tcur_td = origin.trackdir;\n\tTileIndex stopped = ft.m_old_tile;\n\tTrackdir  stopped_td = ft.m_old_td;\n\twhile (tile != stopped || cur_td != stopped_td) {\n\t\tif (!ft.Follow(tile, cur_td)) break;\n\n\t\tif (ft.m_tiles_skipped == 0 && Rail90DegTurnDisallowedTilesFromTrackdir(ft.m_old_tile, ft.m_new_tile, ft.m_old_td)) {\n\t\t\tft.m_new_td_bits &= ~TrackdirCrossesTrackdirs(ft.m_old_td);\n\t\t\tassert(ft.m_new_td_bits != TRACKDIR_BIT_NONE);\n\t\t}\n\t\tassert(KillFirstBit(ft.m_new_td_bits) == TRACKDIR_BIT_NONE);\n\n\t\ttile = ft.m_new_tile;\n\t\tcur_td = FindFirstTrackdir(ft.m_new_td_bits);\n\n\t\tUnreserveRailTrackdir(tile, cur_td);\n\t}\n\n\t/* Path invalid. */\n\treturn PBSTileInfo();\n}\n\n/**\n * Try to reserve any path to a safe tile, ignoring the vehicle's destination.\n * Safe tiles are tiles in front of a signal, depots and station tiles at end of line.\n *\n * @param v The vehicle.\n * @param tile The tile the search should start from.\n * @param td The trackdir the search should start from.\n * @param override_railtype Whether all physically compatible railtypes should be followed.\n * @return True if a path to a safe stopping tile could be reserved.\n */\nstatic bool TryReserveSafeTrack(const Train* v, TileIndex tile, Trackdir td, bool override_railtype)\n{\n\tswitch (_settings_game.pf.pathfinder_for_trains) {\n\tcase VPF_NPF: return NPFTrainFindNearestSafeTile(v, tile, td, override_railtype);\n\tcase VPF_YAPF: return YapfTrainFindNearestSafeTile(v, tile, td, override_railtype);\n\n\tdefault: NOT_REACHED();\n\t}\n}\n\n/** This class will save the current order of a vehicle and restore it on destruction. */\nclass VehicleOrderSaver {\nprivate:\n\tTrain* v;\n\tOrder          old_order;\n\tTileIndex      old_dest_tile;\n\tStationID      old_last_station_visited;\n\tVehicleOrderID index;\n\tbool           suppress_implicit_orders;\n\npublic:\n\tVehicleOrderSaver(Train* _v) :\n\t\tv(_v),\n\t\told_order(_v->current_order),\n\t\told_dest_tile(_v->dest_tile),\n\t\told_last_station_visited(_v->last_station_visited),\n\t\tindex(_v->cur_real_order_index),\n\t\tsuppress_implicit_orders(HasBit(_v->gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS))\n\t{\n\t}\n\n\t~VehicleOrderSaver()\n\t{\n\t\tthis->v->current_order = this->old_order;\n\t\tthis->v->dest_tile = this->old_dest_tile;\n\t\tthis->v->last_station_visited = this->old_last_station_visited;\n\t\tSB(this->v->gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS, 1, suppress_implicit_orders ? 1 : 0);\n\t}\n\n\t/**\n\t * Set the current vehicle order to the next order in the order list.\n\t * @param skip_first Shall the first (i.e. active) order be skipped?\n\t * @return True if a suitable next order could be found.\n\t */\n\tbool SwitchToNextOrder(bool skip_first)\n\t{\n\t\tif (this->v->GetNumOrders() == 0) return false;\n\n\t\tif (skip_first)++this->index;\n\n\t\tint depth = 0;\n\n\t\tdo {\n\t\t\t/* Wrap around. */\n\t\t\tif (this->index >= this->v->GetNumOrders()) this->index = 0;\n\n\t\t\tOrder* order = this->v->GetOrder(this->index);\n\t\t\tassert(order != nullptr);\n\n\t\t\tswitch (order->GetType()) {\n\t\t\tcase OT_GOTO_DEPOT:\n\t\t\t\t/* Skip service in depot orders when the train doesn't need service. */\n\t\t\t\tif ((order->GetDepotOrderType() & ODTFB_SERVICE) && !this->v->NeedsServicing()) break;\n\t\t\t\tFALLTHROUGH;\n\t\t\tcase OT_GOTO_STATION:\n\t\t\tcase OT_GOTO_WAYPOINT:\n\t\t\t\tthis->v->current_order = *order;\n\t\t\t\treturn UpdateOrderDest(this->v, order, 0, true);\n\t\t\tcase OT_CONDITIONAL: {\n\t\t\t\tVehicleOrderID next = ProcessConditionalOrder(order, this->v, true);\n\t\t\t\tif (next != INVALID_VEH_ORDER_ID) {\n\t\t\t\t\tdepth++;\n\t\t\t\t\tthis->index = next;\n\t\t\t\t\t/* Don't increment next, so no break here. */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Don't increment inside the while because otherwise conditional\n\t\t\t * orders can lead to an infinite loop. */\n\t\t\t++this->index;\n\t\t\tdepth++;\n\t\t} while (this->index != this->v->cur_real_order_index && depth < this->v->GetNumOrders());\n\n\t\treturn false;\n\t}\n};\n\nstatic bool HasLongReservePbsSignalOnTrackdir(Train* v, TileIndex tile, Trackdir trackdir)\n{\n\tif (HasPbsSignalOnTrackdir(tile, trackdir)) {\n\t\tif (IsRestrictedSignal(tile)) {\n\t\t\tconst TraceRestrictProgram* prog = GetExistingTraceRestrictProgram(tile, TrackdirToTrack(trackdir));\n\t\t\tif (prog && prog->actions_used_flags & TRPAUF_LONG_RESERVE) {\n\t\t\t\tTraceRestrictProgramResult out;\n\t\t\t\tprog->Execute(v, TraceRestrictProgramInput(tile, trackdir, &VehiclePosTraceRestrictPreviousSignalCallback, nullptr), out);\n\t\t\t\tif (out.flags & TRPRF_LONG_RESERVE) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Choose a track and reserve if necessary\n *\n * @param v The vehicle\n * @param tile The tile from which to start\n * @param enterdir\n * @param tracks\n * @param force_res Force a reservation to be made\n * @param got_reservation [out] If the train has a reservation\n * @param mark_stuck The train has to be marked as stuck when needed\n * @return The track the train should take.\n */\nstatic Track ChooseTrainTrack(Train* v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool force_res, bool* p_got_reservation, bool mark_stuck)\n{\n\tTrack best_track = INVALID_TRACK;\n\tbool do_track_reservation = _settings_game.pf.reserve_paths || force_res;\n\tTrackdir changed_signal = INVALID_TRACKDIR;\n\n\tassert((tracks & ~TRACK_BIT_MASK) == 0);\n\n\tbool got_reservation = false;\n\tif (p_got_reservation != nullptr) *p_got_reservation = got_reservation;\n\n\t/* Don't use tracks here as the setting to forbid 90 deg turns might have been switched between reservation and now. */\n\tTrackBits res_tracks = (TrackBits)(GetReservedTrackbits(tile) & DiagdirReachesTracks(enterdir));\n\t/* Do we have a suitable reserved track? */\n\tif (res_tracks != TRACK_BIT_NONE) return FindFirstTrack(res_tracks);\n\n\t/* Quick return in case only one possible track is available */\n\tif (KillFirstBit(tracks) == TRACK_BIT_NONE) {\n\t\tTrack track = FindFirstTrack(tracks);\n\t\t/* We need to check for signals only here, as a junction tile can't have signals. */\n\t\tif (track != INVALID_TRACK && HasPbsSignalOnTrackdir(tile, TrackEnterdirToTrackdir(track, enterdir))) {\n\t\t\tif (IsRestrictedSignal(tile) && v->force_proceed != TFP_SIGNAL) {\n\t\t\t\tconst TraceRestrictProgram* prog = GetExistingTraceRestrictProgram(tile, track);\n\t\t\t\tif (prog && prog->actions_used_flags & (TRPAUF_WAIT_AT_PBS | TRPAUF_SLOT_ACQUIRE | TRPAUF_TRAIN_NOT_STUCK)) {\n\t\t\t\t\tTraceRestrictProgramResult out;\n\t\t\t\t\tTraceRestrictProgramInput input(tile, TrackEnterdirToTrackdir(track, enterdir), nullptr, nullptr);\n\t\t\t\t\tinput.permitted_slot_operations = TRPISP_ACQUIRE;\n\t\t\t\t\tprog->Execute(v, input, out);\n\t\t\t\t\tif (out.flags & TRPRF_TRAIN_NOT_STUCK) {\n\t\t\t\t\t\tv->wait_counter = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (out.flags & TRPRF_WAIT_AT_PBS) {\n\t\t\t\t\t\tif (mark_stuck) MarkTrainAsStuck(v, true);\n\t\t\t\t\t\treturn track;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tClrBit(v->flags, VRF_WAITING_RESTRICTION);\n\n\t\t\tdo_track_reservation = true;\n\t\t\tchanged_signal = TrackEnterdirToTrackdir(track, enterdir);\n\t\t\tSetSignalStateByTrackdir(tile, changed_signal, SIGNAL_STATE_GREEN);\n\t\t}\n\t\telse if (!do_track_reservation) {\n\t\t\treturn track;\n\t\t}\n\t\tbest_track = track;\n\t}\n\n\tPBSTileInfo   origin = FollowTrainReservation(v);\n\tPBSTileInfo   res_dest(tile, INVALID_TRACKDIR, false);\n\tDiagDirection dest_enterdir = enterdir;\n\tif (do_track_reservation) {\n\t\tres_dest = ExtendTrainReservation(v, origin, &tracks, &dest_enterdir);\n\t\tif (res_dest.tile == INVALID_TILE) {\n\t\t\t/* Reservation failed? */\n\t\t\tif (mark_stuck) MarkTrainAsStuck(v);\n\t\t\tif (changed_signal != INVALID_TRACKDIR) SetSignalStateByTrackdir(tile, changed_signal, SIGNAL_STATE_RED);\n\t\t\treturn FindFirstTrack(tracks);\n\t\t}\n\t\tif (res_dest.okay) {\n\t\t\tCFollowTrackRail ft(v);\n\t\t\tif (ft.Follow(res_dest.tile, res_dest.trackdir)) {\n\t\t\t\tTrackdir  new_td = FindFirstTrackdir(ft.m_new_td_bits);\n\n\t\t\t\tif (!HasLongReservePbsSignalOnTrackdir(v, ft.m_new_tile, new_td)) {\n\t\t\t\t\t/* Got a valid reservation that ends at a safe target, quick exit. */\n\t\t\t\t\tif (p_got_reservation != nullptr) *p_got_reservation = true;\n\t\t\t\t\tif (changed_signal != INVALID_TRACKDIR) MarkSingleSignalDirty(tile, changed_signal);\n\t\t\t\t\tTryReserveRailTrack(v->tile, TrackdirToTrack(v->GetVehicleTrackdir()));\n\t\t\t\t\treturn best_track;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Check if the train needs service here, so it has a chance to always find a depot.\n\t\t * Also check if the current order is a service order so we don't reserve a path to\n\t\t * the destination but instead to the next one if service isn't needed. */\n\t\tCheckIfTrainNeedsService(v);\n\t\tif (v->current_order.IsType(OT_DUMMY) || v->current_order.IsType(OT_CONDITIONAL) || v->current_order.IsType(OT_GOTO_DEPOT)) ProcessOrders(v);\n\t}\n\n\t/* Save the current train order. The destructor will restore the old order on function exit. */\n\tVehicleOrderSaver orders(v);\n\n\t/* If the current tile is the destination of the current order and\n\t * a reservation was requested, advance to the next order.\n\t * Don't advance on a depot order as depots are always safe end points\n\t * for a path and no look-ahead is necessary. This also avoids a\n\t * problem with depot orders not part of the order list when the\n\t * order list itself is empty. */\n\tif (v->current_order.IsType(OT_LEAVESTATION)) {\n\t\torders.SwitchToNextOrder(false);\n\t}\n\telse if (v->current_order.IsAnyLoadingType() || (!v->current_order.IsType(OT_GOTO_DEPOT) && (\n\t\tv->current_order.IsType(OT_GOTO_STATION) ?\n\t\tIsRailStationTile(v->tile) && v->current_order.GetDestination() == GetStationIndex(v->tile) :\n\t\tv->tile == v->dest_tile))) {\n\t\torders.SwitchToNextOrder(true);\n\t}\n\n\tif (res_dest.tile != INVALID_TILE && !res_dest.okay) {\n\t\t/* Pathfinders are able to tell that route was only 'guessed'. */\n\t\tbool      path_found = true;\n\t\tTileIndex new_tile = res_dest.tile;\n\n\t\tTrack next_track = DoTrainPathfind(v, new_tile, dest_enterdir, tracks, path_found, do_track_reservation, &res_dest);\n\t\tUpdateStateChecksum((((uint64)v->index) << 32) | (path_found << 16) | next_track);\n\t\tif (new_tile == tile) best_track = next_track;\n\t\tv->HandlePathfindingResult(path_found);\n\t}\n\n\t/* No track reservation requested -> finished. */\n\tif (!do_track_reservation) return best_track;\n\n\t/* A path was found, but could not be reserved. */\n\tif (res_dest.tile != INVALID_TILE && !res_dest.okay) {\n\t\tif (mark_stuck) MarkTrainAsStuck(v);\n\t\tFreeTrainTrackReservation(v, origin.tile, origin.trackdir);\n\t\treturn best_track;\n\t}\n\n\t/* No possible reservation target found, we are probably lost. */\n\tif (res_dest.tile == INVALID_TILE) {\n\t\t/* Try to find any safe destination. */\n\t\tPBSTileInfo path_end = FollowTrainReservation(v);\n\t\tif (TryReserveSafeTrack(v, path_end.tile, path_end.trackdir, false)) {\n\t\t\tTrackBits res = GetReservedTrackbits(tile) & DiagdirReachesTracks(enterdir);\n\t\t\tbest_track = FindFirstTrack(res);\n\t\t\tTryReserveRailTrack(v->tile, TrackdirToTrack(v->GetVehicleTrackdir()));\n\t\t\tif (p_got_reservation != nullptr) *p_got_reservation = true;\n\t\t\tif (changed_signal != INVALID_TRACKDIR) MarkSingleSignalDirty(tile, changed_signal);\n\t\t}\n\t\telse {\n\t\t\tFreeTrainTrackReservation(v, origin.tile, origin.trackdir);\n\t\t\tif (mark_stuck) MarkTrainAsStuck(v);\n\t\t}\n\t\treturn best_track;\n\t}\n\n\tgot_reservation = true;\n\n\t/* Reservation target found and free, check if it is safe. */\n\twhile (!IsSafeWaitingPosition(v, res_dest.tile, res_dest.trackdir, true, _settings_game.pf.forbid_90_deg)) {\n\t\t/* Extend reservation until we have found a safe position. */\n\t\tDiagDirection exitdir = TrackdirToExitdir(res_dest.trackdir);\n\t\tTileIndex     next_tile = TileAddByDiagDir(res_dest.tile, exitdir);\n\t\tTrackBits     reachable = TrackdirBitsToTrackBits((TrackdirBits)(GetTileTrackStatus(next_tile, TRANSPORT_RAIL, 0))) & DiagdirReachesTracks(exitdir);\n\t\tif (Rail90DegTurnDisallowedTilesFromDiagDir(res_dest.tile, next_tile, exitdir)) {\n\t\t\treachable &= ~TrackCrossesTracks(TrackdirToTrack(res_dest.trackdir));\n\t\t}\n\n\t\t/* Get next order with destination. */\n\t\tif (orders.SwitchToNextOrder(true)) {\n\t\t\tPBSTileInfo cur_dest;\n\t\t\tbool path_found;\n\t\t\tDoTrainPathfind(v, next_tile, exitdir, reachable, path_found, true, &cur_dest);\n\t\t\tif (cur_dest.tile != INVALID_TILE) {\n\t\t\t\tres_dest = cur_dest;\n\t\t\t\tif (res_dest.okay) continue;\n\t\t\t\t/* Path found, but could not be reserved. */\n\t\t\t\tFreeTrainTrackReservation(v, origin.tile, origin.trackdir);\n\t\t\t\tif (mark_stuck) MarkTrainAsStuck(v);\n\t\t\t\tgot_reservation = false;\n\t\t\t\tchanged_signal = INVALID_TRACKDIR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* No order or no safe position found, try any position. */\n\t\tif (!TryReserveSafeTrack(v, res_dest.tile, res_dest.trackdir, true)) {\n\t\t\tFreeTrainTrackReservation(v, origin.tile, origin.trackdir);\n\t\t\tif (mark_stuck) MarkTrainAsStuck(v);\n\t\t\tgot_reservation = false;\n\t\t\tchanged_signal = INVALID_TRACKDIR;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (got_reservation) {\n\t\tCFollowTrackRail ft(v);\n\t\tif (ft.Follow(res_dest.tile, res_dest.trackdir)) {\n\t\t\tTrackdir  new_td = FindFirstTrackdir(ft.m_new_td_bits);\n\n\t\t\tif (HasLongReservePbsSignalOnTrackdir(v, ft.m_new_tile, new_td)) {\n\t\t\t\t// We reserved up to a LR signal, reserve past it as well. recursion\n\t\t\t\tChooseTrainTrack(v, ft.m_new_tile, ft.m_exitdir, TrackdirBitsToTrackBits(ft.m_new_td_bits), force_res, nullptr, mark_stuck);\n\t\t\t}\n\t\t}\n\t}\n\n\tTryReserveRailTrack(v->tile, TrackdirToTrack(v->GetVehicleTrackdir()));\n\n\tif (changed_signal != INVALID_TRACKDIR) MarkSingleSignalDirty(tile, changed_signal);\n\tif (p_got_reservation != nullptr) *p_got_reservation = got_reservation;\n\n\treturn best_track;\n}\n\n/**\n * Try to reserve a path to a safe position.\n *\n * @param v The vehicle\n * @param mark_as_stuck Should the train be marked as stuck on a failed reservation?\n * @param first_tile_okay True if no path should be reserved if the current tile is a safe position.\n * @return True if a path could be reserved.\n */\nbool TryPathReserve(Train* v, bool mark_as_stuck, bool first_tile_okay)\n{\n\tassert(v->IsFrontEngine());\n\n\t/* We have to handle depots specially as the track follower won't look\n\t * at the depot tile itself but starts from the next tile. If we are still\n\t * inside the depot, a depot reservation can never be ours. */\n\tif (v->track == TRACK_BIT_DEPOT) {\n\t\tif (HasDepotReservation(v->tile)) {\n\t\t\tif (mark_as_stuck) MarkTrainAsStuck(v);\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t/* Depot not reserved, but the next tile might be. */\n\t\t\tTileIndex next_tile = TileAddByDiagDir(v->tile, GetRailDepotDirection(v->tile));\n\t\t\tif (HasReservedTracks(next_tile, DiagdirReachesTracks(GetRailDepotDirection(v->tile)))) return false;\n\t\t}\n\t}\n\n\tif (IsTileType(v->tile, MP_TUNNELBRIDGE) && IsTunnelBridgeSignalSimulationExitOnly(v->tile) &&\n\t\tTrackdirEntersTunnelBridge(v->tile, v->GetVehicleTrackdir())) {\n\t\t// prevent any attempt to reserve the wrong way onto a tunnel/bridge exit\n\t\treturn false;\n\t}\n\n\tVehicle* other_train = nullptr;\n\tPBSTileInfo origin = FollowTrainReservation(v, &other_train);\n\t/* The path we are driving on is already blocked by some other train.\n\t * This can only happen in certain situations when mixing path and\n\t * block signals or when changing tracks and/or signals.\n\t * Exit here as doing any further reservations will probably just\n\t * make matters worse. */\n\tif (other_train != nullptr && other_train->index != v->index) {\n\t\tif (mark_as_stuck) MarkTrainAsStuck(v);\n\t\treturn false;\n\t}\n\t/* If we have a reserved path and the path ends at a safe tile, we are finished already. */\n\tif (origin.okay && (v->tile != origin.tile || first_tile_okay)) {\n\t\t/* Can't be stuck then. */\n\t\tif (HasBit(v->flags, VRF_TRAIN_STUCK)) SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n\t\tClrBit(v->flags, VRF_TRAIN_STUCK);\n\t\treturn true;\n\t}\n\n\t/* If we are in a depot, tentatively reserve the depot. */\n\tif (v->track == TRACK_BIT_DEPOT && v->tile == origin.tile) {\n\t\tSetDepotReservation(v->tile, true);\n\t\tif (_settings_client.gui.show_track_reservation) MarkTileDirtyByTile(v->tile, ZOOM_LVL_DRAW_MAP);\n\t}\n\n\tDiagDirection exitdir = TrackdirToExitdir(origin.trackdir);\n\tTileIndex     new_tile = TileAddByDiagDir(origin.tile, exitdir);\n\tTrackBits     reachable = TrackdirBitsToTrackBits(TrackStatusToTrackdirBits(GetTileTrackStatus(new_tile, TRANSPORT_RAIL, 0)) & DiagdirReachesTrackdirs(exitdir));\n\n\tif (Rail90DegTurnDisallowedTilesFromDiagDir(origin.tile, new_tile, exitdir)) reachable &= ~TrackCrossesTracks(TrackdirToTrack(origin.trackdir));\n\n\tbool res_made = false;\n\tChooseTrainTrack(v, new_tile, exitdir, reachable, true, &res_made, mark_as_stuck);\n\n\tif (!res_made) {\n\t\t/* Free the depot reservation as well. */\n\t\tif (v->track == TRACK_BIT_DEPOT && v->tile == origin.tile) SetDepotReservation(v->tile, false);\n\t\treturn false;\n\t}\n\n\tif (HasBit(v->flags, VRF_TRAIN_STUCK)) {\n\t\tv->wait_counter = 0;\n\t\tSetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n\t}\n\tClrBit(v->flags, VRF_TRAIN_STUCK);\n\treturn true;\n}\n\n\nstatic bool CheckReverseTrain(const Train* v)\n{\n\tif (_settings_game.difficulty.line_reverse_mode != 0 ||\n\t\tv->track == TRACK_BIT_DEPOT) {\n\t\treturn false;\n\t}\n\n\tassert(v->track != TRACK_BIT_NONE);\n\n\tswitch (_settings_game.pf.pathfinder_for_trains) {\n\tcase VPF_NPF: return NPFTrainCheckReverse(v);\n\tcase VPF_YAPF: return YapfTrainCheckReverse(v);\n\n\tdefault: NOT_REACHED();\n\t}\n}\n\n/**\n * Get the location of the next station to visit.\n * @param station Next station to visit.\n * @return Location of the new station.\n */\nTileIndex Train::GetOrderStationLocation(StationID station)\n{\n\tif (station == this->last_station_visited) this->last_station_visited = INVALID_STATION;\n\n\tconst Station* st = Station::Get(station);\n\tif (!(st->facilities & FACIL_TRAIN)) {\n\t\t/* The destination station has no trainstation tiles. */\n\t\tthis->IncrementRealOrderIndex();\n\t\treturn 0;\n\t}\n\n\treturn st->xy;\n}\n\n/** Goods at the consist have changed, update the graphics, cargo, and acceleration. */\nvoid Train::MarkDirty()\n{\n\tTrain* v = this;\n\tdo {\n\t\tv->colourmap = PAL_NONE;\n\t\tv->InvalidateImageCache();\n\t\tv->UpdateViewport(true, false);\n\t} while ((v = v->Next()) != nullptr);\n\n\t/* need to update acceleration and cached values since the goods on the train changed. */\n\tthis->CargoChanged();\n\tthis->UpdateAcceleration();\n}\n\n/**\n * This function looks at the vehicle and updates its speed (cur_speed\n * and subspeed) variables. Furthermore, it returns the distance that\n * the train can drive this tick. #Vehicle::GetAdvanceDistance() determines\n * the distance to drive before moving a step on the map.\n * @return distance to drive.\n */\nint Train::UpdateSpeed()\n{\n\tswitch (_settings_game.vehicle.train_acceleration_model) {\n\tdefault: NOT_REACHED();\n\tcase AM_ORIGINAL:\n\t\treturn this->DoUpdateSpeed(this->acceleration * (this->GetAccelerationStatus() == AS_BRAKE ? -4 : 2), 0, this->GetCurrentMaxSpeed());\n\n\tcase AM_REALISTIC:\n\t\treturn this->DoUpdateSpeed(this->GetAcceleration(), this->GetAccelerationStatus() == AS_BRAKE ? 0 : 2, this->GetCurrentMaxSpeed());\n\t}\n}\n/**\n * Handle all breakdown related stuff for a train consist.\n * @param v The front engine.\n */\nstatic bool HandlePossibleBreakdowns(Train* v)\n{\n\tassert(v->IsFrontEngine());\n\tfor (Train* u = v; u != nullptr; u = u->Next()) {\n\t\tif (u->breakdown_ctr != 0 && (u->IsEngine() || u->IsMultiheaded())) {\n\t\t\tif (u->breakdown_ctr <= 2) {\n\t\t\t\tif (u->HandleBreakdown()) return true;\n\t\t\t\t/* We check the order of v (the first vehicle) instead of u here! */\n\t\t\t}\n\t\t\telse if (!v->current_order.IsType(OT_LOADING)) {\n\t\t\t\tu->breakdown_ctr--;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Trains enters a station, send out a news item if it is the first train, and start loading.\n * @param v Train that entered the station.\n * @param station Station visited.\n */\nstatic void TrainEnterStation(Train* v, StationID station)\n{\n\tv->last_station_visited = station;\n\n\tBaseStation* bst = BaseStation::Get(station);\n\n\tif (Waypoint::IsExpected(bst)) {\n\t\tv->DeleteUnreachedImplicitOrders();\n\t\tUpdateVehicleTimetable(v, true);\n\t\tv->last_station_visited = station;\n\t\tv->force_proceed = TFP_NONE;\n\t\tSetWindowDirty(WC_VEHICLE_VIEW, v->index);\n\t\tv->current_order.MakeWaiting();\n\t\tv->current_order.SetNonStopType(ONSF_NO_STOP_AT_ANY_STATION);\n\t\treturn;\n\t}\n\n\t/* check if a train ever visited this station before */\n\tStation* st = Station::From(bst);\n\tif (!(st->had_vehicle_of_type & HVOT_TRAIN)) {\n\t\tst->had_vehicle_of_type |= HVOT_TRAIN;\n\t\tSetDParam(0, st->index);\n\t\tAddVehicleNewsItem(\n\t\t\tSTR_NEWS_FIRST_TRAIN_ARRIVAL,\n\t\t\tv->owner == _local_company ? NT_ARRIVAL_COMPANY : NT_ARRIVAL_OTHER,\n\t\t\tv->index,\n\t\t\tst->index\n\t\t);\n\t\tAI::NewEvent(v->owner, new ScriptEventStationFirstVehicle(st->index, v->index));\n\t\tGame::NewEvent(new ScriptEventStationFirstVehicle(st->index, v->index));\n\t}\n\n\tv->force_proceed = TFP_NONE;\n\tSetWindowDirty(WC_VEHICLE_VIEW, v->index);\n\n\tv->BeginLoading();\n\n\tTileIndex station_tile = v->GetStationLoadingVehicle()->tile;\n\tTriggerStationRandomisation(st, station_tile, SRT_TRAIN_ARRIVES);\n\tTriggerStationAnimation(st, station_tile, SAT_TRAIN_ARRIVES);\n}\n\n/* Check if the vehicle is compatible with the specified tile */\nstatic inline bool CheckCompatibleRail(const Train* v, TileIndex tile, DiagDirection enterdir)\n{\n\treturn IsInfraTileUsageAllowed(VEH_TRAIN, v->owner, tile) &&\n\t\t(!v->IsFrontEngine() || HasBit(v->compatible_railtypes, GetRailTypeByEntryDir(tile, enterdir)));\n}\n\n/** Data structure for storing engine speed changes of an acceleration type. */\nstruct AccelerationSlowdownParams {\n\tbyte small_turn; ///< Speed change due to a small turn.\n\tbyte large_turn; ///< Speed change due to a large turn.\n\tbyte z_up;       ///< Fraction to remove when moving up.\n\tbyte z_down;     ///< Fraction to add when moving down.\n};\n\n/** Speed update fractions for each acceleration type. */\nstatic const AccelerationSlowdownParams _accel_slowdown[] = {\n\t/* normal accel */\n\t{256 / 4, 256 / 2, 256 / 4, 2}, ///< normal\n\t{256 / 4, 256 / 2, 256 / 4, 2}, ///< monorail\n\t{0,       256 / 2, 256 / 4, 2}, ///< maglev\n};\n\n/**\n * Modify the speed of the vehicle due to a change in altitude.\n * @param v %Train to update.\n * @param old_z Previous height.\n */\nstatic inline void AffectSpeedByZChange(Train* v, int old_z)\n{\n\tif (old_z == v->z_pos || _settings_game.vehicle.train_acceleration_model != AM_ORIGINAL) return;\n\n\tconst AccelerationSlowdownParams* asp = &_accel_slowdown[GetRailTypeInfo(v->railtype)->acceleration_type];\n\n\tif (old_z < v->z_pos) {\n\t\tv->cur_speed -= (v->cur_speed * asp->z_up >> 8);\n\t}\n\telse {\n\t\tuint16 spd = v->cur_speed + asp->z_down;\n\t\tif (spd <= v->gcache.cached_max_track_speed) v->cur_speed = spd;\n\t}\n}\n\nenum TrainMovedChangeSignalEnum {\n\tCHANGED_NOTHING, ///< No special signals were changed\n\tCHANGED_NORMAL_TO_PBS_BLOCK, ///< A PBS block with a non-PBS signal facing us\n\tCHANGED_LR_PBS ///< A long reserve PBS signal\n};\n\nstatic TrainMovedChangeSignalEnum TrainMovedChangeSignal(Train* v, TileIndex tile, DiagDirection dir)\n{\n\tif (IsTileType(tile, MP_RAILWAY) &&\n\t\tGetRailTileType(tile) == RAIL_TILE_SIGNALS) {\n\t\tTrackdirBits tracks = TrackBitsToTrackdirBits(GetTrackBits(tile)) & DiagdirReachesTrackdirs(dir);\n\t\tTrackdir trackdir = FindFirstTrackdir(tracks);\n\t\tif (UpdateSignalsOnSegment(tile, TrackdirToExitdir(trackdir), GetTileOwner(tile)) == SIGSEG_PBS && HasSignalOnTrackdir(tile, trackdir)) {\n\t\t\t/* A PBS block with a non-PBS signal facing us? */\n\t\t\tif (!IsPbsSignal(GetSignalType(tile, TrackdirToTrack(trackdir)))) return CHANGED_NORMAL_TO_PBS_BLOCK;\n\n\t\t\tif (HasLongReservePbsSignalOnTrackdir(v, tile, trackdir)) return CHANGED_LR_PBS;\n\t\t}\n\t}\n\tif (IsTileType(tile, MP_TUNNELBRIDGE) && IsTunnelBridgeSignalSimulationExit(tile) && GetTunnelBridgeDirection(tile) == ReverseDiagDir(dir)) {\n\t\tif (UpdateSignalsOnSegment(tile, dir, GetTileOwner(tile)) == SIGSEG_PBS) {\n\t\t\treturn CHANGED_NORMAL_TO_PBS_BLOCK;\n\t\t}\n\t}\n\n\treturn CHANGED_NOTHING;\n}\n\n/** Tries to reserve track under whole train consist. */\nvoid Train::ReserveTrackUnderConsist() const\n{\n\tfor (const Train* u = this; u != nullptr; u = u->Next()) {\n\t\tif (u->track & TRACK_BIT_WORMHOLE) {\n\t\t\tif (IsRailCustomBridgeHeadTile(u->tile)) {\n\t\t\t\t/* reserve the first available track */\n\t\t\t\tTrackBits bits = GetAcrossTunnelBridgeTrackBits(u->tile);\n\t\t\t\tTrack first_track = RemoveFirstTrack(&bits);\n\t\t\t\tassert(IsValidTrack(first_track));\n\t\t\t\tTryReserveRailTrack(u->tile, first_track);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tTryReserveRailTrack(u->tile, DiagDirToDiagTrack(GetTunnelBridgeDirection(u->tile)));\n\t\t\t}\n\t\t}\n\t\telse if (u->track != TRACK_BIT_DEPOT) {\n\t\t\tTryReserveRailTrack(u->tile, TrackBitsToTrack(u->track));\n\t\t}\n\t}\n}\n\n/**\n * The train vehicle crashed!\n * Update its status and other parts around it.\n * @param flooded Crash was caused by flooding.\n * @return Number of people killed.\n */\nuint Train::Crash(bool flooded)\n{\n\tuint pass = 0;\n\tif (this->IsFrontEngine()) {\n\t\tpass += 2; // driver\n\n\t\t/* Remove the reserved path in front of the train if it is not stuck.\n\t\t * Also clear all reserved tracks the train is currently on. */\n\t\tif (!HasBit(this->flags, VRF_TRAIN_STUCK)) FreeTrainTrackReservation(this);\n\t\tfor (const Train* v = this; v != nullptr; v = v->Next()) {\n\t\t\tClearPathReservation(v, v->tile, v->GetVehicleTrackdir(), true);\n\t\t}\n\n\t\t/* we may need to update crossing we were approaching,\n\t\t * but must be updated after the train has been marked crashed */\n\t\tTileIndex crossing = TrainApproachingCrossingTile(this);\n\t\tif (crossing != INVALID_TILE) UpdateLevelCrossing(crossing);\n\n\t\t/* Remove the loading indicators (if any) */\n\t\tHideFillingPercent(&this->fill_percent_te_id);\n\t}\n\n\tRegisterGameEvents(GEF_TRAIN_CRASH);\n\n\tpass += this->GroundVehicleBase::Crash(flooded);\n\n\tthis->crash_anim_pos = flooded ? 4000 : 1; // max 4440, disappear pretty fast when flooded\n\treturn pass;\n}\n\n/**\n * Marks train as crashed and creates an AI event.\n * Doesn't do anything if the train is crashed already.\n * @param v first vehicle of chain\n * @return number of victims (including 2 drivers; zero if train was already crashed)\n */\nstatic uint TrainCrashed(Train* v)\n{\n\tuint num = 0;\n\n\t/* do not crash train twice */\n\tif (!(v->vehstatus & VS_CRASHED)) {\n\t\tnum = v->Crash();\n\t\tAI::NewEvent(v->owner, new ScriptEventVehicleCrashed(v->index, v->tile, ScriptEventVehicleCrashed::CRASH_TRAIN));\n\t\tGame::NewEvent(new ScriptEventVehicleCrashed(v->index, v->tile, ScriptEventVehicleCrashed::CRASH_TRAIN));\n\t}\n\n\t/* Try to re-reserve track under already crashed train too.\n\t * Crash() clears the reservation! */\n\tv->ReserveTrackUnderConsist();\n\n\treturn num;\n}\n\n/** Temporary data storage for testing collisions. */\nstruct TrainCollideChecker {\n\tTrain* v; ///< %Vehicle we are testing for collision.\n\tuint num; ///< Total number of victims if train collided.\n};\n\n/**\n * Collision test function.\n * @param v %Train vehicle to test collision with.\n * @param data %Train being examined.\n * @return \\c nullptr (always continue search)\n */\nstatic Vehicle* FindTrainCollideEnum(Vehicle* v, void* data)\n{\n\tTrainCollideChecker* tcc = (TrainCollideChecker*)data;\n\n\t/* not in depot */\n\tif (Train::From(v)->track == TRACK_BIT_DEPOT) return nullptr;\n\n\tif (_settings_game.vehicle.no_train_crash_other_company) {\n\t\t/* do not crash into trains of another company. */\n\t\tif (v->owner != tcc->v->owner) return nullptr;\n\t}\n\n\t/* get first vehicle now to make most usual checks faster */\n\tTrain* coll = Train::From(v)->First();\n\n\t/* can't collide with own wagons */\n\tif (coll == tcc->v) return nullptr;\n\n\tint x_diff = v->x_pos - tcc->v->x_pos;\n\tint y_diff = v->y_pos - tcc->v->y_pos;\n\n\t/* Do fast calculation to check whether trains are not in close vicinity\n\t * and quickly reject trains distant enough for any collision.\n\t * Differences are shifted by 7, mapping range [-7 .. 8] into [0 .. 15]\n\t * Differences are then ORed and then we check for any higher bits */\n\tuint hash = (y_diff + 7) | (x_diff + 7);\n\tif (hash & ~15) return nullptr;\n\n\t/* Slower check using multiplication */\n\tint min_diff = (Train::From(v)->gcache.cached_veh_length + 1) / 2 + (tcc->v->gcache.cached_veh_length + 1) / 2 - 1;\n\tif (x_diff * x_diff + y_diff * y_diff >= min_diff * min_diff) return nullptr;\n\n\t/* Happens when there is a train under bridge next to bridge head */\n\tif (abs(v->z_pos - tcc->v->z_pos) > 5) return nullptr;\n\n\t/* crash both trains */\n\ttcc->num += TrainCrashed(tcc->v);\n\ttcc->num += TrainCrashed(coll);\n\n\treturn nullptr; // continue searching\n}\n\n/**\n * Checks whether the specified train has a collision with another vehicle. If\n * so, destroys this vehicle, and the other vehicle if its subtype has TS_Front.\n * Reports the incident in a flashy news item, modifies station ratings and\n * plays a sound.\n * @param v %Train to test.\n */\nstatic bool CheckTrainCollision(Train* v)\n{\n\t/* can't collide in depot */\n\tif (v->track == TRACK_BIT_DEPOT) return false;\n\n\tassert(v->track & TRACK_BIT_WORMHOLE || TileVirtXY(v->x_pos, v->y_pos) == v->tile);\n\n\tTrainCollideChecker tcc;\n\ttcc.v = v;\n\ttcc.num = 0;\n\n\t/* find colliding vehicles */\n\tif (v->track & TRACK_BIT_WORMHOLE) {\n\t\tFindVehicleOnPos(v->tile, VEH_TRAIN, &tcc, FindTrainCollideEnum);\n\t\tFindVehicleOnPos(GetOtherTunnelBridgeEnd(v->tile), VEH_TRAIN, &tcc, FindTrainCollideEnum);\n\t}\n\telse {\n\t\tFindVehicleOnPosXY(v->x_pos, v->y_pos, VEH_TRAIN, &tcc, FindTrainCollideEnum);\n\t}\n\n\t/* any dead -> no crash */\n\tif (tcc.num == 0) return false;\n\n\tSetDParam(0, tcc.num);\n\tAddVehicleNewsItem(STR_NEWS_TRAIN_CRASH, NT_ACCIDENT, v->index);\n\n\tModifyStationRatingAround(v->tile, v->owner, -160, 30);\n\tif (_settings_client.sound.disaster) SndPlayVehicleFx(SND_13_BIG_CRASH, v);\n\treturn true;\n}\n\nstatic Vehicle* CheckTrainAtSignal(Vehicle* v, void* data)\n{\n\tif ((v->vehstatus & VS_CRASHED)) return nullptr;\n\n\tTrain* t = Train::From(v);\n\tDiagDirection exitdir = *(DiagDirection*)data;\n\n\t/* not front engine of a train, inside wormhole or depot, crashed */\n\tif (!t->IsFrontEngine() || !(t->track & TRACK_BIT_MASK)) return nullptr;\n\n\tif (t->cur_speed > 5 || VehicleExitDir(t->direction, t->track) != exitdir) return nullptr;\n\n\treturn t;\n}\n\nstruct FindSpaceBetweenTrainsChecker {\n\tint32 pos;\n\tuint16 distance;\n\tDiagDirection direction;\n};\n\n/** Find train in front and keep distance between trains in tunnel/bridge. */\nstatic Vehicle* FindSpaceBetweenTrainsEnum(Vehicle* v, void* data)\n{\n\t/* Don't look at wagons between front and back of train. */\n\tif ((v->Previous() != nullptr && v->Next() != nullptr)) return nullptr;\n\n\tif (!IsDiagonalDirection(v->direction)) {\n\t\t/* Check for vehicles on non-across track pieces of custom bridge head */\n\t\tif ((GetAcrossTunnelBridgeTrackBits(v->tile) & Train::From(v)->track & TRACK_BIT_ALL) == TRACK_BIT_NONE) return nullptr;\n\t}\n\n\tconst FindSpaceBetweenTrainsChecker* checker = (FindSpaceBetweenTrainsChecker*)data;\n\tint32 a, b = 0;\n\n\tswitch (checker->direction) {\n\tdefault: NOT_REACHED();\n\tcase DIAGDIR_NE: a = checker->pos; b = v->x_pos; break;\n\tcase DIAGDIR_SE: a = v->y_pos; b = checker->pos; break;\n\tcase DIAGDIR_SW: a = v->x_pos; b = checker->pos; break;\n\tcase DIAGDIR_NW: a = checker->pos; b = v->y_pos; break;\n\t}\n\n\tif (a > b&& a <= (b + (int)(checker->distance)) + (int)(TILE_SIZE)-1) return v;\n\treturn nullptr;\n}\n\nstatic bool IsTooCloseBehindTrain(Vehicle* v, TileIndex tile, uint16 distance, bool check_endtile)\n{\n\tTrain* t = Train::From(v);\n\n\tif (t->force_proceed != 0) return false;\n\n\tFindSpaceBetweenTrainsChecker checker;\n\tchecker.distance = distance;\n\tchecker.direction = DirToDiagDirAlongAxis(t->direction, DiagDirToAxis(GetTunnelBridgeDirection(t->tile)));\n\tswitch (checker.direction) {\n\tdefault: NOT_REACHED();\n\tcase DIAGDIR_NE: checker.pos = (TileX(tile) * TILE_SIZE) + TILE_UNIT_MASK; break;\n\tcase DIAGDIR_SE: checker.pos = (TileY(tile) * TILE_SIZE); break;\n\tcase DIAGDIR_SW: checker.pos = (TileX(tile) * TILE_SIZE); break;\n\tcase DIAGDIR_NW: checker.pos = (TileY(tile) * TILE_SIZE) + TILE_UNIT_MASK; break;\n\t}\n\n\tif (HasVehicleOnPos(t->tile, VEH_TRAIN, &checker, &FindSpaceBetweenTrainsEnum)) {\n\t\t/* Revert train if not going with tunnel direction. */\n\t\tif (checker.direction != GetTunnelBridgeDirection(t->tile)) {\n\t\t\tSetBit(t->flags, VRF_REVERSING);\n\t\t}\n\t\treturn true;\n\t}\n\t/* Cover blind spot at end of tunnel bridge. */\n\tif (check_endtile) {\n\t\tif (HasVehicleOnPos(GetOtherTunnelBridgeEnd(t->tile), VEH_TRAIN, &checker, &FindSpaceBetweenTrainsEnum)) {\n\t\t\t/* Revert train if not going with tunnel direction. */\n\t\t\tif (checker.direction != GetTunnelBridgeDirection(t->tile)) {\n\t\t\t\tSetBit(t->flags, VRF_REVERSING);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool CheckTrainStayInWormHolePathReserve(Train* t, TileIndex tile)\n{\n\tTrackdir td = TrackEnterdirToTrackdir(FindFirstTrack(GetAcrossTunnelBridgeTrackBits(tile)), ReverseDiagDir(GetTunnelBridgeDirection(tile)));\n\tTileIndex veh_orig_tile = t->tile;\n\tTrackBits veh_orig_track = t->track;\n\tDirection veh_orig_direction = t->direction;\n\tt->tile = tile;\n\tt->track = TRACK_BIT_WORMHOLE;\n\tt->direction = TrackdirToDirection(td);\n\tCFollowTrackRail ft(GetTileOwner(tile), GetRailTypeInfo(t->railtype)->compatible_railtypes);\n\tif (ft.Follow(tile, td)) {\n\t\tTrackdirBits reserved = ft.m_new_td_bits & TrackBitsToTrackdirBits(GetReservedTrackbits(ft.m_new_tile));\n\t\tif (reserved == TRACKDIR_BIT_NONE) {\n\t\t\t/* next tile is not reserved, so reserve the exit tile */\n\t\t\tif (IsBridge(tile)) {\n\t\t\t\tTryReserveRailBridgeHead(tile, FindFirstTrack(GetAcrossTunnelBridgeTrackBits(tile)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSetTunnelReservation(tile, true);\n\t\t\t}\n\t\t\tMarkTileDirtyByTile(tile, ZOOM_LVL_DRAW_MAP);\n\t\t}\n\t}\n\tbool ok = TryPathReserve(t);\n\tt->tile = veh_orig_tile;\n\tt->track = veh_orig_track;\n\tt->direction = veh_orig_direction;\n\tif (ok && IsTunnelBridgePBS(tile)) SetTunnelBridgeExitSignalState(tile, SIGNAL_STATE_GREEN);\n\treturn ok;\n}\n\n/** Simulate signals in tunnel - bridge. */\nstatic bool CheckTrainStayInWormHole(Train* t, TileIndex tile)\n{\n\tif (t->force_proceed != 0) return false;\n\n\t/* When not exit reverse train. */\n\tif (!IsTunnelBridgeSignalSimulationExit(tile)) {\n\t\tSetBit(t->flags, VRF_REVERSING);\n\t\treturn true;\n\t}\n\tSigSegState seg_state = (_settings_game.pf.reserve_paths || IsTunnelBridgePBS(tile)) ? SIGSEG_PBS : UpdateSignalsOnSegment(tile, INVALID_DIAGDIR, t->owner);\n\tif (seg_state != SIGSEG_PBS) {\n\t\tCFollowTrackRail ft(GetTileOwner(tile), GetRailTypeInfo(t->railtype)->compatible_railtypes);\n\t\tif (ft.Follow(tile, TrackEnterdirToTrackdir(FindFirstTrack(GetAcrossTunnelBridgeTrackBits(tile)), ReverseDiagDir(GetTunnelBridgeDirection(tile))))) {\n\t\t\tif (ft.m_new_td_bits != TRACKDIR_BIT_NONE && KillFirstBit(ft.m_new_td_bits) == TRACKDIR_BIT_NONE) {\n\t\t\t\tTrackdir td = FindFirstTrackdir(ft.m_new_td_bits);\n\t\t\t\tif (HasPbsSignalOnTrackdir(ft.m_new_tile, td)) {\n\t\t\t\t\t/* immediately after the exit, there is a PBS signal, switch to PBS mode */\n\t\t\t\t\tseg_state = SIGSEG_PBS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (seg_state == SIGSEG_FULL || (seg_state == SIGSEG_PBS && !CheckTrainStayInWormHolePathReserve(t, tile))) {\n\t\tt->vehstatus |= VS_TRAIN_SLOWING;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void HandleSignalBehindTrain(Train* v, int signal_number)\n{\n\tTileIndex tile;\n\tswitch (v->direction) {\n\tdefault: NOT_REACHED();\n\tcase DIR_NE: tile = TileVirtXY(v->x_pos + (TILE_SIZE * _settings_game.construction.simulated_wormhole_signals), v->y_pos); break;\n\tcase DIR_SE: tile = TileVirtXY(v->x_pos, v->y_pos - (TILE_SIZE * _settings_game.construction.simulated_wormhole_signals)); break;\n\tcase DIR_SW: tile = TileVirtXY(v->x_pos - (TILE_SIZE * _settings_game.construction.simulated_wormhole_signals), v->y_pos); break;\n\tcase DIR_NW: tile = TileVirtXY(v->x_pos, v->y_pos + (TILE_SIZE * _settings_game.construction.simulated_wormhole_signals)); break;\n\t}\n\n\tif (tile == v->tile) {\n\t\t/* Flip signal on ramp. */\n\t\tif (IsTunnelBridgeSignalSimulationEntrance(tile) && GetTunnelBridgeEntranceSignalState(tile) == SIGNAL_STATE_RED) {\n\t\t\tSetTunnelBridgeEntranceSignalState(tile, SIGNAL_STATE_GREEN);\n\t\t\tMarkTileDirtyByTile(tile);\n\t\t}\n\t}\n\telse if (IsBridge(v->tile) && signal_number >= 0) {\n\t\tSetBridgeEntranceSimulatedSignalState(v->tile, signal_number, SIGNAL_STATE_GREEN);\n\t\tMarkTileDirtyByTile(tile);\n\t}\n}\n\nuint16 ReversingDistanceTargetSpeed(const Train* v)\n{\n\tint target_speed;\n\tif (_settings_game.vehicle.train_acceleration_model == AM_REALISTIC) {\n\t\ttarget_speed = ((v->reverse_distance - 1) * 5) / 2;\n\t}\n\telse {\n\t\ttarget_speed = (v->reverse_distance - 1) * 10 - 5;\n\t}\n\treturn max(0, target_speed);\n}\n\n/**\n * Move a vehicle chain one movement stop forwards.\n * @param v First vehicle to move.\n * @param nomove Stop moving this and all following vehicles.\n * @param reverse Set to false to not execute the vehicle reversing. This does not change any other logic.\n * @return True if the vehicle could be moved forward, false otherwise.\n */\nbool TrainController(Train* v, Vehicle* nomove, bool reverse)\n{\n\tTrain* first = v->First();\n\tTrain* prev = nullptr;\n\tSCOPE_INFO_FMT([&], \"TrainController: %s, %s, %s\", scope_dumper().VehicleInfo(v), scope_dumper().VehicleInfo(prev), scope_dumper().VehicleInfo(nomove));\n\tbool direction_changed = false; // has direction of any part changed?\n\tbool update_signal_tunbridge_exit = false;\n\tDirection old_direction = INVALID_DIR;\n\tTrackBits old_trackbits = INVALID_TRACK_BIT;\n\tuint16 old_gv_flags = 0;\n\n\tauto notify_direction_changed = [&](Direction old_direction, Direction new_direction) {\n\t\tif (prev == nullptr && _settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) {\n\t\t\tconst AccelerationSlowdownParams* asp = &_accel_slowdown[GetRailTypeInfo(v->railtype)->acceleration_type];\n\t\t\tDirDiff diff = DirDifference(old_direction, new_direction);\n\t\t\tv->cur_speed -= (diff == DIRDIFF_45RIGHT || diff == DIRDIFF_45LEFT ? asp->small_turn : asp->large_turn) * v->cur_speed >> 8;\n\t\t}\n\t\tdirection_changed = true;\n\t};\n\n\tif (reverse && v->reverse_distance == 1) {\n\t\tgoto reverse_train_direction;\n\t}\n\n\tif (v->reverse_distance > 1) {\n\t\tuint16 spd = ReversingDistanceTargetSpeed(v);\n\t\tif (spd < v->cur_speed) v->cur_speed = spd;\n\t}\n\n\t/* For every vehicle after and including the given vehicle */\n\tfor (prev = v->Previous(); v != nomove; prev = v, v = v->Next()) {\n\t\told_direction = v->direction;\n\t\told_trackbits = v->track;\n\t\told_gv_flags = v->gv_flags;\n\t\tDiagDirection enterdir = DIAGDIR_BEGIN;\n\t\tbool update_signals_crossing = false; // will we update signals or crossing state?\n\n\n\t\tGetNewVehiclePosResult gp = GetNewVehiclePos(v);\n\t\tif (!(v->track & TRACK_BIT_WORMHOLE) && gp.old_tile != gp.new_tile &&\n\t\t\tIsRailBridgeHeadTile(gp.old_tile) && DiagdirBetweenTiles(gp.old_tile, gp.new_tile) == GetTunnelBridgeDirection(gp.old_tile)) {\n\t\t\t/* left a bridge headtile into a wormhole */\n\t\t\tDirection old_direction = v->direction;\n\t\t\tuint32 r = VehicleEnterTile(v, gp.old_tile, gp.x, gp.y); // NB: old tile, the bridge head which the train just left\n\t\t\tif (HasBit(r, VETS_CANNOT_ENTER)) {\n\t\t\t\tgoto invalid_rail;\n\t\t\t}\n\t\t\tif (old_direction != v->direction) notify_direction_changed(old_direction, v->direction);\n\t\t\tDiagDirection dir = GetTunnelBridgeDirection(gp.old_tile);\n\t\t\tconst byte* b = _initial_tile_subcoord[AxisToTrack(DiagDirToAxis(dir))][dir];\n\t\t\tgp.x = (gp.x & ~0xF) | b[0];\n\t\t\tgp.y = (gp.y & ~0xF) | b[1];\n\t\t}\n\t\tif (!(v->track & TRACK_BIT_WORMHOLE)) {\n\t\t\t/* Not inside tunnel */\n\t\t\tif (gp.old_tile == gp.new_tile) {\n\t\t\t\t/* Staying in the old tile */\n\t\t\t\tif (v->track == TRACK_BIT_DEPOT) {\n\t\t\t\t\t/* Inside depot */\n\t\t\t\t\tgp.x = v->x_pos;\n\t\t\t\t\tgp.y = v->y_pos;\n\t\t\t\t\tv->reverse_distance = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* Not inside depot */\n\n\t\t\t\t\t/* Reverse when we are at the end of the track already, do not move to the new position */\n\t\t\t\t\tif (v->IsFrontEngine() && !TrainCheckIfLineEnds(v, reverse)) return false;\n\n\t\t\t\t\tuint32 r = VehicleEnterTile(v, gp.new_tile, gp.x, gp.y);\n\t\t\t\t\tif (HasBit(r, VETS_CANNOT_ENTER)) {\n\t\t\t\t\t\tgoto invalid_rail;\n\t\t\t\t\t}\n\t\t\t\t\tif (HasBit(r, VETS_ENTERED_STATION)) {\n\t\t\t\t\t\t/* The new position is the end of the platform */\n\t\t\t\t\t\tTrainEnterStation(v->First(), r >> VETS_STATION_ID_OFFSET);\n\t\t\t\t\t}\n\t\t\t\t\tif (old_direction != v->direction) notify_direction_changed(old_direction, v->direction);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* A new tile is about to be entered. */\n\n\t\t\t\t/* Determine what direction we're entering the new tile from */\n\t\t\t\tenterdir = DiagdirBetweenTiles(gp.old_tile, gp.new_tile);\n\t\t\t\tassert(IsValidDiagDirection(enterdir));\n\n\t\t\tenter_new_tile:\n\n\t\t\t\t/* Get the status of the tracks in the new tile and mask\n\t\t\t\t * away the bits that aren't reachable. */\n\t\t\t\tTrackStatus ts = GetTileTrackStatus(gp.new_tile, TRANSPORT_RAIL, 0, (v->track & TRACK_BIT_WORMHOLE) ? INVALID_DIAGDIR : ReverseDiagDir(enterdir));\n\t\t\t\tTrackdirBits reachable_trackdirs = DiagdirReachesTrackdirs(enterdir);\n\n\t\t\t\tTrackdirBits trackdirbits = TrackStatusToTrackdirBits(ts) & reachable_trackdirs;\n\t\t\t\tTrackBits red_signals = TrackdirBitsToTrackBits(TrackStatusToRedSignals(ts) & reachable_trackdirs);\n\n\t\t\t\tTrackBits bits = TrackdirBitsToTrackBits(trackdirbits);\n\t\t\t\tif (Rail90DegTurnDisallowedTilesFromDiagDir(gp.old_tile, gp.new_tile, enterdir) && prev == nullptr) {\n\t\t\t\t\t/* We allow wagons to make 90 deg turns, because forbid_90_deg\n\t\t\t\t\t * can be switched on halfway a turn */\n\t\t\t\t\tif (!(v->track & TRACK_BIT_WORMHOLE)) {\n\t\t\t\t\t\tbits &= ~TrackCrossesTracks(FindFirstTrack(v->track));\n\t\t\t\t\t}\n\t\t\t\t\telse if (v->track & TRACK_BIT_MASK) {\n\t\t\t\t\t\tbits &= ~TrackCrossesTracks(FindFirstTrack(v->track & TRACK_BIT_MASK));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (bits == TRACK_BIT_NONE) goto invalid_rail;\n\n\t\t\t\t/* Check if the new tile constrains tracks that are compatible\n\t\t\t\t * with the current train, if not, bail out. */\n\t\t\t\tif (!CheckCompatibleRail(v, gp.new_tile, enterdir)) goto invalid_rail;\n\n\t\t\t\tTrackBits chosen_track;\n\t\t\t\tif (prev == nullptr) {\n\t\t\t\t\t/* Currently the locomotive is active. Determine which one of the\n\t\t\t\t\t * available tracks to choose */\n\t\t\t\t\tchosen_track = TrackToTrackBits(ChooseTrainTrack(v, gp.new_tile, enterdir, bits, false, nullptr, true));\n\t\t\t\t\tassert_msg_tile(chosen_track & (bits | GetReservedTrackbits(gp.new_tile)), gp.new_tile, \"0x%X, 0x%X, 0x%X\", chosen_track, bits, GetReservedTrackbits(gp.new_tile));\n\n\t\t\t\t\tif (v->force_proceed != TFP_NONE && IsPlainRailTile(gp.new_tile) && HasSignals(gp.new_tile)) {\n\t\t\t\t\t\t/* For each signal we find decrease the counter by one.\n\t\t\t\t\t\t * We start at two, so the first signal we pass decreases\n\t\t\t\t\t\t * this to one, then if we reach the next signal it is\n\t\t\t\t\t\t * decreased to zero and we won't pass that new signal. */\n\t\t\t\t\t\tTrackdir dir = FindFirstTrackdir(trackdirbits);\n\t\t\t\t\t\tif (HasSignalOnTrackdir(gp.new_tile, dir) ||\n\t\t\t\t\t\t\t(HasSignalOnTrackdir(gp.new_tile, ReverseTrackdir(dir)) &&\n\t\t\t\t\t\t\t\tGetSignalType(gp.new_tile, TrackdirToTrack(dir)) != SIGTYPE_PBS)) {\n\t\t\t\t\t\t\t/* However, we do not want to be stopped by PBS signals\n\t\t\t\t\t\t\t * entered via the back. */\n\t\t\t\t\t\t\tv->force_proceed = (v->force_proceed == TFP_SIGNAL) ? TFP_STUCK : TFP_NONE;\n\t\t\t\t\t\t\tSetWindowDirty(WC_VEHICLE_VIEW, v->index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check if it's a red signal and that force proceed is not clicked. */\n\t\t\t\t\tif ((red_signals & chosen_track) && v->force_proceed == TFP_NONE) {\n\t\t\t\t\t\t/* In front of a red signal */\n\t\t\t\t\t\tTrackdir i = FindFirstTrackdir(trackdirbits);\n\n\t\t\t\t\t\t/* Don't handle stuck trains here. */\n\t\t\t\t\t\tif (HasBit(v->flags, VRF_TRAIN_STUCK)) return false;\n\n\t\t\t\t\t\tif (!HasSignalOnTrackdir(gp.new_tile, ReverseTrackdir(i))) {\n\t\t\t\t\t\t\tv->cur_speed = 0;\n\t\t\t\t\t\t\tv->subspeed = 0;\n\t\t\t\t\t\t\tv->progress = 255; // make sure that every bit of acceleration will hit the signal again, so speed stays 0.\n\t\t\t\t\t\t\tif (!_settings_game.pf.reverse_at_signals || ++v->wait_counter < _settings_game.pf.wait_oneway_signal * DAY_TICKS * 2) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (HasSignalOnTrackdir(gp.new_tile, i)) {\n\t\t\t\t\t\t\tv->cur_speed = 0;\n\t\t\t\t\t\t\tv->subspeed = 0;\n\t\t\t\t\t\t\tv->progress = 255; // make sure that every bit of acceleration will hit the signal again, so speed stays 0.\n\t\t\t\t\t\t\tif (!_settings_game.pf.reverse_at_signals || ++v->wait_counter < _settings_game.pf.wait_twoway_signal * DAY_TICKS * 2) {\n\t\t\t\t\t\t\t\tDiagDirection exitdir = TrackdirToExitdir(i);\n\t\t\t\t\t\t\t\tTileIndex o_tile = TileAddByDiagDir(gp.new_tile, exitdir);\n\n\t\t\t\t\t\t\t\texitdir = ReverseDiagDir(exitdir);\n\n\t\t\t\t\t\t\t\t/* check if a train is waiting on the other side */\n\t\t\t\t\t\t\t\tif (!HasVehicleOnPos(o_tile, VEH_TRAIN, &exitdir, &CheckTrainAtSignal)) return false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* If we would reverse but are currently in a PBS block and\n\t\t\t\t\t\t * reversing of stuck trains is disabled, don't reverse.\n\t\t\t\t\t\t * This does not apply if the reason for reversing is a one-way\n\t\t\t\t\t\t * signal blocking us, because a train would then be stuck forever. */\n\t\t\t\t\t\tif (!_settings_game.pf.reverse_at_signals && !HasOnewaySignalBlockingTrackdir(gp.new_tile, i) &&\n\t\t\t\t\t\t\tUpdateSignalsOnSegment(v->tile, enterdir, v->owner) == SIGSEG_PBS) {\n\t\t\t\t\t\t\tv->wait_counter = 0;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto reverse_train_direction;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tTryReserveRailTrack(gp.new_tile, TrackBitsToTrack(chosen_track), false);\n\n\t\t\t\t\t\tif (IsPlainRailTile(gp.new_tile) && HasSignals(gp.new_tile) && IsRestrictedSignal(gp.new_tile)) {\n\t\t\t\t\t\t\tconst Trackdir dir = FindFirstTrackdir(trackdirbits);\n\t\t\t\t\t\t\tif (HasSignalOnTrack(gp.new_tile, TrackdirToTrack(dir))) {\n\t\t\t\t\t\t\t\tconst TraceRestrictProgram* prog = GetExistingTraceRestrictProgram(gp.new_tile, TrackdirToTrack(dir));\n\t\t\t\t\t\t\t\tif (prog && prog->actions_used_flags & (TRPAUF_SLOT_ACQUIRE | TRPAUF_SLOT_RELEASE_FRONT | TRPAUF_REVERSE | TRPAUF_SPEED_RESTRICTION | TRPAUF_CHANGE_COUNTER)) {\n\t\t\t\t\t\t\t\t\tTraceRestrictProgramResult out;\n\t\t\t\t\t\t\t\t\tTraceRestrictProgramInput input(gp.new_tile, dir, nullptr, nullptr);\n\t\t\t\t\t\t\t\t\tinput.permitted_slot_operations = TRPISP_ACQUIRE | TRPISP_RELEASE_FRONT | TRPISP_CHANGE_COUNTER;\n\t\t\t\t\t\t\t\t\tprog->Execute(v, input, out);\n\t\t\t\t\t\t\t\t\tif (out.flags & TRPRF_REVERSE && GetSignalType(gp.new_tile, TrackdirToTrack(dir)) == SIGTYPE_PBS &&\n\t\t\t\t\t\t\t\t\t\t!HasSignalOnTrackdir(gp.new_tile, dir)) {\n\t\t\t\t\t\t\t\t\t\tv->reverse_distance = v->gcache.cached_total_length + (IsDiagonalTrack(TrackdirToTrack(dir)) ? 16 : 8);\n\t\t\t\t\t\t\t\t\t\tSetWindowDirty(WC_VEHICLE_VIEW, v->index);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (out.flags & TRPRF_SPEED_RETRICTION_SET) {\n\t\t\t\t\t\t\t\t\t\tSetBit(v->flags, VRF_PENDING_SPEED_RESTRICTION);\n\t\t\t\t\t\t\t\t\t\tauto range = pending_speed_restriction_change_map.equal_range(v->index);\n\t\t\t\t\t\t\t\t\t\tfor (auto it = range.first; it != range.second; ++it) {\n\t\t\t\t\t\t\t\t\t\t\tif ((uint16)(out.speed_restriction + 0xFFFF) < (uint16)(it->second.new_speed + 0xFFFF)) it->second.new_speed = out.speed_restriction;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tuint16 flags = 0;\n\t\t\t\t\t\t\t\t\t\tif (IsDiagonalTrack(TrackdirToTrack(dir))) SetBit(flags, PSRCF_DIAGONAL);\n\t\t\t\t\t\t\t\t\t\tpending_speed_restriction_change_map.insert({ v->index, { (uint16)(v->gcache.cached_total_length + (HasBit(flags, PSRCF_DIAGONAL) ? 8 : 4)), out.speed_restriction, v->speed_restriction, flags } });\n\t\t\t\t\t\t\t\t\t\tif ((uint16)(out.speed_restriction + 0xFFFF) < (uint16)(v->speed_restriction + 0xFFFF)) v->speed_restriction = out.speed_restriction;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* The wagon is active, simply follow the prev vehicle. */\n\t\t\t\t\tif (TileVirtXY(prev->x_pos, prev->y_pos) == gp.new_tile) {\n\t\t\t\t\t\t/* Choose the same track as prev */\n\t\t\t\t\t\tif (prev->track & TRACK_BIT_WORMHOLE) {\n\t\t\t\t\t\t\t/* Vehicles entering tunnels enter the wormhole earlier than for bridges.\n\t\t\t\t\t\t\t * However, just choose the track into the wormhole. */\n\t\t\t\t\t\t\tassert_tile(IsTunnel(prev->tile), prev->tile);\n\t\t\t\t\t\t\tchosen_track = bits;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tchosen_track = prev->track;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t/* Choose the track that leads to the tile where prev is.\n\t\t\t\t\t\t * This case is active if 'prev' is already on the second next tile, when 'v' just enters the next tile.\n\t\t\t\t\t\t * I.e. when the tile between them has only space for a single vehicle like\n\t\t\t\t\t\t *  1) horizontal/vertical track tiles and\n\t\t\t\t\t\t *  2) some orientations of tunnel entries, where the vehicle is already inside the wormhole at 8/16 from the tile edge.\n\t\t\t\t\t\t *     Is also the train just reversing, the wagon inside the tunnel is 'on' the tile of the opposite tunnel entry.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstatic const TrackBits _connecting_track[DIAGDIR_END][DIAGDIR_END] = {\n\t\t\t\t\t\t\t{TRACK_BIT_X,     TRACK_BIT_LOWER, TRACK_BIT_NONE,  TRACK_BIT_LEFT },\n\t\t\t\t\t\t\t{TRACK_BIT_UPPER, TRACK_BIT_Y,     TRACK_BIT_LEFT,  TRACK_BIT_NONE },\n\t\t\t\t\t\t\t{TRACK_BIT_NONE,  TRACK_BIT_RIGHT, TRACK_BIT_X,     TRACK_BIT_UPPER},\n\t\t\t\t\t\t\t{TRACK_BIT_RIGHT, TRACK_BIT_NONE,  TRACK_BIT_LOWER, TRACK_BIT_Y    }\n\t\t\t\t\t\t};\n\t\t\t\t\t\tDiagDirection exitdir = DiagdirBetweenTiles(gp.new_tile, TileVirtXY(prev->x_pos, prev->y_pos));\n\t\t\t\t\t\tassert(IsValidDiagDirection(exitdir));\n\t\t\t\t\t\tchosen_track = _connecting_track[enterdir][exitdir];\n\t\t\t\t\t}\n\t\t\t\t\tchosen_track &= bits;\n\t\t\t\t}\n\n\t\t\t\t/* Make sure chosen track is a valid track */\n\t\t\t\tassert(\n\t\t\t\t\tchosen_track == TRACK_BIT_X || chosen_track == TRACK_BIT_Y ||\n\t\t\t\t\tchosen_track == TRACK_BIT_UPPER || chosen_track == TRACK_BIT_LOWER ||\n\t\t\t\t\tchosen_track == TRACK_BIT_LEFT || chosen_track == TRACK_BIT_RIGHT);\n\n\t\t\t\t/* Update XY to reflect the entrance to the new tile, and select the direction to use */\n\t\t\t\tconst byte* b = _initial_tile_subcoord[FIND_FIRST_BIT(chosen_track)][enterdir];\n\t\t\t\tgp.x = (gp.x & ~0xF) | b[0];\n\t\t\t\tgp.y = (gp.y & ~0xF) | b[1];\n\t\t\t\tDirection chosen_dir = (Direction)b[2];\n\n\t\t\t\t/* Call the landscape function and tell it that the vehicle entered the tile */\n\t\t\t\tuint32 r = (v->track & TRACK_BIT_WORMHOLE) ? 0 : VehicleEnterTile(v, gp.new_tile, gp.x, gp.y);\n\t\t\t\tif (HasBit(r, VETS_CANNOT_ENTER)) {\n\t\t\t\t\tgoto invalid_rail;\n\t\t\t\t}\n\n\t\t\t\tif (!(v->track & TRACK_BIT_WORMHOLE) && IsTunnelBridgeWithSignalSimulation(gp.new_tile) && (GetAcrossTunnelBridgeTrackBits(gp.new_tile) & chosen_track)) {\n\t\t\t\t\t/* If red signal stop. */\n\t\t\t\t\tif (v->IsFrontEngine() && v->force_proceed == 0) {\n\t\t\t\t\t\tif (IsTunnelBridgeSignalSimulationEntrance(gp.new_tile) && GetTunnelBridgeEntranceSignalState(gp.new_tile) == SIGNAL_STATE_RED) {\n\t\t\t\t\t\t\tv->cur_speed = 0;\n\t\t\t\t\t\t\tv->vehstatus |= VS_TRAIN_SLOWING;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (IsTunnelBridgeSignalSimulationExitOnly(gp.new_tile) &&\n\t\t\t\t\t\t\tTrackdirEntersTunnelBridge(gp.new_tile, TrackDirectionToTrackdir(FindFirstTrack(chosen_track), chosen_dir))) {\n\t\t\t\t\t\t\tv->cur_speed = 0;\n\t\t\t\t\t\t\tgoto invalid_rail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Flip signal on tunnel entrance tile red. */\n\t\t\t\t\t\tSetTunnelBridgeEntranceSignalState(gp.new_tile, SIGNAL_STATE_RED);\n\t\t\t\t\t\tMarkTileDirtyByTile(gp.new_tile);\n\t\t\t\t\t\tif (IsTunnelBridgeSignalSimulationBidirectional(gp.new_tile)) {\n\t\t\t\t\t\t\t/* Set incoming signal in other direction to red as well */\n\t\t\t\t\t\t\tTileIndex other_end = GetOtherTunnelBridgeEnd(gp.new_tile);\n\t\t\t\t\t\t\tSetTunnelBridgeEntranceSignalState(other_end, SIGNAL_STATE_RED);\n\t\t\t\t\t\t\tMarkTileDirtyByTile(other_end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!HasBit(r, VETS_ENTERED_WORMHOLE)) {\n\t\t\t\t\tTrack track = FindFirstTrack(chosen_track);\n\t\t\t\t\tTrackdir tdir = TrackDirectionToTrackdir(track, chosen_dir);\n\t\t\t\t\tif (v->IsFrontEngine() && HasPbsSignalOnTrackdir(gp.new_tile, tdir)) {\n\t\t\t\t\t\tSetSignalStateByTrackdir(gp.new_tile, tdir, SIGNAL_STATE_RED);\n\t\t\t\t\t\tMarkSingleSignalDirty(gp.new_tile, tdir);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Clear any track reservation when the last vehicle leaves the tile */\n\t\t\t\t\tif (v->Next() == nullptr && !(v->track & TRACK_BIT_WORMHOLE)) ClearPathReservation(v, v->tile, v->GetVehicleTrackdir(), true);\n\n\t\t\t\t\tv->tile = gp.new_tile;\n\t\t\t\t\tv->track = chosen_track;\n\t\t\t\t\tassert(v->track);\n\n\t\t\t\t\tif (GetTileRailTypeByTrackBit(gp.new_tile, chosen_track) != GetTileRailTypeByTrackBit(gp.old_tile, old_trackbits)) {\n\t\t\t\t\t\t/* v->track and v->tile must both be valid and consistent before this is called */\n\t\t\t\t\t\tv->First()->ConsistChanged(CCF_TRACK);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* We need to update signal status, but after the vehicle position hash\n\t\t\t\t * has been updated by UpdateInclination() */\n\t\t\t\tupdate_signals_crossing = true;\n\n\t\t\t\tif (chosen_dir != v->direction) {\n\t\t\t\t\tnotify_direction_changed(v->direction, chosen_dir);\n\t\t\t\t\tv->direction = chosen_dir;\n\t\t\t\t}\n\n\t\t\t\tif (v->IsFrontEngine()) {\n\t\t\t\t\tv->wait_counter = 0;\n\n\t\t\t\t\t/* If we are approaching a crossing that is reserved, play the sound now. */\n\t\t\t\t\tTileIndex crossing = TrainApproachingCrossingTile(v);\n\t\t\t\t\tif (crossing != INVALID_TILE && HasCrossingReservation(crossing) && _settings_client.sound.ambient) SndPlayTileFx(SND_0E_LEVEL_CROSSING, crossing);\n\n\t\t\t\t\t/* Always try to extend the reservation when entering a tile. */\n\t\t\t\t\tCheckNextTrainTile(v);\n\t\t\t\t}\n\n\t\t\t\tif (HasBit(r, VETS_ENTERED_STATION)) {\n\t\t\t\t\t/* The new position is the location where we want to stop */\n\t\t\t\t\tTrainEnterStation(v->First(), r >> VETS_STATION_ID_OFFSET);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Handle signal simulation on tunnel/bridge. */\n\t\t\tTileIndex old_tile = TileVirtXY(v->x_pos, v->y_pos);\n\t\t\tif (old_tile != gp.new_tile && IsTunnelBridgeWithSignalSimulation(v->tile) && (v->IsFrontEngine() || v->Next() == nullptr)) {\n\t\t\t\tif (old_tile == v->tile) {\n\t\t\t\t\tif (v->IsFrontEngine() && v->force_proceed == 0 && IsTunnelBridgeSignalSimulationExitOnly(v->tile)) goto invalid_rail;\n\t\t\t\t\t/* Entered wormhole set counters. */\n\t\t\t\t\tv->wait_counter = (TILE_SIZE * _settings_game.construction.simulated_wormhole_signals) - TILE_SIZE;\n\t\t\t\t\tv->tunnel_bridge_signal_num = 0;\n\t\t\t\t}\n\n\t\t\t\tuint distance = v->wait_counter;\n\t\t\t\tbool leaving = false;\n\t\t\t\tif (distance == 0) v->wait_counter = (TILE_SIZE * _settings_game.construction.simulated_wormhole_signals);\n\n\t\t\t\tif (v->IsFrontEngine()) {\n\t\t\t\t\t/* Check if track in front is free and see if we can leave wormhole. */\n\t\t\t\t\tint z = GetSlopePixelZ(gp.x, gp.y) - v->z_pos;\n\t\t\t\t\tif (IsTileType(gp.new_tile, MP_TUNNELBRIDGE) && !(abs(z) > 2)) {\n\t\t\t\t\t\tif (CheckTrainStayInWormHole(v, gp.new_tile)) {\n\t\t\t\t\t\t\tv->cur_speed = 0;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleaving = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (IsTooCloseBehindTrain(v, gp.new_tile, v->wait_counter, distance == 0)) {\n\t\t\t\t\t\t\tif (distance == 0) v->wait_counter = 0;\n\t\t\t\t\t\t\tv->cur_speed = 0;\n\t\t\t\t\t\t\tv->vehstatus |= VS_TRAIN_SLOWING;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* flip signal in front to red on bridges*/\n\t\t\t\t\t\tif (distance == 0 && IsBridge(v->tile)) {\n\t\t\t\t\t\t\tSetBridgeEntranceSimulatedSignalState(v->tile, v->tunnel_bridge_signal_num, SIGNAL_STATE_RED);\n\t\t\t\t\t\t\tMarkTileDirtyByTile(gp.new_tile);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v->Next() == nullptr) {\n\t\t\t\t\tif (v->tunnel_bridge_signal_num > 0 && distance == (TILE_SIZE * _settings_game.construction.simulated_wormhole_signals) - TILE_SIZE) HandleSignalBehindTrain(v, v->tunnel_bridge_signal_num - 2);\n\t\t\t\t\tDiagDirection tunnel_bridge_dir = GetTunnelBridgeDirection(v->tile);\n\t\t\t\t\tAxis axis = DiagDirToAxis(tunnel_bridge_dir);\n\t\t\t\t\tDiagDirection axial_dir = DirToDiagDirAlongAxis(v->direction, axis);\n\t\t\t\t\tif (old_tile == ((axial_dir == tunnel_bridge_dir) ? v->tile : GetOtherTunnelBridgeEnd(v->tile))) {\n\t\t\t\t\t\t/* We left ramp into wormhole. */\n\t\t\t\t\t\tv->x_pos = gp.x;\n\t\t\t\t\t\tv->y_pos = gp.y;\n\t\t\t\t\t\tUpdateSignalsOnSegment(old_tile, INVALID_DIAGDIR, v->owner);\n\t\t\t\t\t\tUnreserveBridgeTunnelTile(old_tile);\n\t\t\t\t\t\tif (_settings_client.gui.show_track_reservation) MarkTileDirtyByTile(old_tile, ZOOM_LVL_DRAW_MAP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (distance == 0) v->tunnel_bridge_signal_num++;\n\t\t\t\tv->wait_counter -= TILE_SIZE;\n\n\t\t\t\tif (leaving) { // Reset counters.\n\t\t\t\t\tv->force_proceed = TFP_NONE;\n\t\t\t\t\tv->wait_counter = 0;\n\t\t\t\t\tv->tunnel_bridge_signal_num = 0;\n\t\t\t\t\tupdate_signal_tunbridge_exit = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (old_tile == gp.new_tile && IsTunnelBridgeWithSignalSimulation(v->tile) && v->IsFrontEngine()) {\n\t\t\t\tAxis axis = DiagDirToAxis(GetTunnelBridgeDirection(v->tile));\n\t\t\t\tDiagDirection axial_dir = DirToDiagDirAlongAxis(v->direction, axis);\n\t\t\t\tTileIndex next_tile = old_tile + TileOffsByDiagDir(axial_dir);\n\t\t\t\tbool is_exit = false;\n\t\t\t\tif (IsTileType(next_tile, MP_TUNNELBRIDGE) && IsTunnelBridgeWithSignalSimulation(next_tile) &&\n\t\t\t\t\tReverseDiagDir(GetTunnelBridgeDirection(next_tile)) == axial_dir) {\n\t\t\t\t\tif (IsBridge(next_tile) && IsBridge(v->tile)) {\n\t\t\t\t\t\t// bridge ramp facing towards us\n\t\t\t\t\t\tis_exit = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (IsTunnel(next_tile) && IsTunnel(v->tile)) {\n\t\t\t\t\t\t// tunnel exit at same height\n\t\t\t\t\t\tis_exit = (GetTileZ(next_tile) == GetTileZ(v->tile));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_exit) {\n\t\t\t\t\tif (CheckTrainStayInWormHole(v, next_tile)) {\n\t\t\t\t\t\tTrainApproachingLineEnd(v, true, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (v->wait_counter == 0) {\n\t\t\t\t\tif (IsTooCloseBehindTrain(v, next_tile, TILE_SIZE * _settings_game.construction.simulated_wormhole_signals, true)) {\n\t\t\t\t\t\tTrainApproachingLineEnd(v, true, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (IsTileType(gp.new_tile, MP_TUNNELBRIDGE) && HasBit(VehicleEnterTile(v, gp.new_tile, gp.x, gp.y), VETS_ENTERED_WORMHOLE)) {\n\t\t\t\t/* Perform look-ahead on tunnel exit. */\n\t\t\t\tif (IsRailCustomBridgeHeadTile(gp.new_tile)) {\n\t\t\t\t\tenterdir = ReverseDiagDir(GetTunnelBridgeDirection(gp.new_tile));\n\t\t\t\t\tgoto enter_new_tile;\n\t\t\t\t}\n\t\t\t\tif (v->IsFrontEngine()) {\n\t\t\t\t\tTryReserveRailTrack(gp.new_tile, DiagDirToDiagTrack(GetTunnelBridgeDirection(gp.new_tile)));\n\t\t\t\t\tCheckNextTrainTile(v);\n\t\t\t\t}\n\t\t\t\t/* Prevent v->UpdateInclination() being called with wrong parameters.\n\t\t\t\t * This could happen if the train was reversed inside the tunnel/bridge. */\n\t\t\t\tif (gp.old_tile == gp.new_tile) {\n\t\t\t\t\tgp.old_tile = GetOtherTunnelBridgeEnd(gp.old_tile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv->x_pos = gp.x;\n\t\t\t\tv->y_pos = gp.y;\n\t\t\t\tv->UpdatePosition();\n\t\t\t\tv->UpdateDeltaXY();\n\t\t\t\tif (HasBit(v->gv_flags, GVF_CHUNNEL_BIT)) {\n\t\t\t\t\t/* update the Z position of the vehicle */\n\t\t\t\t\tint old_z = v->UpdateInclination(false, false, true);\n\n\t\t\t\t\tif (prev == nullptr) {\n\t\t\t\t\t\t/* This is the first vehicle in the train */\n\t\t\t\t\t\tAffectSpeedByZChange(v, old_z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v->IsDrawn()) v->Vehicle::UpdateViewport(true);\n\t\t\t\tif (update_signal_tunbridge_exit) {\n\t\t\t\t\tUpdateSignalsOnSegment(gp.new_tile, INVALID_DIAGDIR, v->owner);\n\t\t\t\t\tupdate_signal_tunbridge_exit = false;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* update image of train, as well as delta XY */\n\t\tv->UpdateDeltaXY();\n\n\t\tv->x_pos = gp.x;\n\t\tv->y_pos = gp.y;\n\t\tv->UpdatePosition();\n\t\tif (v->reverse_distance > 1) {\n\t\t\tv->reverse_distance--;\n\t\t}\n\t\tif (HasBit(v->flags, VRF_PENDING_SPEED_RESTRICTION)) {\n\t\t\tauto range = pending_speed_restriction_change_map.equal_range(v->index);\n\t\t\tif (range.first == range.second) ClrBit(v->flags, VRF_PENDING_SPEED_RESTRICTION);\n\t\t\tfor (auto it = range.first; it != range.second;) {\n\t\t\t\tif (--it->second.distance == 0) {\n\t\t\t\t\tv->speed_restriction = it->second.new_speed;\n\t\t\t\t\tit = pending_speed_restriction_change_map.erase(it);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* update the Z position of the vehicle */\n\t\tint old_z = v->UpdateInclination(gp.new_tile != gp.old_tile, false, v->track == TRACK_BIT_WORMHOLE);\n\n\t\tif (prev == nullptr) {\n\t\t\t/* This is the first vehicle in the train */\n\t\t\tAffectSpeedByZChange(v, old_z);\n\t\t}\n\n\t\tif (update_signal_tunbridge_exit) {\n\t\t\tUpdateSignalsOnSegment(gp.new_tile, INVALID_DIAGDIR, v->owner);\n\t\t\tupdate_signal_tunbridge_exit = false;\n\t\t}\n\n\t\tif (update_signals_crossing) {\n\t\t\tif (v->IsFrontEngine()) {\n\t\t\t\tswitch (TrainMovedChangeSignal(v, gp.new_tile, enterdir)) {\n\t\t\t\tcase CHANGED_NORMAL_TO_PBS_BLOCK:\n\t\t\t\t\t/* We are entering a block with PBS signals right now, but\n\t\t\t\t\t* not through a PBS signal. This means we don't have a\n\t\t\t\t\t* reservation right now. As a conventional signal will only\n\t\t\t\t\t* ever be green if no other train is in the block, getting\n\t\t\t\t\t* a path should always be possible. If the player built\n\t\t\t\t\t* such a strange network that it is not possible, the train\n\t\t\t\t\t* will be marked as stuck and the player has to deal with\n\t\t\t\t\t* the problem. */\n\t\t\t\t\tif ((!HasReservedTracks(gp.new_tile, v->track) &&\n\t\t\t\t\t\t!TryReserveRailTrack(gp.new_tile, FindFirstTrack(v->track))) ||\n\t\t\t\t\t\t!TryPathReserve(v)) {\n\t\t\t\t\t\tMarkTrainAsStuck(v);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CHANGED_LR_PBS:\n\t\t\t\t{\n\t\t\t\t\t/* We went past a long reserve PBS signal. Try to extend the\n\t\t\t\t\t* reservation if reserving failed at another LR signal. */\n\t\t\t\t\tPBSTileInfo origin = FollowTrainReservation(v);\n\t\t\t\t\tCFollowTrackRail ft(v);\n\n\t\t\t\t\tif (ft.Follow(origin.tile, origin.trackdir)) {\n\t\t\t\t\t\tTrackdir  new_td = FindFirstTrackdir(ft.m_new_td_bits);\n\n\t\t\t\t\t\tif (HasLongReservePbsSignalOnTrackdir(v, ft.m_new_tile, new_td)) {\n\t\t\t\t\t\t\tChooseTrainTrack(v, ft.m_new_tile, ft.m_exitdir, TrackdirBitsToTrackBits(ft.m_new_td_bits), true, nullptr, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Signals can only change when the first\n\t\t\t * (above) or the last vehicle moves. */\n\t\t\tif (v->Next() == nullptr) {\n\t\t\t\tTrainMovedChangeSignal(v, gp.old_tile, ReverseDiagDir(enterdir));\n\t\t\t\tif (IsLevelCrossingTile(gp.old_tile)) UpdateLevelCrossing(gp.old_tile);\n\n\t\t\t\tif (IsTileType(gp.old_tile, MP_RAILWAY) && HasSignals(gp.old_tile) && IsRestrictedSignal(gp.old_tile)) {\n\t\t\t\t\tconst TrackdirBits rev_tracks = TrackBitsToTrackdirBits(GetTrackBits(gp.old_tile)) & DiagdirReachesTrackdirs(ReverseDiagDir(enterdir));\n\t\t\t\t\tconst Trackdir rev_trackdir = FindFirstTrackdir(rev_tracks);\n\t\t\t\t\tconst Track track = TrackdirToTrack(rev_trackdir);\n\t\t\t\t\tif (HasSignalOnTrack(gp.old_tile, track)) {\n\t\t\t\t\t\tconst TraceRestrictProgram* prog = GetExistingTraceRestrictProgram(gp.old_tile, track);\n\t\t\t\t\t\tif (prog && prog->actions_used_flags & TRPAUF_SLOT_RELEASE_BACK) {\n\t\t\t\t\t\t\tTraceRestrictProgramResult out;\n\t\t\t\t\t\t\tTraceRestrictProgramInput input(gp.old_tile, ReverseTrackdir(rev_trackdir), nullptr, nullptr);\n\t\t\t\t\t\t\tinput.permitted_slot_operations = TRPISP_RELEASE_BACK;\n\t\t\t\t\t\t\tprog->Execute(first, input, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Do not check on every tick to save some computing time. */\n\t\tif (v->IsFrontEngine() && v->tick_counter % _settings_game.pf.path_backoff_interval == 0) CheckNextTrainTile(v);\n\t}\n\n\tif (direction_changed) first->tcache.cached_max_curve_speed = first->GetCurveSpeedLimit();\n\n\treturn true;\n\ninvalid_rail:\n\t/* We've reached end of line?? */\n\tif (prev != nullptr) return true; //error(\"Disconnecting train\");\n\nreverse_train_direction:\n\tif (old_trackbits != INVALID_TRACK_BIT && (v->track ^ old_trackbits) & TRACK_BIT_WORMHOLE) {\n\t\t/* Entering/exiting wormhole failed/aborted, back out changes to vehicle direction and track */\n\t\tv->track = old_trackbits;\n\t\tv->direction = old_direction;\n\t\tv->gv_flags = old_gv_flags;\n\t}\n\tif (reverse) {\n\t\tv->wait_counter = 0;\n\t\tv->cur_speed = 0;\n\t\tv->subspeed = 0;\n\t\tReverseTrainDirection(v);\n\t}\n\n\treturn false;\n}\n\nstatic TrackBits GetTrackbitsFromCrashedVehicle(Train* t)\n{\n\tTrackBits train_tbits = t->track;\n\tif (train_tbits & TRACK_BIT_WORMHOLE) {\n\t\t/* Vehicle is inside a wormhole, v->track contains no useful value then. */\n\t\ttrain_tbits = GetAcrossTunnelBridgeReservationTrackBits(t->tile);\n\t\tif (train_tbits != TRACK_BIT_NONE) return train_tbits;\n\t\t/* Pick the first available tunnel/bridge head track which could be reserved */\n\t\ttrain_tbits = GetAcrossTunnelBridgeTrackBits(t->tile);\n\t\treturn train_tbits ^ KillFirstBit(train_tbits);\n\t}\n\telse {\n\t\treturn train_tbits;\n\t}\n}\n\n/**\n * Collect trackbits of all crashed train vehicles on a tile\n * @param v Vehicle passed from Find/HasVehicleOnPos()\n * @param data trackdirbits for the result\n * @return nullptr to iterate over all vehicles on the tile.\n */\nstatic Vehicle* CollectTrackbitsFromCrashedVehiclesEnum(Vehicle* v, void* data)\n{\n\tTrackBits* trackbits = (TrackBits*)data;\n\n\tif ((v->vehstatus & VS_CRASHED) != 0) {\n\t\tif (Train::From(v)->track != TRACK_BIT_DEPOT) {\n\t\t\t*trackbits |= GetTrackbitsFromCrashedVehicle(Train::From(v));\n\t\t}\n\t}\n\n\treturn nullptr;\n}\n\nstatic void SetSignalledBridgeTunnelGreenIfClear(TileIndex tile, TileIndex end)\n{\n\tif (TunnelBridgeIsFree(tile, end, nullptr, true).Succeeded()) {\n\t\tauto process_tile = [](TileIndex t) {\n\t\t\tif (IsTunnelBridgeSignalSimulationEntrance(t)) {\n\t\t\t\tif (IsBridge(t)) {\n\t\t\t\t\tSetAllBridgeEntranceSimulatedSignalsGreen(t);\n\t\t\t\t\tMarkBridgeDirty(t, ZOOM_LVL_DRAW_MAP);\n\t\t\t\t}\n\t\t\t\tif (IsTunnelBridgeSignalSimulationEntrance(t) && GetTunnelBridgeEntranceSignalState(t) == SIGNAL_STATE_RED) {\n\t\t\t\t\tSetTunnelBridgeEntranceSignalState(t, SIGNAL_STATE_GREEN);\n\t\t\t\t\tMarkTileDirtyByTile(t, ZOOM_LVL_DRAW_MAP);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tprocess_tile(tile);\n\t\tprocess_tile(end);\n\t}\n}\n\n/**\n * Deletes/Clears the last wagon of a crashed train. It takes the engine of the\n * train, then goes to the last wagon and deletes that. Each call to this function\n * will remove the last wagon of a crashed train. If this wagon was on a crossing,\n * or inside a tunnel/bridge, recalculate the signals as they might need updating\n * @param v the Vehicle of which last wagon is to be removed\n */\nstatic void DeleteLastWagon(Train* v)\n{\n\tTrain* first = v->First();\n\n\t/* Go to the last wagon and delete the link pointing there\n\t * *u is then the one-before-last wagon, and *v the last\n\t * one which will physically be removed */\n\tTrain* u = v;\n\tfor (; v->Next() != nullptr; v = v->Next()) u = v;\n\tu->SetNext(nullptr);\n\n\tif (first != v) {\n\t\t/* Recalculate cached train properties */\n\t\tfirst->ConsistChanged(CCF_ARRANGE);\n\t\t/* Update the depot window if the first vehicle is in depot -\n\t\t * if v == first, then it is updated in PreDestructor() */\n\t\tif (first->track == TRACK_BIT_DEPOT) {\n\t\t\tSetWindowDirty(WC_VEHICLE_DEPOT, first->tile);\n\t\t}\n\t\tv->last_station_visited = first->last_station_visited; // for PreDestructor\n\t}\n\n\t/* 'v' shouldn't be accessed after it has been deleted */\n\tconst TrackBits orig_trackbits = v->track;\n\tTrackBits trackbits = GetTrackbitsFromCrashedVehicle(v);\n\tconst TileIndex tile = v->tile;\n\tconst Owner owner = v->owner;\n\n\tdelete v;\n\tv = nullptr; // make sure nobody will try to read 'v' anymore\n\n\tTrack track = TrackBitsToTrack(trackbits);\n\tif (HasReservedTracks(tile, trackbits)) {\n\t\tUnreserveRailTrack(tile, track);\n\n\t\t/* If there are still crashed vehicles on the tile, give the track reservation to them */\n\t\tTrackBits remaining_trackbits = TRACK_BIT_NONE;\n\t\tFindVehicleOnPos(tile, VEH_TRAIN, &remaining_trackbits, CollectTrackbitsFromCrashedVehiclesEnum);\n\n\t\t/* It is important that these two are the first in the loop, as reservation cannot deal with every trackbit combination */\n\t\tassert(TRACK_BEGIN == TRACK_X && TRACK_Y == TRACK_BEGIN + 1);\n\t\tTrack t;\n\t\tFOR_EACH_SET_TRACK(t, remaining_trackbits) TryReserveRailTrack(tile, t);\n\t}\n\n\t/* check if the wagon was on a road/rail-crossing */\n\tif (IsLevelCrossingTile(tile)) UpdateLevelCrossing(tile);\n\n\t/* Update signals */\n\tif (IsTunnelBridgeWithSignalSimulation(tile)) {\n\t\tTileIndex end = GetOtherTunnelBridgeEnd(tile);\n\t\tUpdateSignalsOnSegment(end, INVALID_DIAGDIR, owner);\n\t\tSetSignalledBridgeTunnelGreenIfClear(tile, end);\n\t}\n\tif ((orig_trackbits & TRACK_BIT_WORMHOLE) || IsRailDepotTile(tile)) {\n\t\tUpdateSignalsOnSegment(tile, INVALID_DIAGDIR, owner);\n\t}\n\telse {\n\t\tSetSignalsOnBothDir(tile, track, owner);\n\t}\n}\n\n/**\n * Rotate all vehicles of a (crashed) train chain randomly to animate the crash.\n * @param v First crashed vehicle.\n */\nstatic void ChangeTrainDirRandomly(Train* v)\n{\n\tstatic const DirDiff delta[] = {\n\t\tDIRDIFF_45LEFT, DIRDIFF_SAME, DIRDIFF_SAME, DIRDIFF_45RIGHT\n\t};\n\n\tdo {\n\t\t/* We don't need to twist around vehicles if they're not visible */\n\t\tif (!(v->vehstatus & VS_HIDDEN)) {\n\t\t\tv->direction = ChangeDir(v->direction, delta[GB(Random(), 0, 2)]);\n\t\t\t/* Refrain from updating the z position of the vehicle when on\n\t\t\t * a bridge, because UpdateInclination() will put the vehicle under\n\t\t\t * the bridge in that case */\n\t\t\tif (!(v->track & TRACK_BIT_WORMHOLE)) {\n\t\t\t\tv->UpdatePosition();\n\t\t\t\tv->UpdateInclination(false, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv->UpdateViewport(false, true);\n\t\t\t}\n\t\t}\n\t} while ((v = v->Next()) != nullptr);\n}\n\n/**\n * Handle a crashed train.\n * @param v First train vehicle.\n * @return %Vehicle chain still exists.\n */\nstatic bool HandleCrashedTrain(Train* v)\n{\n\tint state = ++v->crash_anim_pos;\n\n\tif (state == 4 && !(v->vehstatus & VS_HIDDEN)) {\n\t\tCreateEffectVehicleRel(v, 4, 4, 8, EV_EXPLOSION_LARGE);\n\t}\n\n\tuint32 r;\n\tif (state <= 200 && Chance16R(1, 7, r)) {\n\t\tint index = (r * 10 >> 16);\n\n\t\tVehicle* u = v;\n\t\tdo {\n\t\t\tif (--index < 0) {\n\t\t\t\tr = Random();\n\n\t\t\t\tCreateEffectVehicleRel(u,\n\t\t\t\t\tGB(r, 8, 3) + 2,\n\t\t\t\t\tGB(r, 16, 3) + 2,\n\t\t\t\t\tGB(r, 0, 3) + 5,\n\t\t\t\t\tEV_EXPLOSION_SMALL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((u = u->Next()) != nullptr);\n\t}\n\n\tif (state <= 240 && !(v->tick_counter & 3)) ChangeTrainDirRandomly(v);\n\n\tif (state >= 4440 && !(v->tick_counter & 0x1F)) {\n\t\tbool ret = v->Next() != nullptr;\n\t\tDeleteLastWagon(v);\n\t\treturn ret;\n\t}\n\n\treturn true;\n}\n\n/** Maximum speeds for train that is broken down or approaching line end */\nstatic const uint16 _breakdown_speeds[16] = {\n\t225, 210, 195, 180, 165, 150, 135, 120, 105, 90, 75, 60, 45, 30, 15, 15\n};\n\n\n/**\n * Train is approaching line end, slow down and possibly reverse\n *\n * @param v front train engine\n * @param signal not line end, just a red signal\n * @param reverse Set to false to not execute the vehicle reversing. This does not change any other logic.\n * @return true iff we did NOT have to reverse\n */\nstatic bool TrainApproachingLineEnd(Train* v, bool signal, bool reverse)\n{\n\t/* Calc position within the current tile */\n\tuint x = v->x_pos & 0xF;\n\tuint y = v->y_pos & 0xF;\n\n\t/* for diagonal directions, 'x' will be 0..15 -\n\t * for other directions, it will be 1, 3, 5, ..., 15 */\n\tswitch (v->direction) {\n\tcase DIR_N: x = ~x + ~y + 25; break;\n\tcase DIR_NW: x = y;            FALLTHROUGH;\n\tcase DIR_NE: x = ~x + 16;      break;\n\tcase DIR_E: x = ~x + y + 9;   break;\n\tcase DIR_SE: x = y;            break;\n\tcase DIR_S: x = x + y - 7;    break;\n\tcase DIR_W: x = ~y + x + 9;   break;\n\tdefault: break;\n\t}\n\n\t/* Do not reverse when approaching red signal. Make sure the vehicle's front\n\t * does not cross the tile boundary when we do reverse, but as the vehicle's\n\t * location is based on their center, use half a vehicle's length as offset.\n\t * Multiply the half-length by two for straight directions to compensate that\n\t * we only get odd x offsets there. */\n\tif (!signal && x + (v->gcache.cached_veh_length + 1) / 2 * (IsDiagonalDirection(v->direction) ? 1 : 2) >= TILE_SIZE) {\n\t\t/* we are too near the tile end, reverse now */\n\t\tv->cur_speed = 0;\n\t\tif (reverse) ReverseTrainDirection(v);\n\t\treturn false;\n\t}\n\n\t/* slow down */\n\tv->vehstatus |= VS_TRAIN_SLOWING;\n\tuint16 break_speed = _breakdown_speeds[x & 0xF];\n\tif (break_speed < v->cur_speed) v->cur_speed = break_speed;\n\n\treturn true;\n}\n\n\n/**\n * Determines whether train would like to leave the tile\n * @param v train to test\n * @return true iff vehicle is NOT entering or inside a depot or tunnel/bridge\n */\nstatic bool TrainCanLeaveTile(const Train* v)\n{\n\t/* Exit if inside a tunnel/bridge or a depot */\n\tif (v->track & TRACK_BIT_WORMHOLE || v->track == TRACK_BIT_DEPOT) return false;\n\n\tTileIndex tile = v->tile;\n\n\t/* entering a tunnel/bridge? */\n\tif (IsTileType(tile, MP_TUNNELBRIDGE)) {\n\t\tDiagDirection dir = GetTunnelBridgeDirection(tile);\n\t\tif (DiagDirToDir(dir) == v->direction) return false;\n\t\tif (IsRailCustomBridgeHeadTile(tile) && VehicleExitDir(v->direction, v->track) == dir) {\n\t\t\tif (_settings_game.pf.forbid_90_deg && v->Previous() == nullptr && GetTunnelBridgeLength(tile, GetOtherTunnelBridgeEnd(tile)) == 0) {\n\t\t\t\t/* Check for 90 degree turn on zero-length bridge span */\n\t\t\t\tif (!(GetCustomBridgeHeadTrackBits(tile) & ~TrackCrossesTracks(FindFirstTrack(v->track)))) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* entering a depot? */\n\tif (IsRailDepotTile(tile)) {\n\t\tDiagDirection dir = ReverseDiagDir(GetRailDepotDirection(tile));\n\t\tif (DiagDirToDir(dir) == v->direction) return false;\n\t}\n\n\treturn true;\n}\n\n\n/**\n * Determines whether train is approaching a rail-road crossing\n *   (thus making it barred)\n * @param v front engine of train\n * @return TileIndex of crossing the train is approaching, else INVALID_TILE\n * @pre v in non-crashed front engine\n */\nstatic TileIndex TrainApproachingCrossingTile(const Train* v)\n{\n\tassert(v->IsFrontEngine());\n\tassert(!(v->vehstatus & VS_CRASHED));\n\n\tif (!TrainCanLeaveTile(v)) return INVALID_TILE;\n\n\tDiagDirection dir = VehicleExitDir(v->direction, v->track);\n\tTileIndex tile = v->tile + TileOffsByDiagDir(dir);\n\n\t/* not a crossing || wrong axis || unusable rail (wrong type or owner) */\n\tif (!IsLevelCrossingTile(tile) || DiagDirToAxis(dir) == GetCrossingRoadAxis(tile) ||\n\t\t!CheckCompatibleRail(v, tile, dir)) {\n\t\treturn INVALID_TILE;\n\t}\n\n\treturn tile;\n}\n\n\n/**\n * Checks for line end. Also, bars crossing at next tile if needed\n *\n * @param v vehicle we are checking\n * @param reverse Set to false to not execute the vehicle reversing. This does not change any other logic.\n * @return true iff we did NOT have to reverse\n */\nstatic bool TrainCheckIfLineEnds(Train* v, bool reverse)\n{\n\t/* First, handle broken down train */\n\n\tif (HasBit(v->flags, VRF_BREAKDOWN_BRAKING)) {\n\t\tv->vehstatus |= VS_TRAIN_SLOWING;\n\t}\n\telse {\n\t\tv->vehstatus &= ~VS_TRAIN_SLOWING;\n\t}\n\n\tif (!TrainCanLeaveTile(v)) return true;\n\n\t/* Determine the non-diagonal direction in which we will exit this tile */\n\tDiagDirection dir = VehicleExitDir(v->direction, v->track);\n\t/* Calculate next tile */\n\tTileIndex tile = v->tile + TileOffsByDiagDir(dir);\n\n\t/* Determine the track status on the next tile */\n\tTrackStatus ts = GetTileTrackStatus(tile, TRANSPORT_RAIL, 0, ReverseDiagDir(dir));\n\tTrackdirBits reachable_trackdirs = DiagdirReachesTrackdirs(dir);\n\n\tTrackdirBits trackdirbits = TrackStatusToTrackdirBits(ts) & reachable_trackdirs;\n\tTrackdirBits red_signals = TrackStatusToRedSignals(ts) & reachable_trackdirs;\n\n\t/* We are sure the train is not entering a depot, it is detected above */\n\n\t/* mask unreachable track bits if we are forbidden to do 90deg turns */\n\tTrackBits bits = TrackdirBitsToTrackBits(trackdirbits);\n\tif (Rail90DegTurnDisallowedTilesFromDiagDir(v->tile, tile, dir)) {\n\t\tbits &= ~TrackCrossesTracks(FindFirstTrack(v->track));\n\t}\n\n\t/* no suitable trackbits at all || unusable rail (wrong type or owner) */\n\tif (bits == TRACK_BIT_NONE || !CheckCompatibleRail(v, tile, dir)) {\n\t\treturn TrainApproachingLineEnd(v, false, reverse);\n\t}\n\n\t/* approaching red signal */\n\tif ((trackdirbits & red_signals) != 0) return TrainApproachingLineEnd(v, true, reverse);\n\n\t/* approaching a rail/road crossing? then make it red */\n\tif (IsLevelCrossingTile(tile)) MaybeBarCrossingWithSound(tile);\n\n\tif (IsTileType(tile, MP_TUNNELBRIDGE) && GetTunnelBridgeTransportType(tile) == TRANSPORT_RAIL &&\n\t\tIsTunnelBridgeSignalSimulationEntrance(tile) && GetTunnelBridgeEntranceSignalState(tile) == SIGNAL_STATE_RED) {\n\t\treturn TrainApproachingLineEnd(v, true, reverse);\n\t}\n\n\treturn true;\n}\n\n/* Calculate the summed up value of all parts of a train */\nMoney Train::CalculateCurrentOverallValue() const\n{\n\tMoney ovr_value = 0;\n\tconst Train* v = this;\n\tdo {\n\t\tovr_value += v->value;\n\t} while ((v = v->GetNextVehicle()) != nullptr);\n\treturn ovr_value;\n}\n\nstatic bool TrainLocoHandler(Train* v, bool mode)\n{\n\t/* train has crashed? */\n\tif (v->vehstatus & VS_CRASHED) {\n\t\treturn mode ? true : HandleCrashedTrain(v); // 'this' can be deleted here\n\t}\n\n\tif (v->force_proceed != TFP_NONE) {\n\t\tClrBit(v->flags, VRF_TRAIN_STUCK);\n\t\tSetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n\t}\n\n\t/* train is broken down? */\n\tif (HasBit(v->flags, VRF_CONSIST_BREAKDOWN) && HandlePossibleBreakdowns(v)) return true;\n\n\tif (HasBit(v->flags, VRF_REVERSING) && v->cur_speed == 0) {\n\t\tReverseTrainDirection(v);\n\t}\n\n\t/* exit if train is stopped */\n\tif ((v->vehstatus & VS_STOPPED) && v->cur_speed == 0) return true;\n\n\tbool valid_order = !v->current_order.IsType(OT_NOTHING) && v->current_order.GetType() != OT_CONDITIONAL;\n\tif (ProcessOrders(v) && CheckReverseTrain(v)) {\n\t\tv->wait_counter = 0;\n\t\tv->cur_speed = 0;\n\t\tv->subspeed = 0;\n\t\tClrBit(v->flags, VRF_LEAVING_STATION);\n\t\tReverseTrainDirection(v);\n\t\treturn true;\n\t}\n\telse if (HasBit(v->flags, VRF_LEAVING_STATION)) {\n\t\t/* Try to reserve a path when leaving the station as we\n\t\t * might not be marked as wanting a reservation, e.g.\n\t\t * when an overlength train gets turned around in a station. */\n\t\tDiagDirection dir = VehicleExitDir(v->direction, v->track);\n\t\tif (IsRailDepotTile(v->tile) || IsTileType(v->tile, MP_TUNNELBRIDGE)) dir = INVALID_DIAGDIR;\n\n\t\tif (UpdateSignalsOnSegment(v->tile, dir, v->owner) == SIGSEG_PBS || _settings_game.pf.reserve_paths) {\n\t\t\tTryPathReserve(v, true, true);\n\t\t}\n\t\tClrBit(v->flags, VRF_LEAVING_STATION);\n\t}\n\n\tv->HandleLoading(mode);\n\n\tif (v->current_order.IsType(OT_LOADING)) return true;\n\n\tif (CheckTrainStayInDepot(v)) return true;\n\n\tif (v->current_order.IsType(OT_WAITING) && v->reverse_distance == 0) {\n\t\tv->HandleWaiting(false);\n\t\tif (v->current_order.IsType(OT_WAITING)) return true;\n\t\tProcessOrders(v);\n\t\tif (IsRailWaypointTile(v->tile)) {\n\t\t\tStationID station_id = GetStationIndex(v->tile);\n\t\t\tif (v->current_order.ShouldStopAtStation(v, station_id, true)) {\n\t\t\t\tUpdateVehicleTimetable(v, true);\n\t\t\t\tv->last_station_visited = station_id;\n\t\t\t\tSetWindowDirty(WC_VEHICLE_VIEW, v->index);\n\t\t\t\tv->current_order.MakeWaiting();\n\t\t\t\tv->current_order.SetNonStopType(ONSF_NO_STOP_AT_ANY_STATION);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mode) v->ShowVisualEffect();\n\n\t/* We had no order but have an order now, do look ahead. */\n\tif (!valid_order && !v->current_order.IsType(OT_NOTHING)) {\n\t\tCheckNextTrainTile(v);\n\t}\n\n\t/* Handle stuck trains. */\n\tif (!mode && HasBit(v->flags, VRF_TRAIN_STUCK)) {\n\t\t++v->wait_counter;\n\n\t\t/* Should we try reversing this tick if still stuck? */\n\t\tbool turn_around = v->wait_counter % (_settings_game.pf.wait_for_pbs_path * DAY_TICKS) == 0 && _settings_game.pf.reverse_at_signals;\n\n\t\tif (!turn_around && v->wait_counter % _settings_game.pf.path_backoff_interval != 0 && v->force_proceed == TFP_NONE) return true;\n\t\tif (!TryPathReserve(v)) {\n\t\t\t/* Still stuck. */\n\t\t\tif (turn_around) ReverseTrainDirection(v);\n\n\t\t\tif (HasBit(v->flags, VRF_TRAIN_STUCK) && v->wait_counter > 2 * _settings_game.pf.wait_for_pbs_path * DAY_TICKS) {\n\t\t\t\t/* Show message to player. */\n\t\t\t\tif (v->owner == _local_company && (HasBit(v->flags, VRF_WAITING_RESTRICTION) ? _settings_client.gui.restriction_wait_vehicle_warn : _settings_client.gui.lost_vehicle_warn)) {\n\t\t\t\t\tSetDParam(0, v->index);\n\t\t\t\t\tAddVehicleAdviceNewsItem(STR_NEWS_TRAIN_IS_STUCK, v->index);\n\t\t\t\t}\n\t\t\t\tv->wait_counter = 0;\n\t\t\t}\n\t\t\t/* Exit if force proceed not pressed, else reset stuck flag anyway. */\n\t\t\tif (v->force_proceed == TFP_NONE) return true;\n\t\t\tClrBit(v->flags, VRF_TRAIN_STUCK);\n\t\t\tv->wait_counter = 0;\n\t\t\tSetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n\t\t}\n\t}\n\n\tif (v->current_order.IsType(OT_LEAVESTATION)) {\n\t\tv->current_order.Free();\n\t\tSetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n\t\treturn true;\n\t}\n\n\tint j = v->UpdateSpeed();\n\n\t/* we need to invalidate the widget if we are stopping from 'Stopping 0 km/h' to 'Stopped' */\n\tif (v->cur_speed == 0 && (v->vehstatus & VS_STOPPED)) {\n\t\t/* If we manually stopped, we're not force-proceeding anymore. */\n\t\tv->force_proceed = TFP_NONE;\n\t\tSetWindowDirty(WC_VEHICLE_VIEW, v->index);\n\t}\n\n\tint adv_spd = v->GetAdvanceDistance();\n\tif (j < adv_spd) {\n\t\t/* if the vehicle has speed 0, update the last_speed field. */\n\t\tif (v->cur_speed == 0) v->SetLastSpeed();\n\t}\n\telse {\n\t\tTrainCheckIfLineEnds(v);\n\t\t/* Loop until the train has finished moving. */\n\t\tfor (;;) {\n\t\t\tj -= adv_spd;\n\t\t\tTrainController(v, nullptr);\n\t\t\t/* Don't continue to move if the train crashed. */\n\t\t\tif (CheckTrainCollision(v)) break;\n\t\t\t/* Determine distance to next map position */\n\t\t\tadv_spd = v->GetAdvanceDistance();\n\n\t\t\t/* No more moving this tick */\n\t\t\tif (j < adv_spd || v->cur_speed == 0) break;\n\n\t\t\tOrderType order_type = v->current_order.GetType();\n\t\t\t/* Do not skip waypoints (incl. 'via' stations) when passing through at full speed. */\n\t\t\tif ((order_type == OT_GOTO_WAYPOINT || order_type == OT_GOTO_STATION) &&\n\t\t\t\t(v->current_order.GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION) &&\n\t\t\t\tIsTileType(v->tile, MP_STATION) &&\n\t\t\t\tv->current_order.GetDestination() == GetStationIndex(v->tile)) {\n\t\t\t\tProcessOrders(v);\n\t\t\t}\n\t\t}\n\t\tv->SetLastSpeed();\n\t}\n\n\tfor (Train* u = v; u != nullptr; u = u->Next()) {\n\t\tif (!(u->IsDrawn())) continue;\n\n\t\tu->UpdateViewport(false, false);\n\t}\n\n\tif (v->progress == 0) v->progress = j; // Save unused spd for next time, if TrainController didn't set progress\n\n\treturn true;\n}\n\n/**\n * Get running cost for the train consist.\n * @return Yearly running costs.\n */\nMoney Train::GetRunningCost() const\n{\n\tMoney cost = 0;\n\tconst Train* v = this;\n\n\tdo {\n\t\tconst Engine* e = v->GetEngine();\n\t\tif (e->u.rail.running_cost_class == INVALID_PRICE) continue;\n\n\t\tuint cost_factor = GetVehicleProperty(v, PROP_TRAIN_RUNNING_COST_FACTOR, e->u.rail.running_cost);\n\t\tif (cost_factor == 0) continue;\n\n\t\t/* Halve running cost for multiheaded parts */\n\t\tif (v->IsMultiheaded()) cost_factor /= 2;\n\n\t\tcost += GetPrice(e->u.rail.running_cost_class, cost_factor, e->GetGRF());\n\t} while ((v = v->GetNextVehicle()) != nullptr);\n\n\treturn cost;\n}\n\n/**\n * Update train vehicle data for a tick.\n * @return True if the vehicle still exists, false if it has ceased to exist (front of consists only).\n */\nbool Train::Tick()\n{\n\tUpdateStateChecksum((((uint64)this->x_pos) << 32) | (this->y_pos << 16) | this->track);\n\tif (this->IsFrontEngine()) {\n\t\tif (!(this->vehstatus & VS_STOPPED) || this->cur_speed > 0) this->running_ticks++;\n\n\t\tthis->current_order_time++;\n\n\t\tif (!TrainLocoHandler(this, false)) return false;\n\n\t\treturn TrainLocoHandler(this, true);\n\t}\n\telse if (this->IsFreeWagon() && (this->vehstatus & VS_CRASHED)) {\n\t\t/* Delete flooded standalone wagon chain */\n\t\tif (++this->crash_anim_pos >= 4400) {\n\t\t\tdelete this;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Check whether a train needs service, and if so, find a depot or service it.\n * @return v %Train to check.\n */\nstatic void CheckIfTrainNeedsService(Train* v)\n{\n\tif (Company::Get(v->owner)->settings.vehicle.servint_trains == 0 || !v->NeedsAutomaticServicing()) return;\n\tif (v->IsChainInDepot()) {\n\t\tVehicleServiceInDepot(v);\n\t\treturn;\n\t}\n\n\tuint max_penalty;\n\tswitch (_settings_game.pf.pathfinder_for_trains) {\n\tcase VPF_NPF:  max_penalty = _settings_game.pf.npf.maximum_go_to_depot_penalty;  break;\n\tcase VPF_YAPF: max_penalty = _settings_game.pf.yapf.maximum_go_to_depot_penalty; break;\n\tdefault: NOT_REACHED();\n\t}\n\n\tFindDepotData tfdd = FindClosestTrainDepot(v, max_penalty);\n\t/* Only go to the depot if it is not too far out of our way. */\n\tif (tfdd.best_length == UINT_MAX || tfdd.best_length > max_penalty) {\n\t\tif (v->current_order.IsType(OT_GOTO_DEPOT)) {\n\t\t\t/* If we were already heading for a depot but it has\n\t\t\t * suddenly moved farther away, we continue our normal\n\t\t\t * schedule? */\n\t\t\tv->current_order.MakeDummy();\n\t\t\tSetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n\t\t}\n\t\treturn;\n\t}\n\n\tDepotID depot = GetDepotIndex(tfdd.tile);\n\n\tif (v->current_order.IsType(OT_GOTO_DEPOT) &&\n\t\tv->current_order.GetDestination() != depot &&\n\t\t!Chance16(3, 16)) {\n\t\treturn;\n\t}\n\n\tSetBit(v->gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS);\n\tv->current_order.MakeGoToDepot(depot, ODTFB_SERVICE);\n\tv->dest_tile = tfdd.tile;\n\tSetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);\n}\n\n/** Update day counters of the train vehicle. */\nvoid Train::OnNewDay()\n{\n\tAgeVehicle(this);\n\n\tif ((++this->day_counter & 7) == 0) DecreaseVehicleValue(this);\n\n\tif (this->IsFrontEngine()) {\n\t\tCheckIfTrainNeedsService(this);\n\n\t\tCheckOrders(this);\n\n\t\t/* update destination */\n\t\tif (this->current_order.IsType(OT_GOTO_STATION)) {\n\t\t\tTileIndex tile = Station::Get(this->current_order.GetDestination())->train_station.tile;\n\t\t\tif (tile != INVALID_TILE) this->dest_tile = tile;\n\t\t}\n\n\t\tif (this->running_ticks != 0) {\n\t\t\t/* running costs */\n\t\t\tCommandCost cost(EXPENSES_TRAIN_RUN, this->GetRunningCost() * this->running_ticks / (DAYS_IN_YEAR * DAY_TICKS));\n\n\t\t\t/* sharing fee */\n\t\t\tPayDailyTrackSharingFee(this);\n\n\t\t\tthis->profit_this_year -= cost.GetCost();\n\t\t\tthis->running_ticks = 0;\n\n\t\t\tSubtractMoneyFromCompanyFract(this->owner, cost);\n\n\t\t\tSetWindowDirty(WC_VEHICLE_DETAILS, this->index);\n\t\t\tSetWindowClassesDirty(WC_TRAINS_LIST);\n\t\t\tSetWindowClassesDirty(WC_TRACE_RESTRICT_SLOTS);\n\t\t}\n\t}\n\tif (IsEngine() || IsMultiheaded()) {\n\t\tCheckVehicleBreakdown(this);\n\t}\n}\n\n/**\n * Get the tracks of the train vehicle.\n * @return Current tracks of the vehicle.\n */\nTrackdir Train::GetVehicleTrackdir() const\n{\n\tif (this->vehstatus & VS_CRASHED) return INVALID_TRACKDIR;\n\n\tif (this->track == TRACK_BIT_DEPOT) {\n\t\t/* We'll assume the train is facing outwards */\n\t\treturn DiagDirToDiagTrackdir(GetRailDepotDirection(this->tile)); // Train in depot\n\t}\n\n\tif (this->track == TRACK_BIT_WORMHOLE) {\n\t\t/* Train in tunnel or on bridge, so just use his direction and make an educated guess\n\t\t * given the track bits on the tunnel/bridge head tile.\n\t\t * If a reachable track piece is reserved, use that, otherwise use the first reachable track piece.\n\t\t */\n\t\tTrackBits tracks = GetAcrossTunnelBridgeReservationTrackBits(this->tile);\n\t\tif (!tracks) tracks = GetAcrossTunnelBridgeTrackBits(this->tile);\n\t\tTrackdir td = TrackExitdirToTrackdir(FindFirstTrack(tracks), GetTunnelBridgeDirection(this->tile));\n\t\tif (GetTunnelBridgeDirection(this->tile) != DirToDiagDir(this->direction)) td = ReverseTrackdir(td);\n\t\treturn td;\n\t}\n\telse if (this->track & TRACK_BIT_WORMHOLE) {\n\t\treturn TrackDirectionToTrackdir(FindFirstTrack(this->track & TRACK_BIT_MASK), this->direction);\n\t}\n\n\treturn TrackDirectionToTrackdir(FindFirstTrack(this->track), this->direction);\n}\n\n/**\n * Delete a train while it is visible.\n * This happens when a company bankrupts when infrastructure sharing is enabled.\n * @param v The train to delete.\n */\nvoid DeleteVisibleTrain(Train* v)\n{\n\tSCOPE_INFO_FMT([v], \"DeleteVisibleTrain: %s\", scope_dumper().VehicleInfo(v));\n\n\tassert(!v->IsVirtual());\n\n\tFreeTrainTrackReservation(v);\n\tTileIndex crossing = TrainApproachingCrossingTile(v);\n\n\t/* delete train from back to front */\n\tTrain* u;\n\tTrain* prev = v->Last();\n\tdo {\n\t\tu = prev;\n\t\tprev = u->Previous();\n\t\tif (prev != nullptr) prev->SetNext(nullptr);\n\n\t\t/* 'u' shouldn't be accessed after it has been deleted */\n\t\tTileIndex tile = u->tile;\n\t\tTrackBits trackbits = u->track;\n\t\tbool in_wormhole = trackbits & TRACK_BIT_WORMHOLE;\n\n\t\tdelete u;\n\n\t\tif (in_wormhole) {\n\t\t\t/* Vehicle is inside a wormhole, u->track contains no useful value then. */\n\t\t\tif (IsTunnelBridgeWithSignalSimulation(tile)) {\n\t\t\t\tTileIndex end = GetOtherTunnelBridgeEnd(tile);\n\t\t\t\tAddSideToSignalBuffer(end, INVALID_DIAGDIR, GetTileOwner(tile));\n\t\t\t\tSetSignalledBridgeTunnelGreenIfClear(tile, end);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tTrack track = TrackBitsToTrack(trackbits);\n\t\t\tif (HasReservedTracks(tile, trackbits)) UnreserveRailTrack(tile, track);\n\t\t\tif (IsLevelCrossingTile(tile)) UpdateLevelCrossing(tile);\n\t\t}\n\n\t\t/* Update signals */\n\t\tif (in_wormhole || IsRailDepotTile(tile)) {\n\t\t\tAddSideToSignalBuffer(tile, INVALID_DIAGDIR, GetTileOwner(tile));\n\t\t}\n\t\telse {\n\t\t\tAddTrackToSignalBuffer(tile, TrackBitsToTrack(trackbits), GetTileOwner(tile));\n\t\t}\n\t} while (prev != nullptr);\n\n\tif (crossing != INVALID_TILE) UpdateLevelCrossing(crossing);\n\n\tUpdateSignalsInBuffer();\n}\n\n/* Get the pixel-width of the image that is used for the train vehicle\n * @return:\tthe image width number in pixel\n */\nint GetDisplayImageWidth(Train* t, Point* offset)\n{\n\tint reference_width = TRAININFO_DEFAULT_VEHICLE_WIDTH;\n\tint vehicle_pitch = 0;\n\n\tconst Engine* e = Engine::Get(t->engine_type);\n\tif (e->grf_prop.grffile != nullptr && is_custom_sprite(e->u.rail.image_index)) {\n\t\treference_width = e->grf_prop.grffile->traininfo_vehicle_width;\n\t\tvehicle_pitch = e->grf_prop.grffile->traininfo_vehicle_pitch;\n\t}\n\n\tif (offset != nullptr) {\n\t\toffset->x = reference_width / 2;\n\t\toffset->y = vehicle_pitch;\n\t}\n\treturn t->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH;\n}\n\nTrain* CmdBuildVirtualRailWagon(const Engine* e)\n{\n\tconst RailVehicleInfo* rvi = &e->u.rail;\n\n\tTrain* v = new Train();\n\n\tv->x_pos = 0;\n\tv->y_pos = 0;\n\n\tv->spritenum = rvi->image_index;\n\n\tv->engine_type = e->index;\n\tv->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback\n\n\tv->direction = DIR_W;\n\tv->tile = 0; // INVALID_TILE;\n\n\tv->owner = _current_company;\n\tv->track = TRACK_BIT_DEPOT;\n\tSetBit(v->flags, VRF_CONSIST_SPEED_REDUCTION);\n\tv->vehstatus = VS_HIDDEN | VS_DEFPAL;\n\n\tv->SetWagon();\n\tv->SetFreeWagon();\n\tv->SetVirtual();\n\n\tv->cargo_type = e->GetDefaultCargoType();\n\tv->cargo_cap = rvi->capacity;\n\n\tv->railtype = rvi->railtype;\n\n\tv->build_year = _cur_year;\n\tv->sprite_seq.Set(SPR_IMG_QUERY);\n\tv->random_bits = VehicleRandomBits();\n\n\tv->group_id = DEFAULT_GROUP;\n\n\tAddArticulatedParts(v);\n\n\t// Make sure we set EVERYTHING to virtual, even articulated parts.\n\tfor (Train* train_part = v; train_part != nullptr; train_part = train_part->Next()) {\n\t\ttrain_part->SetVirtual();\n\t}\n\n\t_new_vehicle_id = v->index;\n\n\tv->UpdateViewport(true, false);\n\n\tv->First()->ConsistChanged(CCF_ARRANGE);\n\n\tCheckConsistencyOfArticulatedVehicle(v);\n\n\tInvalidateVehicleTickCaches();\n\n\treturn v;\n}\n\nTrain* CmdBuildVirtualRailVehicle(EngineID eid, StringID& error)\n{\n\tconst Engine* e = Engine::GetIfValid(eid);\n\tif (e == nullptr || e->type != VEH_TRAIN) {\n\t\terror = STR_ERROR_RAIL_VEHICLE_NOT_AVAILABLE + VEH_TRAIN;\n\t\treturn nullptr;\n\t}\n\n\tconst RailVehicleInfo* rvi = &e->u.rail;\n\n\tint num_vehicles = (e->u.rail.railveh_type == RAILVEH_MULTIHEAD ? 2 : 1) + CountArticulatedParts(eid, false);\n\tif (!Train::CanAllocateItem(num_vehicles)) {\n\t\terror = STR_ERROR_TOO_MANY_VEHICLES_IN_GAME;\n\t\treturn nullptr;\n\t}\n\n\tRegisterGameEvents(GEF_VIRT_TRAIN);\n\n\tif (rvi->railveh_type == RAILVEH_WAGON) {\n\t\treturn CmdBuildVirtualRailWagon(e);\n\t}\n\n\tTrain* v = new Train();\n\n\tv->x_pos = 0;\n\tv->y_pos = 0;\n\n\tv->direction = DIR_W;\n\tv->tile = 0; // INVALID_TILE;\n\tv->owner = _current_company;\n\tv->track = TRACK_BIT_DEPOT;\n\tSetBit(v->flags, VRF_CONSIST_SPEED_REDUCTION);\n\tv->vehstatus = VS_HIDDEN | VS_STOPPED | VS_DEFPAL;\n\tv->spritenum = rvi->image_index;\n\tv->cargo_type = e->GetDefaultCargoType();\n\tv->cargo_cap = rvi->capacity;\n\tv->last_station_visited = INVALID_STATION;\n\n\tv->engine_type = e->index;\n\tv->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback\n\n\tv->reliability = e->reliability;\n\tv->reliability_spd_dec = e->reliability_spd_dec;\n\tv->max_age = e->GetLifeLengthInDays();\n\n\tv->railtype = rvi->railtype;\n\t_new_vehicle_id = v->index;\n\n\tv->build_year = _cur_year;\n\tv->sprite_seq.Set(SPR_IMG_QUERY);\n\tv->random_bits = VehicleRandomBits();\n\n\tv->group_id = DEFAULT_GROUP;\n\n\tv->SetFrontEngine();\n\tv->SetEngine();\n\tv->SetVirtual();\n\n\tif (rvi->railveh_type == RAILVEH_MULTIHEAD) {\n\t\tAddRearEngineToMultiheadedTrain(v);\n\t}\n\telse {\n\t\tAddArticulatedParts(v);\n\t}\n\n\t// Make sure we set EVERYTHING to virtual, even articulated parts.\n\tfor (Train* train_part = v; train_part != nullptr; train_part = train_part->Next()) {\n\t\ttrain_part->SetVirtual();\n\t}\n\n\tv->ConsistChanged(CCF_ARRANGE);\n\n\tCheckConsistencyOfArticulatedVehicle(v);\n\n\tInvalidateVehicleTickCaches();\n\n\treturn v;\n}\n\n/**\n * Build a virtual train vehicle.\n * @param tile unused\n * @param flags type of operation\n * @param p1 various bitstuffed data\n *  bits  0-15: vehicle type being built.\n *  bits 24-31: refit cargo type.\n * @param p2 unused\n * @param text unused\n * @return the cost of this operation or an error\n */\nCommandCost CmdBuildVirtualRailVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char* text)\n{\n\tEngineID eid = GB(p1, 0, 16);\n\n\tif (!IsEngineBuildable(eid, VEH_TRAIN, _current_company)) {\n\t\treturn_cmd_error(STR_ERROR_RAIL_VEHICLE_NOT_AVAILABLE + VEH_TRAIN);\n\t}\n\n\t/* Validate the cargo type. */\n\tCargoID cargo = GB(p1, 24, 8);\n\tif (cargo >= NUM_CARGO && cargo != CT_INVALID) return CMD_ERROR;\n\n\tbool should_execute = (flags & DC_EXEC) != 0;\n\n\tif (should_execute) {\n\t\tStringID err = INVALID_STRING_ID;\n\t\tTrain* train = CmdBuildVirtualRailVehicle(eid, err);\n\n\t\tif (train == nullptr) {\n\t\t\treturn_cmd_error(err);\n\t\t}\n\n\t\tif (cargo != CT_INVALID) {\n\t\t\tCargoID default_cargo = Engine::Get(eid)->GetDefaultCargoType();\n\t\t\tif (default_cargo != cargo) {\n\t\t\t\tCommandCost refit_res = CmdRefitVehicle(tile, flags, train->index, cargo, nullptr);\n\t\t\t\tif (!refit_res.Succeeded()) return refit_res;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn CommandCost();\n}\n\n/**\n* Replace a vehicle based on a template replacement order.\n* @param tile unused\n* @param flags type of operation\n* @param p1 the ID of the vehicle to replace.\n* @param p2 whether the vehicle should leave (1) or stay (0) in the depot.\n* @param text unused\n* @return the cost of this operation or an error\n*/\nCommandCost CmdTemplateReplaceVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char* text)\n{\n\tVehicleID vehicle_id = p1;\n\n\tVehicle* vehicle = Vehicle::GetIfValid(vehicle_id);\n\n\tif (vehicle == nullptr || vehicle->type != VEH_TRAIN) {\n\t\treturn CMD_ERROR;\n\t}\n\n\tbool should_execute = (flags & DC_EXEC) != 0;\n\n\tif (!should_execute) {\n\t\treturn CommandCost();\n\t}\n\n\tTrain* incoming = Train::From(vehicle);\n\tbool leaveDepot = (p2 != 0);\n\n\tTrain* new_chain = nullptr;\n\tTrain* remainder_chain = nullptr;\n\tTrain* tmp_chain = nullptr;\n\tTemplateVehicle* tv = GetTemplateVehicleByGroupIDRecursive(incoming->group_id);\n\tif (tv == nullptr) {\n\t\tif (leaveDepot) incoming->vehstatus &= ~VS_STOPPED;\n\t\treturn CMD_ERROR;\n\t}\n\tEngineID eid = tv->engine_type;\n\n\t_new_vehicle_id = p1;\n\n\tCommandCost buy(EXPENSES_NEW_VEHICLES);\n\tCommandCost move_cost(EXPENSES_NEW_VEHICLES);\n\tCommandCost tmp_result(EXPENSES_NEW_VEHICLES);\n\n\n\t/* first some tests on necessity and sanity */\n\tif (tv == nullptr) return buy;\n\tif (tv->IsReplaceOldOnly() && !vehicle->NeedsAutorenewing(Company::Get(vehicle->owner), false)) {\n\t\tif (leaveDepot) incoming->vehstatus &= ~VS_STOPPED;\n\t\treturn buy;\n\t}\n\tbool need_replacement = !TrainMatchesTemplate(incoming, tv);\n\tbool need_refit = !TrainMatchesTemplateRefit(incoming, tv);\n\tbool use_refit = tv->refit_as_template;\n\tCargoID store_refit_ct = CT_INVALID;\n\tshort store_refit_csubt = 0;\n\t// if a train shall keep its old refit, store the refit setting of its first vehicle\n\tif (!use_refit) {\n\t\tfor (Train* getc = incoming; getc != nullptr; getc = getc->GetNextUnit()) {\n\t\t\tif (getc->cargo_type != CT_INVALID) {\n\t\t\t\tstore_refit_ct = getc->cargo_type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: set result status to success/no success before returning\n\tif (!need_replacement) {\n\t\tif (!need_refit || !use_refit) {\n\t\t\t/* before returning, release incoming train first if 2nd param says so */\n\t\t\tif (leaveDepot) incoming->vehstatus &= ~VS_STOPPED;\n\t\t\treturn buy;\n\t\t}\n\t}\n\telse {\n\t\tCommandCost buyCost = TestBuyAllTemplateVehiclesInChain(tv, tile);\n\t\tif (!buyCost.Succeeded() || !CheckCompanyHasMoney(buyCost)) {\n\t\t\tif (leaveDepot) incoming->vehstatus &= ~VS_STOPPED;\n\n\t\t\tif (!buyCost.Succeeded() && buyCost.GetErrorMessage() != INVALID_STRING_ID) {\n\t\t\t\treturn buyCost;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn_cmd_error(STR_ERROR_NOT_ENOUGH_CASH_REQUIRES_CURRENCY);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (need_replacement || (need_refit && use_refit)) RegisterGameEvents(GEF_TBTR_REPLACEMENT);\n\n\t/* define replacement behavior */\n\tbool reuseDepot = tv->IsSetReuseDepotVehicles();\n\tbool keepRemainders = tv->IsSetKeepRemainingVehicles();\n\n\tif (need_replacement) {\n\t\t// step 1: generate primary for newchain and generate remainder_chain\n\t\t// 1. primary of incoming might already fit the template\n\t\t//    leave incoming's primary as is and move the rest to a free chain = remainder_chain\n\t\t// 2. needed primary might be one of incoming's member vehicles\n\t\t// 3. primary might be available as orphan vehicle in the depot\n\t\t// 4. we need to buy a new engine for the primary\n\t\t// all options other than 1. need to make sure to copy incoming's primary's status\n\t\tif (eid == incoming->engine_type) {                                                                       // 1\n\t\t\tnew_chain = incoming;\n\t\t\tremainder_chain = incoming->GetNextUnit();\n\t\t\tif (remainder_chain) {\n\t\t\t\tmove_cost.AddCost(CmdMoveRailVehicle(tile, flags, remainder_chain->index | (1 << 20), INVALID_VEHICLE, 0));\n\t\t\t}\n\t\t}\n\t\telse if ((tmp_chain = ChainContainsEngine(eid, incoming)) && tmp_chain != nullptr) {                       // 2\n\t\t // new_chain is the needed engine, move it to an empty spot in the depot\n\t\t\tnew_chain = tmp_chain;\n\t\t\tmove_cost.AddCost(DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags, CMD_MOVE_RAIL_VEHICLE));\n\t\t\tremainder_chain = incoming;\n\t\t}\n\t\telse if (reuseDepot && (tmp_chain = DepotContainsEngine(tile, eid, incoming)) && tmp_chain != nullptr) {   // 3\n\t\t\tnew_chain = tmp_chain;\n\t\t\tmove_cost.AddCost(DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags, CMD_MOVE_RAIL_VEHICLE));\n\t\t\tremainder_chain = incoming;\n\t\t}\n\t\telse {                                                                                                  // 4\n\t\t\ttmp_result = DoCommand(tile, eid, 0, flags, CMD_BUILD_VEHICLE);\n\t\t\t/* break up in case buying the vehicle didn't succeed */\n\t\t\tif (!tmp_result.Succeeded()) {\n\t\t\t\treturn tmp_result;\n\t\t\t}\n\t\t\tbuy.AddCost(tmp_result);\n\t\t\tnew_chain = Train::Get(_new_vehicle_id);\n\t\t\t/* make sure the newly built engine is not attached to any free wagons inside the depot */\n\t\t\tmove_cost.AddCost(DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags, CMD_MOVE_RAIL_VEHICLE));\n\t\t\t/* prepare the remainder chain */\n\t\t\tremainder_chain = incoming;\n\t\t}\n\t\t// If we bought a new engine or reused one from the depot, copy some parameters from the incoming primary engine\n\t\tif (incoming != new_chain && flags == DC_EXEC) {\n\t\t\tCopyHeadSpecificThings(incoming, new_chain, flags);\n\t\t\tNeutralizeStatus(incoming);\n\n\t\t\t// additionally, if we don't want to use the template refit, refit as incoming\n\t\t\t// the template refit will be set further down, if we use it at all\n\t\t\tif (!use_refit) {\n\t\t\t\tuint32 cb = GetCmdRefitVeh(new_chain);\n\t\t\t\tDoCommand(new_chain->tile, new_chain->index, store_refit_ct | store_refit_csubt << 8 | (1 << 16) | (1 << 31), flags, cb);\n\t\t\t}\n\t\t}\n\n\t\t// step 2: fill up newchain according to the template\n\t\t// foreach member of template (after primary):\n\t\t// 1. needed engine might be within remainder_chain already\n\t\t// 2. needed engine might be orphaned within the depot (copy status)\n\t\t// 3. we need to buy (again)                           (copy status)\n\t\tTemplateVehicle* cur_tmpl = tv->GetNextUnit();\n\t\tTrain* last_veh = new_chain;\n\t\twhile (cur_tmpl) {\n\t\t\t// 1. engine contained in remainder chain\n\t\t\tif ((tmp_chain = ChainContainsEngine(cur_tmpl->engine_type, remainder_chain)) && tmp_chain != nullptr) {\n\t\t\t\t// advance remainder_chain (if necessary) to not lose track of it\n\t\t\t\tif (tmp_chain == remainder_chain) {\n\t\t\t\t\tremainder_chain = remainder_chain->GetNextUnit();\n\t\t\t\t}\n\t\t\t\tmove_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));\n\t\t\t}\n\t\t\t// 2. engine contained somewhere else in the depot\n\t\t\telse if (reuseDepot && (tmp_chain = DepotContainsEngine(tile, cur_tmpl->engine_type, new_chain)) && tmp_chain != nullptr) {\n\t\t\t\tmove_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));\n\t\t\t}\n\t\t\t// 3. must buy new engine\n\t\t\telse {\n\t\t\t\ttmp_result = DoCommand(tile, cur_tmpl->engine_type, 0, flags, CMD_BUILD_VEHICLE);\n\t\t\t\tif (!tmp_result.Succeeded()) {\n\t\t\t\t\treturn tmp_result;\n\t\t\t\t}\n\t\t\t\tbuy.AddCost(tmp_result);\n\t\t\t\ttmp_chain = Train::Get(_new_vehicle_id);\n\t\t\t\tmove_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));\n\t\t\t}\n\t\t\t// TODO: is this enough ? might it be that we bought a new wagon here and it now has std refit ?\n\t\t\tif (need_refit && flags == DC_EXEC) {\n\t\t\t\tif (use_refit) {\n\t\t\t\t\tuint32 cb = GetCmdRefitVeh(tmp_chain);\n\t\t\t\t\tDoCommand(tmp_chain->tile, tmp_chain->index, cur_tmpl->cargo_type | (cur_tmpl->cargo_subtype << 8) | (1 << 16) | (1 << 31), flags, cb);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuint32 cb = GetCmdRefitVeh(tmp_chain);\n\t\t\t\t\tDoCommand(tmp_chain->tile, tmp_chain->index, store_refit_ct | (store_refit_csubt << 8) | (1 << 16) | (1 << 31), flags, cb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur_tmpl = cur_tmpl->GetNextUnit();\n\t\t\tlast_veh = tmp_chain;\n\t\t}\n\t}\n\t/* no replacement done */\n\telse {\n\t\tnew_chain = incoming;\n\t}\n\t/// step 3: reorder and neutralize the remaining vehicles from incoming\n\t// wagons remaining from remainder_chain should be filled up in as few freewagonchains as possible\n\t// each locos might be left as singular in the depot\n\t// neutralize each remaining engine's status\n\n\t// refit, only if the template option is set so\n\tif (use_refit && (need_refit || need_replacement)) {\n\t\tbuy.AddCost(CmdRefitTrainFromTemplate(new_chain, tv, flags));\n\t}\n\n\tif (new_chain && remainder_chain) {\n\t\tfor (Train* ct = remainder_chain; ct; ct = ct->GetNextUnit()) {\n\t\t\tTransferCargoForTrain(ct, new_chain);\n\t\t}\n\t}\n\n\t// point incoming to the newly created train so that starting/stopping from the calling function can be done\n\tincoming = new_chain;\n\tif (leaveDepot && flags == DC_EXEC) {\n\t\tnew_chain->vehstatus &= ~VS_STOPPED;\n\t}\n\n\tif (remainder_chain && keepRemainders && flags == DC_EXEC) {\n\t\tBreakUpRemainders(remainder_chain);\n\t}\n\telse if (remainder_chain) {\n\t\tbuy.AddCost(DoCommand(tile, remainder_chain->index | (1 << 20), 0, flags, CMD_SELL_VEHICLE));\n\t}\n\n\t/* Redraw main gui for changed statistics */\n\tSetWindowClassesDirty(WC_TEMPLATEGUI_MAIN);\n\n\t_new_vehicle_id = new_chain->index;\n\n\treturn buy;\n}\n\nvoid TrainRoadVehicleCrashBreakdown(Vehicle* v)\n{\n\tTrain* t = Train::From(v)->First();\n\tt->breakdown_ctr = 2;\n\tSetBit(t->flags, VRF_CONSIST_BREAKDOWN);\n\tt->breakdown_delay = 255;\n\tt->breakdown_type = BREAKDOWN_RV_CRASH;\n\tt->breakdown_severity = 0;\n\tt->reliability = 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
--- a/src/train_cmd.cpp	(revision 4eb175746c01e644311535ded9c993e381c3e6cb)
+++ b/src/train_cmd.cpp	(date 1642741627577)
@@ -3185,7 +3185,11 @@
 		if (track != INVALID_TRACK && HasPbsSignalOnTrackdir(tile, TrackEnterdirToTrackdir(track, enterdir))) {
 			if (IsRestrictedSignal(tile) && v->force_proceed != TFP_SIGNAL) {
 				const TraceRestrictProgram* prog = GetExistingTraceRestrictProgram(tile, track);
+<<<<<<< HEAD
 				if (prog && prog->actions_used_flags & (TRPAUF_WAIT_AT_PBS | TRPAUF_SLOT_ACQUIRE | TRPAUF_TRAIN_NOT_STUCK)) {
+=======
+				if (prog && prog->actions_used_flags & (TRPAUF_WAIT_AT_PBS | TRPAUF_SLOT_ACQUIRE)) {
+>>>>>>> Added setting for train max speed
 					TraceRestrictProgramResult out;
 					TraceRestrictProgramInput input(tile, TrackEnterdirToTrackdir(track, enterdir), nullptr, nullptr);
 					input.permitted_slot_operations = TRPISP_ACQUIRE;
@@ -4199,7 +4203,11 @@
 							const Trackdir dir = FindFirstTrackdir(trackdirbits);
 							if (HasSignalOnTrack(gp.new_tile, TrackdirToTrack(dir))) {
 								const TraceRestrictProgram* prog = GetExistingTraceRestrictProgram(gp.new_tile, TrackdirToTrack(dir));
+<<<<<<< HEAD
 								if (prog && prog->actions_used_flags & (TRPAUF_SLOT_ACQUIRE | TRPAUF_SLOT_RELEASE_FRONT | TRPAUF_REVERSE | TRPAUF_SPEED_RESTRICTION | TRPAUF_CHANGE_COUNTER)) {
+=======
+								if (prog && prog->actions_used_flags & (TRPAUF_SLOT_ACQUIRE | TRPAUF_SLOT_RELEASE_FRONT | TRPAUF_REVERSE | TRPAUF_SPEED_RESTRICTION)) {
+>>>>>>> Added setting for train max speed
 									TraceRestrictProgramResult out;
 									TraceRestrictProgramInput input(gp.new_tile, dir, nullptr, nullptr);
 									input.permitted_slot_operations = TRPISP_ACQUIRE | TRPISP_RELEASE_FRONT | TRPISP_CHANGE_COUNTER;
